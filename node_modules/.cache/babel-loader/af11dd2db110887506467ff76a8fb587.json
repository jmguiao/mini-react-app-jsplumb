{"ast":null,"code":"(function () {\n  function a(a, b) {\n    return [-a[0][b] + 3 * a[1][b] + -3 * a[2][b] + a[3][b], 3 * a[0][b] - 6 * a[1][b] + 3 * a[2][b], -3 * a[0][b] + 3 * a[1][b], a[0][b]];\n  }\n\n  function b(b) {\n    return [a(b, \"x\"), a(b, \"y\")];\n  }\n\n  function c(a) {\n    return 0 > a ? -1 : a > 0 ? 1 : 0;\n  }\n\n  function d(a, b, d, e) {\n    var f,\n        g,\n        h = b / a,\n        i = d / a,\n        j = e / a,\n        k = (3 * i - Math.pow(h, 2)) / 9,\n        l = (9 * h * i - 27 * j - 2 * Math.pow(h, 3)) / 54,\n        m = Math.pow(k, 3) + Math.pow(l, 2),\n        n = [];\n    if (m >= 0) f = c(l + Math.sqrt(m)) * Math.pow(Math.abs(l + Math.sqrt(m)), 1 / 3), g = c(l - Math.sqrt(m)) * Math.pow(Math.abs(l - Math.sqrt(m)), 1 / 3), n[0] = -h / 3 + (f + g), n[1] = -h / 3 - (f + g) / 2, n[2] = -h / 3 - (f + g) / 2, 0 !== Math.abs(Math.sqrt(3) * (f - g) / 2) && (n[1] = -1, n[2] = -1);else {\n      var o = Math.acos(l / Math.sqrt(-Math.pow(k, 3)));\n      n[0] = 2 * Math.sqrt(-k) * Math.cos(o / 3) - h / 3, n[1] = 2 * Math.sqrt(-k) * Math.cos((o + 2 * Math.PI) / 3) - h / 3, n[2] = 2 * Math.sqrt(-k) * Math.cos((o + 4 * Math.PI) / 3) - h / 3;\n    }\n\n    for (var p = 0; 3 > p; p++) {\n      (n[p] < 0 || n[p] > 1) && (n[p] = -1);\n    }\n\n    return n;\n  }\n\n  \"undefined\" == typeof Math.sgn && (Math.sgn = function (a) {\n    return 0 == a ? 0 : a > 0 ? 1 : -1;\n  });\n\n  var e = {\n    subtract: function subtract(a, b) {\n      return {\n        x: a.x - b.x,\n        y: a.y - b.y\n      };\n    },\n    dotProduct: function dotProduct(a, b) {\n      return a.x * b.x + a.y * b.y;\n    },\n    square: function square(a) {\n      return Math.sqrt(a.x * a.x + a.y * a.y);\n    },\n    scale: function scale(a, b) {\n      return {\n        x: a.x * b,\n        y: a.y * b\n      };\n    }\n  },\n      f = 64,\n      g = Math.pow(2, -f - 1),\n      h = function h(a, b) {\n    for (var c = [], d = j(a, b), f = b.length - 1, g = 2 * f - 1, h = k(d, g, c, 0), i = e.subtract(a, b[0]), l = e.square(i), m = 0, n = 0; h > n; n++) {\n      i = e.subtract(a, o(b, f, c[n], null, null));\n      var p = e.square(i);\n      l > p && (l = p, m = c[n]);\n    }\n\n    return i = e.subtract(a, b[f]), p = e.square(i), l > p && (l = p, m = 1), {\n      location: m,\n      distance: l\n    };\n  },\n      i = function i(a, b) {\n    var c = h(a, b);\n    return {\n      point: o(b, b.length - 1, c.location, null, null),\n      location: c.location\n    };\n  },\n      j = function j(a, b) {\n    for (var c = b.length - 1, d = 2 * c - 1, f = [], g = [], h = [], i = [], j = [[1, .6, .3, .1], [.4, .6, .6, .4], [.1, .3, .6, 1]], k = 0; c >= k; k++) {\n      f[k] = e.subtract(b[k], a);\n    }\n\n    for (var k = 0; c - 1 >= k; k++) {\n      g[k] = e.subtract(b[k + 1], b[k]), g[k] = e.scale(g[k], 3);\n    }\n\n    for (var l = 0; c - 1 >= l; l++) {\n      for (var m = 0; c >= m; m++) {\n        h[l] || (h[l] = []), h[l][m] = e.dotProduct(g[l], f[m]);\n      }\n    }\n\n    for (k = 0; d >= k; k++) {\n      i[k] || (i[k] = []), i[k].y = 0, i[k].x = parseFloat(k) / d;\n    }\n\n    for (var n = c, o = c - 1, p = 0; n + o >= p; p++) {\n      var q = Math.max(0, p - o),\n          r = Math.min(p, n);\n\n      for (k = q; r >= k; k++) {\n        var s = p - k;\n        i[k + s].y += h[s][k] * j[s][k];\n      }\n    }\n\n    return i;\n  },\n      k = function k(a, b, c, d) {\n    var e,\n        g,\n        h = [],\n        i = [],\n        j = [],\n        p = [];\n\n    switch (l(a, b)) {\n      case 0:\n        return 0;\n\n      case 1:\n        if (d >= f) return c[0] = (a[0].x + a[b].x) / 2, 1;\n        if (m(a, b)) return c[0] = n(a, b), 1;\n    }\n\n    o(a, b, .5, h, i), e = k(h, b, j, d + 1), g = k(i, b, p, d + 1);\n\n    for (var q = 0; e > q; q++) {\n      c[q] = j[q];\n    }\n\n    for (var q = 0; g > q; q++) {\n      c[q + e] = p[q];\n    }\n\n    return e + g;\n  },\n      l = function l(a, b) {\n    var c,\n        d,\n        e = 0;\n    c = d = Math.sgn(a[0].y);\n\n    for (var f = 1; b >= f; f++) {\n      c = Math.sgn(a[f].y), c != d && e++, d = c;\n    }\n\n    return e;\n  },\n      m = function m(a, b) {\n    var c, d, e, f, h, i, j, k, l, m, n, o, p, q, r, s;\n    i = a[0].y - a[b].y, j = a[b].x - a[0].x, k = a[0].x * a[b].y - a[b].x * a[0].y;\n    var t, u;\n    t = u = 0;\n\n    for (var v = 1; b > v; v++) {\n      var w = i * a[v].x + j * a[v].y + k;\n      w > t ? t = w : u > w && (u = w);\n    }\n\n    return n = 0, o = 1, p = 0, q = i, r = j, s = k - t, l = n * r - q * o, m = 1 / l, d = (o * s - r * p) * m, q = i, r = j, s = k - u, l = n * r - q * o, m = 1 / l, e = (o * s - r * p) * m, f = Math.min(d, e), h = Math.max(d, e), c = h - f, g > c ? 1 : 0;\n  },\n      n = function n(a, b) {\n    var c = 1,\n        d = 0,\n        e = a[b].x - a[0].x,\n        f = a[b].y - a[0].y,\n        g = a[0].x - 0,\n        h = a[0].y - 0,\n        i = e * d - f * c,\n        j = 1 / i,\n        k = (e * h - f * g) * j;\n    return 0 + c * k;\n  },\n      o = function o(a, b, c, d, e) {\n    for (var f = [[]], g = 0; b >= g; g++) {\n      f[0][g] = a[g];\n    }\n\n    for (var h = 1; b >= h; h++) {\n      for (var g = 0; b - h >= g; g++) {\n        f[h] || (f[h] = []), f[h][g] || (f[h][g] = {}), f[h][g].x = (1 - c) * f[h - 1][g].x + c * f[h - 1][g + 1].x, f[h][g].y = (1 - c) * f[h - 1][g].y + c * f[h - 1][g + 1].y;\n      }\n    }\n\n    if (null != d) for (g = 0; b >= g; g++) {\n      d[g] = f[g][0];\n    }\n    if (null != e) for (g = 0; b >= g; g++) {\n      e[g] = f[b - g][g];\n    }\n    return f[b][0];\n  },\n      p = {},\n      q = function q(a) {\n    var b = p[a];\n\n    if (!b) {\n      b = [];\n\n      var c = function c() {\n        return function (b) {\n          return Math.pow(b, a);\n        };\n      },\n          d = function d() {\n        return function (b) {\n          return Math.pow(1 - b, a);\n        };\n      },\n          e = function e(a) {\n        return function (b) {\n          return a;\n        };\n      },\n          f = function f() {\n        return function (a) {\n          return a;\n        };\n      },\n          g = function g() {\n        return function (a) {\n          return 1 - a;\n        };\n      },\n          h = function h(a) {\n        return function (b) {\n          for (var c = 1, d = 0; d < a.length; d++) {\n            c *= a[d](b);\n          }\n\n          return c;\n        };\n      };\n\n      b.push(new c());\n\n      for (var i = 1; a > i; i++) {\n        for (var j = [new e(a)], k = 0; a - i > k; k++) {\n          j.push(new f());\n        }\n\n        for (var k = 0; i > k; k++) {\n          j.push(new g());\n        }\n\n        b.push(new h(j));\n      }\n\n      b.push(new d()), p[a] = b;\n    }\n\n    return b;\n  },\n      r = function r(a, b) {\n    for (var c = q(a.length - 1), d = 0, e = 0, f = 0; f < a.length; f++) {\n      d += a[f].x * c[f](b), e += a[f].y * c[f](b);\n    }\n\n    return {\n      x: d,\n      y: e\n    };\n  },\n      s = function s(a, b) {\n    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n  },\n      t = function t(a) {\n    return a[0].x === a[1].x && a[0].y === a[1].y;\n  },\n      u = function u(a, b, c) {\n    if (t(a)) return {\n      point: a[0],\n      location: b\n    };\n\n    for (var d = r(a, b), e = 0, f = b, g = c > 0 ? 1 : -1, h = null; e < Math.abs(c);) {\n      f += .005 * g, h = r(a, f), e += s(h, d), d = h;\n    }\n\n    return {\n      point: h,\n      location: f\n    };\n  },\n      v = function v(a) {\n    if (t(a)) return 0;\n\n    for (var b = r(a, 0), c = 0, d = 0, e = 1, f = null; 1 > d;) {\n      d += .005 * e, f = r(a, d), c += s(f, b), b = f;\n    }\n\n    return c;\n  },\n      w = function w(a, b, c) {\n    return u(a, b, c).point;\n  },\n      x = function x(a, b, c) {\n    return u(a, b, c).location;\n  },\n      y = function y(a, b) {\n    var c = r(a, b),\n        d = r(a.slice(0, a.length - 1), b),\n        e = d.y - c.y,\n        f = d.x - c.x;\n    return 0 === e ? 1 / 0 : Math.atan(e / f);\n  },\n      z = function z(a, b, c) {\n    var d = u(a, b, c);\n    return d.location > 1 && (d.location = 1), d.location < 0 && (d.location = 0), y(a, d.location);\n  },\n      A = function A(a, b, c, d) {\n    d = null == d ? 0 : d;\n    var e = u(a, b, d),\n        f = y(a, e.location),\n        g = Math.atan(-1 / f),\n        h = c / 2 * Math.sin(g),\n        i = c / 2 * Math.cos(g);\n    return [{\n      x: e.point.x + i,\n      y: e.point.y + h\n    }, {\n      x: e.point.x - i,\n      y: e.point.y - h\n    }];\n  },\n      B = function B(a, c, e, f, g) {\n    var h = f - c,\n        i = a - e,\n        j = a * (c - f) + c * (e - a),\n        k = b(g),\n        l = [h * k[0][0] + i * k[1][0], h * k[0][1] + i * k[1][1], h * k[0][2] + i * k[1][2], h * k[0][3] + i * k[1][3] + j],\n        m = d.apply(null, l),\n        n = [];\n    if (null != m) for (var o = 0; 3 > o; o++) {\n      var p,\n          q = m[o],\n          r = Math.pow(q, 2),\n          s = Math.pow(q, 3),\n          t = [k[0][0] * s + k[0][1] * r + k[0][2] * q + k[0][3], k[1][0] * s + k[1][1] * r + k[1][2] * q + k[1][3]];\n      p = e - a !== 0 ? (t[0] - a) / (e - a) : (t[1] - c) / (f - c), q >= 0 && 1 >= q && p >= 0 && 1 >= p && n.push(t);\n    }\n    return n;\n  },\n      C = function C(a, b, c, d, e) {\n    var f = [];\n    return f.push.apply(f, B(a, b, a + c, b, e)), f.push.apply(f, B(a + c, b, a + c, b + d, e)), f.push.apply(f, B(a + c, b + d, a, b + d, e)), f.push.apply(f, B(a, b + d, a, b, e)), f;\n  },\n      D = function D(a, b) {\n    var c = [];\n    return c.push.apply(c, B(a.x, a.y, a.x + a.w, a.y, b)), c.push.apply(c, B(a.x + a.w, a.y, a.x + a.w, a.y + a.h, b)), c.push.apply(c, B(a.x + a.w, a.y + a.h, a.x, a.y + a.h, b)), c.push.apply(c, B(a.x, a.y + a.h, a.x, a.y, b)), c;\n  },\n      E = this.jsBezier = {\n    distanceFromCurve: h,\n    gradientAtPoint: y,\n    gradientAtPointAlongCurveFrom: z,\n    nearestPointOnCurve: i,\n    pointOnCurve: r,\n    pointAlongCurveFrom: w,\n    perpendicularToCurveAt: A,\n    locationAlongCurveFrom: x,\n    getLength: v,\n    lineIntersection: B,\n    boxIntersection: C,\n    boundingBoxIntersection: D,\n    version: \"0.9.0\"\n  };\n\n  \"undefined\" != typeof exports && (exports.jsBezier = E);\n}).call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this,\n      b = a.Biltong = {\n    version: \"0.4.0\"\n  };\n  \"undefined\" != typeof exports && (exports.Biltong = b);\n\n  var c = function c(a) {\n    return \"[object Array]\" === Object.prototype.toString.call(a);\n  },\n      d = function d(a, b, _d) {\n    return a = c(a) ? a : [a.x, a.y], b = c(b) ? b : [b.x, b.y], _d(a, b);\n  },\n      e = b.gradient = function (a, b) {\n    return d(a, b, function (a, b) {\n      return b[0] == a[0] ? b[1] > a[1] ? 1 / 0 : -(1 / 0) : b[1] == a[1] ? b[0] > a[0] ? 0 : -0 : (b[1] - a[1]) / (b[0] - a[0]);\n    });\n  },\n      f = (b.normal = function (a, b) {\n    return -1 / e(a, b);\n  }, b.lineLength = function (a, b) {\n    return d(a, b, function (a, b) {\n      return Math.sqrt(Math.pow(b[1] - a[1], 2) + Math.pow(b[0] - a[0], 2));\n    });\n  }, b.quadrant = function (a, b) {\n    return d(a, b, function (a, b) {\n      return b[0] > a[0] ? b[1] > a[1] ? 2 : 1 : b[0] == a[0] ? b[1] > a[1] ? 2 : 1 : b[1] > a[1] ? 3 : 4;\n    });\n  }),\n      g = (b.theta = function (a, b) {\n    return d(a, b, function (a, b) {\n      var c = e(a, b),\n          d = Math.atan(c),\n          g = f(a, b);\n      return (4 == g || 3 == g) && (d += Math.PI), 0 > d && (d += 2 * Math.PI), d;\n    });\n  }, b.intersects = function (a, b) {\n    var c = a.x,\n        d = a.x + a.w,\n        e = a.y,\n        f = a.y + a.h,\n        g = b.x,\n        h = b.x + b.w,\n        i = b.y,\n        j = b.y + b.h;\n    return g >= c && d >= g && i >= e && f >= i || h >= c && d >= h && i >= e && f >= i || g >= c && d >= g && j >= e && f >= j || h >= c && d >= g && j >= e && f >= j || c >= g && h >= c && e >= i && j >= e || d >= g && h >= d && e >= i && j >= e || c >= g && h >= c && f >= i && j >= f || d >= g && h >= c && f >= i && j >= f;\n  }, b.encloses = function (a, b, c) {\n    var d = a.x,\n        e = a.x + a.w,\n        f = a.y,\n        g = a.y + a.h,\n        h = b.x,\n        i = b.x + b.w,\n        j = b.y,\n        k = b.y + b.h,\n        l = function l(a, b, d, e) {\n      return c ? b >= a && d >= e : b > a && d > e;\n    };\n\n    return l(d, h, e, i) && l(f, j, g, k);\n  }, [null, [1, -1], [1, 1], [-1, 1], [-1, -1]]),\n      h = [null, [-1, -1], [-1, 1], [1, 1], [1, -1]];\n\n  b.pointOnLine = function (a, b, c) {\n    var d = e(a, b),\n        i = f(a, b),\n        j = c > 0 ? g[i] : h[i],\n        k = Math.atan(d),\n        l = Math.abs(c * Math.sin(k)) * j[1],\n        m = Math.abs(c * Math.cos(k)) * j[0];\n    return {\n      x: a.x + m,\n      y: a.y + l\n    };\n  }, b.perpendicularLineTo = function (a, b, c) {\n    var d = e(a, b),\n        f = Math.atan(-1 / d),\n        g = c / 2 * Math.sin(f),\n        h = c / 2 * Math.cos(f);\n    return [{\n      x: b.x + h,\n      y: b.y + g\n    }, {\n      x: b.x - h,\n      y: b.y - g\n    }];\n  };\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  function a(a, b, c, d, e, f, g, h) {\n    return new Touch({\n      target: b,\n      identifier: J(),\n      pageX: c,\n      pageY: d,\n      screenX: e,\n      screenY: f,\n      clientX: g || e,\n      clientY: h || f\n    });\n  }\n\n  function b() {\n    var a = [];\n    return Array.prototype.push.apply(a, arguments), a.item = function (a) {\n      return this[a];\n    }, a;\n  }\n\n  function c(c, d, e, f, g, h, i, j) {\n    return b(a.apply(null, arguments));\n  }\n\n  var d = this,\n      e = function e(a, b, c) {\n    c = c || a.parentNode;\n\n    for (var d = c.querySelectorAll(b), e = 0; e < d.length; e++) {\n      if (d[e] === a) return !0;\n    }\n\n    return !1;\n  },\n      f = function f(a) {\n    return \"string\" == typeof a || a.constructor === String ? document.getElementById(a) : a;\n  },\n      g = function g(a) {\n    return a.srcElement || a.target;\n  },\n      h = function h(a, b, c, d) {\n    if (d) {\n      if (\"undefined\" != typeof a.path && a.path.indexOf) return {\n        path: a.path,\n        end: a.path.indexOf(c)\n      };\n\n      var e = {\n        path: [],\n        end: -1\n      },\n          f = function f(a) {\n        e.path.push(a), a === c ? e.end = e.path.length - 1 : null != a.parentNode && f(a.parentNode);\n      };\n\n      return f(b), e;\n    }\n\n    return {\n      path: [b],\n      end: 1\n    };\n  },\n      i = function i(a, b) {\n    for (var c = 0, d = a.length; d > c && a[c] != b; c++) {\n      ;\n    }\n\n    c < a.length && a.splice(c, 1);\n  },\n      j = 1,\n      k = function k(a, b, c) {\n    var d = j++;\n    return a.__ta = a.__ta || {}, a.__ta[b] = a.__ta[b] || {}, a.__ta[b][d] = c, c.__tauid = d, d;\n  },\n      l = function l(a, b, c) {\n    if (a.__ta && a.__ta[b] && delete a.__ta[b][c.__tauid], c.__taExtra) {\n      for (var d = 0; d < c.__taExtra.length; d++) {\n        H(a, c.__taExtra[d][0], c.__taExtra[d][1]);\n      }\n\n      c.__taExtra.length = 0;\n    }\n\n    c.__taUnstore && c.__taUnstore();\n  },\n      m = function m(a, b, c, d) {\n    if (null == a) return c;\n\n    var f = a.split(\",\"),\n        i = function i(d) {\n      i.__tauid = c.__tauid;\n      var j = g(d),\n          k = j,\n          l = h(d, j, b, null != a);\n      if (-1 != l.end) for (var m = 0; m < l.end; m++) {\n        k = l.path[m];\n\n        for (var n = 0; n < f.length; n++) {\n          e(k, f[n], b) && c.apply(k, arguments);\n        }\n      }\n    };\n\n    return n(c, d, i), i;\n  },\n      n = function n(a, b, c) {\n    a.__taExtra = a.__taExtra || [], a.__taExtra.push([b, c]);\n  },\n      o = function o(a, b, c, d) {\n    if (u && w[b]) {\n      var e = m(d, a, c, w[b]);\n      G(a, w[b], e, c);\n    }\n\n    \"focus\" === b && null == a.getAttribute(\"tabindex\") && a.setAttribute(\"tabindex\", \"1\"), G(a, b, m(d, a, c, b), c);\n  },\n      p = function p(a, b, c, d) {\n    if (null == a.__taSmartClicks) {\n      var e = function e(b) {\n        a.__tad = A(b);\n      },\n          f = function f(b) {\n        a.__tau = A(b);\n      },\n          h = function h(b) {\n        if (a.__tad && a.__tau && a.__tad[0] === a.__tau[0] && a.__tad[1] === a.__tau[1]) for (var c = 0; c < a.__taSmartClicks.length; c++) {\n          a.__taSmartClicks[c].apply(g(b), [b]);\n        }\n      };\n\n      o(a, \"mousedown\", e, d), o(a, \"mouseup\", f, d), o(a, \"click\", h, d), a.__taSmartClicks = [];\n    }\n\n    a.__taSmartClicks.push(c), c.__taUnstore = function () {\n      i(a.__taSmartClicks, c);\n    };\n  },\n      q = {\n    tap: {\n      touches: 1,\n      taps: 1\n    },\n    dbltap: {\n      touches: 1,\n      taps: 2\n    },\n    contextmenu: {\n      touches: 2,\n      taps: 1\n    }\n  },\n      r = function r(a, b) {\n    return function (c, d, f, j) {\n      if (\"contextmenu\" == d && v) o(c, d, f, j);else {\n        if (null == c.__taTapHandler) {\n          var k = c.__taTapHandler = {\n            tap: [],\n            dbltap: [],\n            contextmenu: [],\n            down: !1,\n            taps: 0,\n            downSelectors: []\n          },\n              l = function l(d) {\n            for (var f = g(d), i = h(d, f, c, null != j), l = !1, m = 0; m < i.end; m++) {\n              if (l) return;\n              f = i.path[m];\n\n              for (var o = 0; o < k.downSelectors.length; o++) {\n                if (null == k.downSelectors[o] || e(f, k.downSelectors[o], c)) {\n                  k.down = !0, setTimeout(n, a), setTimeout(p, b), l = !0;\n                  break;\n                }\n              }\n            }\n          },\n              m = function m(a) {\n            if (k.down) {\n              var b,\n                  d,\n                  f = g(a);\n              k.taps++;\n              var i = F(a);\n\n              for (var j in q) {\n                if (q.hasOwnProperty(j)) {\n                  var l = q[j];\n                  if (l.touches === i && (1 === l.taps || l.taps === k.taps)) for (var m = 0; m < k[j].length; m++) {\n                    d = h(a, f, c, null != k[j][m][1]);\n\n                    for (var n = 0; n < d.end; n++) {\n                      if (b = d.path[n], null == k[j][m][1] || e(b, k[j][m][1], c)) {\n                        k[j][m][0].apply(b, [a]);\n                        break;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          },\n              n = function n() {\n            k.down = !1;\n          },\n              p = function p() {\n            k.taps = 0;\n          };\n\n          o(c, \"mousedown\", l), o(c, \"mouseup\", m);\n        }\n\n        c.__taTapHandler.downSelectors.push(j), c.__taTapHandler[d].push([f, j]), f.__taUnstore = function () {\n          i(c.__taTapHandler[d], f);\n        };\n      }\n    };\n  },\n      s = function s(a, b, c, d) {\n    for (var e in c.__tamee[a]) {\n      c.__tamee[a].hasOwnProperty(e) && c.__tamee[a][e].apply(d, [b]);\n    }\n  },\n      t = function t() {\n    var a = [];\n    return function (b, c, d, f) {\n      if (!b.__tamee) {\n        b.__tamee = {\n          over: !1,\n          mouseenter: [],\n          mouseexit: []\n        };\n\n        var h = function h(c) {\n          var d = g(c);\n          (null == f && d == b && !b.__tamee.over || e(d, f, b) && (null == d.__tamee || !d.__tamee.over)) && (s(\"mouseenter\", c, b, d), d.__tamee = d.__tamee || {}, d.__tamee.over = !0, a.push(d));\n        },\n            i = function i(c) {\n          for (var d = g(c), f = 0; f < a.length; f++) {\n            d != a[f] || e(c.relatedTarget || c.toElement, \"*\", d) || (d.__tamee.over = !1, a.splice(f, 1), s(\"mouseexit\", c, b, d));\n          }\n        };\n\n        G(b, \"mouseover\", m(f, b, h, \"mouseover\"), h), G(b, \"mouseout\", m(f, b, i, \"mouseout\"), i);\n      }\n\n      d.__taUnstore = function () {\n        delete b.__tamee[c][d.__tauid];\n      }, k(b, c, d), b.__tamee[c][d.__tauid] = d;\n    };\n  },\n      u = (\"ontouchstart\" in document.documentElement),\n      v = (\"onmousedown\" in document.documentElement),\n      w = {\n    mousedown: \"touchstart\",\n    mouseup: \"touchend\",\n    mousemove: \"touchmove\"\n  },\n      x = function () {\n    var a = -1;\n\n    if (\"Microsoft Internet Explorer\" == navigator.appName) {\n      var b = navigator.userAgent,\n          c = new RegExp(\"MSIE ([0-9]{1,}[.0-9]{0,})\");\n      null != c.exec(b) && (a = parseFloat(RegExp.$1));\n    }\n\n    return a;\n  }(),\n      y = x > -1 && 9 > x,\n      z = function z(a, b) {\n    if (null == a) return [0, 0];\n    var c = E(a),\n        d = D(c, 0);\n    return [d[b + \"X\"], d[b + \"Y\"]];\n  },\n      A = function A(a) {\n    return null == a ? [0, 0] : y ? [a.clientX + document.documentElement.scrollLeft, a.clientY + document.documentElement.scrollTop] : z(a, \"page\");\n  },\n      B = function B(a) {\n    return z(a, \"screen\");\n  },\n      C = function C(a) {\n    return z(a, \"client\");\n  },\n      D = function D(a, b) {\n    return a.item ? a.item(b) : a[b];\n  },\n      E = function E(a) {\n    return a.touches && a.touches.length > 0 ? a.touches : a.changedTouches && a.changedTouches.length > 0 ? a.changedTouches : a.targetTouches && a.targetTouches.length > 0 ? a.targetTouches : [a];\n  },\n      F = function F(a) {\n    return E(a).length;\n  },\n      G = function G(a, b, c, d) {\n    if (k(a, b, c), d.__tauid = c.__tauid, a.addEventListener) a.addEventListener(b, c, !1);else if (a.attachEvent) {\n      var e = b + c.__tauid;\n      a[\"e\" + e] = c, a[e] = function () {\n        a[\"e\" + e] && a[\"e\" + e](window.event);\n      }, a.attachEvent(\"on\" + b, a[e]);\n    }\n  },\n      H = function H(a, b, c) {\n    null != c && I(a, function () {\n      var d = f(this);\n      if (l(d, b, c), null != c.__tauid) if (d.removeEventListener) d.removeEventListener(b, c, !1), u && w[b] && d.removeEventListener(w[b], c, !1);else if (this.detachEvent) {\n        var e = b + c.__tauid;\n        d[e] && d.detachEvent(\"on\" + b, d[e]), d[e] = null, d[\"e\" + e] = null;\n      }\n      c.__taTouchProxy && H(a, c.__taTouchProxy[1], c.__taTouchProxy[0]);\n    });\n  },\n      I = function I(a, b) {\n    if (null != a) {\n      a = \"undefined\" != typeof Window && \"unknown\" != typeof a.top && a == a.top ? [a] : \"string\" != typeof a && null == a.tagName && null != a.length ? a : \"string\" == typeof a ? document.querySelectorAll(a) : [a];\n\n      for (var c = 0; c < a.length; c++) {\n        b.apply(a[c]);\n      }\n    }\n  },\n      J = function J() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (a) {\n      var b = 16 * Math.random() | 0,\n          c = \"x\" == a ? b : 3 & b | 8;\n      return c.toString(16);\n    });\n  };\n\n  d.Mottle = function (a) {\n    a = a || {};\n\n    var b = a.clickThreshold || 250,\n        d = a.dblClickThreshold || 450,\n        e = new t(),\n        g = new r(b, d),\n        h = a.smartClicks,\n        i = function i(a, b, c, d) {\n      null != c && I(a, function () {\n        var a = f(this);\n        h && \"click\" === b ? p(a, b, c, d) : \"tap\" === b || \"dbltap\" === b || \"contextmenu\" === b ? g(a, b, c, d) : \"mouseenter\" === b || \"mouseexit\" == b ? e(a, b, c, d) : o(a, b, c, d);\n      });\n    };\n\n    this.remove = function (a) {\n      return I(a, function () {\n        var a = f(this);\n        if (a.__ta) for (var b in a.__ta) {\n          if (a.__ta.hasOwnProperty(b)) for (var c in a.__ta[b]) {\n            a.__ta[b].hasOwnProperty(c) && H(a, b, a.__ta[b][c]);\n          }\n        }\n        a.parentNode && a.parentNode.removeChild(a);\n      }), this;\n    }, this.on = function (a, b, c, d) {\n      var e = arguments[0],\n          f = 4 == arguments.length ? arguments[2] : null,\n          g = arguments[1],\n          h = arguments[arguments.length - 1];\n      return i(e, g, h, f), this;\n    }, this.off = function (a, b, c) {\n      return H(a, b, c), this;\n    }, this.trigger = function (a, b, d, e) {\n      var g = v && (\"undefined\" == typeof MouseEvent || null == d || d.constructor === MouseEvent),\n          h = u && !v && w[b] ? w[b] : b,\n          i = !(u && !v && w[b]),\n          j = A(d),\n          k = B(d),\n          l = C(d);\n      return I(a, function () {\n        var a,\n            m = f(this);\n        d = d || {\n          screenX: k[0],\n          screenY: k[1],\n          clientX: l[0],\n          clientY: l[1]\n        };\n\n        var n = function n(a) {\n          e && (a.payload = e);\n        },\n            o = {\n          TouchEvent: function TouchEvent(a) {\n            var b = c(window, m, 0, j[0], j[1], k[0], k[1], l[0], l[1]),\n                d = a.initTouchEvent || a.initEvent;\n            d(h, !0, !0, window, null, k[0], k[1], l[0], l[1], !1, !1, !1, !1, b, b, b, 1, 0);\n          },\n          MouseEvents: function MouseEvents(a) {\n            a.initMouseEvent(h, !0, !0, window, 0, k[0], k[1], l[0], l[1], !1, !1, !1, !1, 1, m);\n          }\n        };\n\n        if (document.createEvent) {\n          var p = !i && !g && u && w[b],\n              q = p ? \"TouchEvent\" : \"MouseEvents\";\n          a = document.createEvent(q), o[q](a), n(a), m.dispatchEvent(a);\n        } else document.createEventObject && (a = document.createEventObject(), a.eventType = a.eventName = h, a.screenX = k[0], a.screenY = k[1], a.clientX = l[0], a.clientY = l[1], n(a), m.fireEvent(\"on\" + h, a));\n      }), this;\n    };\n  }, d.Mottle.consume = function (a, b) {\n    a.stopPropagation ? a.stopPropagation() : a.returnValue = !1, !b && a.preventDefault && a.preventDefault();\n  }, d.Mottle.pageLocation = A, d.Mottle.setForceTouchEvents = function (a) {\n    u = a;\n  }, d.Mottle.setForceMouseEvents = function (a) {\n    v = a;\n  }, d.Mottle.version = \"0.8.0\", \"undefined\" != typeof exports && (exports.Mottle = d.Mottle);\n}.call(\"undefined\" == typeof window ? this : window), function () {\n  \"use strict\";\n\n  var a = this,\n      b = function b(a, _b, c) {\n    return -1 === a.indexOf(_b) ? (c ? a.unshift(_b) : a.push(_b), !0) : !1;\n  },\n      c = function c(a, b) {\n    var c = a.indexOf(b);\n    -1 !== c && a.splice(c, 1);\n  },\n      d = function d(a, b) {\n    for (var c = [], d = 0; d < a.length; d++) {\n      -1 === b.indexOf(a[d]) && c.push(a[d]);\n    }\n\n    return c;\n  },\n      e = function e(a) {\n    return null == a ? !1 : \"string\" == typeof a || a.constructor === String;\n  },\n      f = function f(a) {\n    var b = a.getBoundingClientRect(),\n        c = document.body,\n        d = document.documentElement,\n        e = window.pageYOffset || d.scrollTop || c.scrollTop,\n        f = window.pageXOffset || d.scrollLeft || c.scrollLeft,\n        g = d.clientTop || c.clientTop || 0,\n        h = d.clientLeft || c.clientLeft || 0,\n        i = b.top + e - g,\n        j = b.left + f - h;\n    return {\n      top: Math.round(i),\n      left: Math.round(j)\n    };\n  },\n      g = function g(a, b, c) {\n    c = c || a.parentNode;\n\n    for (var d = c.querySelectorAll(b), e = 0; e < d.length; e++) {\n      if (d[e] === a) return !0;\n    }\n\n    return !1;\n  },\n      h = function h(a, b, c) {\n    if (g(b, c, a)) return b;\n\n    for (var d = b.parentNode; null != d && d !== a;) {\n      if (g(d, c, a)) return d;\n      d = d.parentNode;\n    }\n  },\n      i = function i(a, b, c) {\n    for (var d = null, e = b.getAttribute(\"katavorio-draggable\"), f = null != e ? \"[katavorio-draggable='\" + e + \"'] \" : \"\", i = 0; i < a.length; i++) {\n      if (d = h(b, c, f + a[i].selector), null != d) {\n        if (a[i].filter) {\n          var j = g(c, a[i].filter, d),\n              k = a[i].filterExclude === !0;\n          if (k && !j || j) return null;\n        }\n\n        return [a[i], d];\n      }\n    }\n\n    return null;\n  },\n      j = function () {\n    var a = -1;\n\n    if (\"Microsoft Internet Explorer\" === navigator.appName) {\n      var b = navigator.userAgent,\n          c = new RegExp(\"MSIE ([0-9]{1,}[.0-9]{0,})\");\n      null != c.exec(b) && (a = parseFloat(RegExp.$1));\n    }\n\n    return a;\n  }(),\n      k = 10,\n      l = 10,\n      m = j > -1 && 9 > j,\n      n = 9 === j,\n      o = function o(a) {\n    if (m) return [a.clientX + document.documentElement.scrollLeft, a.clientY + document.documentElement.scrollTop];\n    var b = q(a),\n        c = p(b, 0);\n    return n ? [c.pageX || c.clientX, c.pageY || c.clientY] : [c.pageX, c.pageY];\n  },\n      p = function p(a, b) {\n    return a.item ? a.item(b) : a[b];\n  },\n      q = function q(a) {\n    return a.touches && a.touches.length > 0 ? a.touches : a.changedTouches && a.changedTouches.length > 0 ? a.changedTouches : a.targetTouches && a.targetTouches.length > 0 ? a.targetTouches : [a];\n  },\n      r = {\n    delegatedDraggable: \"katavorio-delegated-draggable\",\n    draggable: \"katavorio-draggable\",\n    droppable: \"katavorio-droppable\",\n    drag: \"katavorio-drag\",\n    selected: \"katavorio-drag-selected\",\n    active: \"katavorio-drag-active\",\n    hover: \"katavorio-drag-hover\",\n    noSelect: \"katavorio-drag-no-select\",\n    ghostProxy: \"katavorio-ghost-proxy\",\n    clonedDrag: \"katavorio-clone-drag\"\n  },\n      s = \"katavorio-drag-scope\",\n      t = [\"stop\", \"start\", \"drag\", \"drop\", \"over\", \"out\", \"beforeStart\"],\n      u = function u() {},\n      v = function v() {\n    return !0;\n  },\n      w = function w(a, b, c) {\n    for (var d = 0; d < a.length; d++) {\n      a[d] != c && b(a[d]);\n    }\n  },\n      x = function x(a, b, c, d) {\n    w(a, function (a) {\n      a.setActive(b), b && a.updatePosition(), c && a.setHover(d, b);\n    });\n  },\n      y = function y(a, b) {\n    if (null != a) {\n      a = e(a) || null != a.tagName || null == a.length ? [a] : a;\n\n      for (var c = 0; c < a.length; c++) {\n        b.apply(a[c], [a[c]]);\n      }\n    }\n  },\n      z = function z(a) {\n    a.stopPropagation ? (a.stopPropagation(), a.preventDefault()) : a.returnValue = !1;\n  },\n      A = \"input,textarea,select,button,option\",\n      B = function B(a, b, c) {\n    var d = a.srcElement || a.target;\n    return !g(d, c.getInputFilterSelector(), b);\n  },\n      C = function C(a, b, c, d) {\n    this.params = b || {}, this.el = a, this.params.addClass(this.el, this._class), this.uuid = H();\n    var e = !0;\n    return this.setEnabled = function (a) {\n      e = a;\n    }, this.isEnabled = function () {\n      return e;\n    }, this.toggleEnabled = function () {\n      e = !e;\n    }, this.setScope = function (a) {\n      this.scopes = a ? a.split(/\\s+/) : [d];\n    }, this.addScope = function (a) {\n      var b = {};\n      y(this.scopes, function (a) {\n        b[a] = !0;\n      }), y(a ? a.split(/\\s+/) : [], function (a) {\n        b[a] = !0;\n      }), this.scopes = [];\n\n      for (var c in b) {\n        this.scopes.push(c);\n      }\n    }, this.removeScope = function (a) {\n      var b = {};\n      y(this.scopes, function (a) {\n        b[a] = !0;\n      }), y(a ? a.split(/\\s+/) : [], function (a) {\n        delete b[a];\n      }), this.scopes = [];\n\n      for (var c in b) {\n        this.scopes.push(c);\n      }\n    }, this.toggleScope = function (a) {\n      var b = {};\n      y(this.scopes, function (a) {\n        b[a] = !0;\n      }), y(a ? a.split(/\\s+/) : [], function (a) {\n        b[a] ? delete b[a] : b[a] = !0;\n      }), this.scopes = [];\n\n      for (var c in b) {\n        this.scopes.push(c);\n      }\n    }, this.setScope(b.scope), this.k = b.katavorio, b.katavorio;\n  },\n      D = function D() {\n    return !0;\n  },\n      E = function E() {\n    return !1;\n  },\n      F = function F(a, b, c, d) {\n    this._class = c.draggable;\n    var h = C.apply(this, arguments);\n    this.rightButtonCanDrag = this.params.rightButtonCanDrag;\n\n    var j,\n        m,\n        n,\n        p,\n        q = [0, 0],\n        s = null,\n        t = null,\n        u = [0, 0],\n        w = !1,\n        y = [0, 0],\n        A = this.params.consumeStartEvent !== !1,\n        F = this.el,\n        G = this.params.clone,\n        J = (this.params.scroll, b.multipleDrop !== !1),\n        K = !1,\n        L = b.ghostProxy === !0 ? D : b.ghostProxy && \"function\" == typeof b.ghostProxy ? b.ghostProxy : E,\n        M = function M(a) {\n      return a.cloneNode(!0);\n    },\n        N = null,\n        O = [],\n        P = null,\n        Q = b.ghostProxyParent;\n\n    if (b.selector) {\n      var R = a.getAttribute(\"katavorio-draggable\");\n      null == R && (R = \"\" + new Date().getTime(), a.setAttribute(\"katavorio-draggable\", R)), O.push(b);\n    }\n\n    var S = b.snapThreshold,\n        T = function T(a, b, c, d, e) {\n      var f = Math.floor(a[0] / b),\n          g = b * f,\n          h = g + b,\n          i = Math.abs(a[0] - g) <= d ? g : Math.abs(h - a[0]) <= d ? h : a[0],\n          j = Math.floor(a[1] / c),\n          k = c * j,\n          l = k + c,\n          m = Math.abs(a[1] - k) <= e ? k : Math.abs(l - a[1]) <= e ? l : a[1];\n      return [i, m];\n    };\n\n    this.posses = [], this.posseRoles = {}, this.toGrid = function (a) {\n      if (null == this.params.grid) return a;\n      var b = this.params.grid ? this.params.grid[0] / 2 : S ? S : k / 2,\n          c = this.params.grid ? this.params.grid[1] / 2 : S ? S : l / 2;\n      return T(a, this.params.grid[0], this.params.grid[1], b, c);\n    }, this.snap = function (a, b) {\n      if (null != F) {\n        a = a || (this.params.grid ? this.params.grid[0] : k), b = b || (this.params.grid ? this.params.grid[1] : l);\n        var c = this.params.getPosition(F),\n            d = this.params.grid ? this.params.grid[0] / 2 : S,\n            e = this.params.grid ? this.params.grid[1] / 2 : S,\n            f = T(c, a, b, d, e);\n        return this.params.setPosition(F, f), f;\n      }\n    }, this.setUseGhostProxy = function (a) {\n      L = a ? D : E;\n    };\n\n    var U,\n        V = function V(a) {\n      return b.allowNegative === !1 ? [Math.max(0, a[0]), Math.max(0, a[1])] : a;\n    },\n        W = function (a) {\n      U = \"function\" == typeof a ? a : a ? function (a, b, c, d) {\n        return V([Math.max(0, Math.min(c.w - d[0], a[0])), Math.max(0, Math.min(c.h - d[1], a[1]))]);\n      }.bind(this) : function (a) {\n        return V(a);\n      };\n    }.bind(this);\n\n    W(\"function\" == typeof this.params.constrain ? this.params.constrain : this.params.constrain || this.params.containment), this.setConstrain = function (a) {\n      W(a);\n    };\n    var X;\n    this.setRevert = function (a) {\n      X = a;\n    }, this.params.revert && (X = this.params.revert);\n\n    var Y = function Y(a) {\n      return \"function\" == typeof a ? (a._katavorioId = H(), a._katavorioId) : a;\n    },\n        Z = {},\n        $ = function $(a) {\n      for (var b in Z) {\n        var c = Z[b],\n            d = c[0](a);\n        if (c[1] && (d = !d), !d) return !1;\n      }\n\n      return !0;\n    },\n        _ = this.setFilter = function (b, c) {\n      if (b) {\n        var d = Y(b);\n        Z[d] = [function (c) {\n          var d,\n              f = c.srcElement || c.target;\n          return e(b) ? d = g(f, b, a) : \"function\" == typeof b && (d = b(c, a)), d;\n        }, c !== !1];\n      }\n    };\n\n    this.addFilter = _, this.removeFilter = function (a) {\n      var b = \"function\" == typeof a ? a._katavorioId : a;\n      delete Z[b];\n    };\n    this.clearAllFilters = function () {\n      Z = {};\n    }, this.canDrag = this.params.canDrag || v;\n    var aa,\n        ba = [],\n        ca = [];\n    this.addSelector = function (a) {\n      a.selector && O.push(a);\n    }, this.downListener = function (a) {\n      if (!a.defaultPrevented) {\n        var b = this.rightButtonCanDrag || 3 !== a.which && 2 !== a.button;\n\n        if (b && this.isEnabled() && this.canDrag()) {\n          var d = $(a) && B(a, this.el, this.k);\n\n          if (d) {\n            if (P = null, N = null, O.length > 0) {\n              var e = i(O, this.el, a.target || a.srcElement);\n              if (null != e && (P = e[0], N = e[1]), null == N) return;\n            } else N = this.el;\n\n            if (G) {\n              if (F = N.cloneNode(!0), this.params.addClass(F, r.clonedDrag), F.setAttribute(\"id\", null), F.style.position = \"absolute\", null != this.params.parent) {\n                var g = this.params.getPosition(this.el);\n                F.style.left = g[0] + \"px\", F.style.top = g[1] + \"px\", this.params.parent.appendChild(F);\n              } else {\n                var j = f(N);\n                F.style.left = j.left + \"px\", F.style.top = j.top + \"px\", document.body.appendChild(F);\n              }\n            } else F = N;\n            A && z(a), q = o(a), F && F.parentNode && (y = [F.parentNode.scrollLeft, F.parentNode.scrollTop]), this.params.bind(document, \"mousemove\", this.moveListener), this.params.bind(document, \"mouseup\", this.upListener), h.markSelection(this), h.markPosses(this), this.params.addClass(document.body, c.noSelect), ea(\"beforeStart\", {\n              el: this.el,\n              pos: s,\n              e: a,\n              drag: this\n            });\n          } else this.params.consumeFilteredEvents && z(a);\n        }\n      }\n    }.bind(this), this.moveListener = function (a) {\n      if (q) {\n        if (!w) {\n          var b = ea(\"start\", {\n            el: this.el,\n            pos: s,\n            e: a,\n            drag: this\n          });\n\n          if (b !== !1) {\n            if (!q) return;\n            this.mark(!0), w = !0;\n          } else this.abort();\n        }\n\n        if (q) {\n          ca.length = 0;\n          var c = o(a),\n              d = c[0] - q[0],\n              e = c[1] - q[1],\n              f = this.params.ignoreZoom ? 1 : h.getZoom();\n          F && F.parentNode && (d += F.parentNode.scrollLeft - y[0], e += F.parentNode.scrollTop - y[1]), d /= f, e /= f, this.moveBy(d, e, a), h.updateSelection(d, e, this), h.updatePosses(d, e, this);\n        }\n      }\n    }.bind(this), this.upListener = function (a) {\n      q && (q = null, this.params.unbind(document, \"mousemove\", this.moveListener), this.params.unbind(document, \"mouseup\", this.upListener), this.params.removeClass(document.body, c.noSelect), this.unmark(a), h.unmarkSelection(this, a), h.unmarkPosses(this, a), this.stop(a), h.notifyPosseDragStop(this, a), w = !1, ca.length = 0, G ? (F && F.parentNode && F.parentNode.removeChild(F), F = null) : X && X(F, this.params.getPosition(F)) === !0 && (this.params.setPosition(F, s), ea(\"revert\", F)));\n    }.bind(this), this.getFilters = function () {\n      return Z;\n    }, this.abort = function () {\n      null != q && this.upListener();\n    }, this.getDragElement = function (a) {\n      return a ? N || this.el : F || this.el;\n    };\n    var da = {\n      start: [],\n      drag: [],\n      stop: [],\n      over: [],\n      out: [],\n      beforeStart: [],\n      revert: []\n    };\n    b.events.start && da.start.push(b.events.start), b.events.beforeStart && da.beforeStart.push(b.events.beforeStart), b.events.stop && da.stop.push(b.events.stop), b.events.drag && da.drag.push(b.events.drag), b.events.revert && da.revert.push(b.events.revert), this.on = function (a, b) {\n      da[a] && da[a].push(b);\n    }, this.off = function (a, b) {\n      if (da[a]) {\n        for (var c = [], d = 0; d < da[a].length; d++) {\n          da[a][d] !== b && c.push(da[a][d]);\n        }\n\n        da[a] = c;\n      }\n    };\n\n    var ea = function ea(a, b) {\n      var c = null;\n      if (P && P[a]) c = P[a](b);else if (da[a]) for (var d = 0; d < da[a].length; d++) {\n        try {\n          var e = da[a][d](b);\n          null != e && (c = e);\n        } catch (f) {}\n      }\n      return c;\n    };\n\n    this.notifyStart = function (a) {\n      ea(\"start\", {\n        el: this.el,\n        pos: this.params.getPosition(F),\n        e: a,\n        drag: this\n      });\n    }, this.stop = function (a, b) {\n      if (b || w) {\n        var c = [],\n            d = h.getSelection(),\n            e = this.params.getPosition(F);\n        if (d.length > 0) for (var f = 0; f < d.length; f++) {\n          var g = this.params.getPosition(d[f].el);\n          c.push([d[f].el, {\n            left: g[0],\n            top: g[1]\n          }, d[f]]);\n        } else c.push([F, {\n          left: e[0],\n          top: e[1]\n        }, this]);\n        ea(\"stop\", {\n          el: F,\n          pos: fa || e,\n          finalPos: e,\n          e: a,\n          drag: this,\n          selection: c\n        });\n      }\n    }, this.mark = function (a) {\n      s = this.params.getPosition(F), t = this.params.getPosition(F, !0), u = [t[0] - s[0], t[1] - s[1]], this.size = this.params.getSize(F), ba = h.getMatchingDroppables(this), x(ba, !0, !1, this), this.params.addClass(F, this.params.dragClass || c.drag);\n      var b;\n      b = this.params.getConstrainingRectangle ? this.params.getConstrainingRectangle(F) : this.params.getSize(F.parentNode), aa = {\n        w: b[0],\n        h: b[1]\n      }, n = 0, p = 0, a && h.notifySelectionDragStart(this);\n    };\n    var fa;\n    this.unmark = function (a, d) {\n      if (x(ba, !1, !0, this), K && L(N, F) ? (fa = [F.offsetLeft - n, F.offsetTop - p], F.parentNode.removeChild(F), F = N) : fa = null, this.params.removeClass(F, this.params.dragClass || c.drag), ba.length = 0, K = !1, !d) {\n        ca.length > 0 && fa && b.setPosition(N, fa), ca.sort(I);\n\n        for (var e = 0; e < ca.length; e++) {\n          var f = ca[e].drop(this, a);\n          if (f === !0) break;\n        }\n      }\n    }, this.moveBy = function (a, c, d) {\n      ca.length = 0;\n      var e = this.toGrid([s[0] + a, s[1] + c]),\n          f = U(e, F, aa, this.size);\n      if (L(this.el, F)) if (e[0] !== f[0] || e[1] !== f[1]) {\n        if (!K) {\n          var g = M(N);\n          b.addClass(g, r.ghostProxy), Q ? (Q.appendChild(g), j = b.getPosition(N.parentNode, !0), m = b.getPosition(b.ghostProxyParent, !0), n = j[0] - m[0], p = j[1] - m[1]) : N.parentNode.appendChild(g), F = g, K = !0;\n        }\n\n        f = e;\n      } else K && (F.parentNode.removeChild(F), F = N, K = !1, j = null, m = null, n = 0, p = 0);\n      var h = {\n        x: f[0],\n        y: f[1],\n        w: this.size[0],\n        h: this.size[1]\n      },\n          i = {\n        x: h.x + u[0],\n        y: h.y + u[1],\n        w: h.w,\n        h: h.h\n      },\n          k = null;\n      this.params.setPosition(F, [f[0] + n, f[1] + p]);\n\n      for (var l = 0; l < ba.length; l++) {\n        var o = {\n          x: ba[l].pagePosition[0],\n          y: ba[l].pagePosition[1],\n          w: ba[l].size[0],\n          h: ba[l].size[1]\n        };\n        this.params.intersects(i, o) && (J || null == k || k === ba[l].el) && ba[l].canDrop(this) ? (k || (k = ba[l].el), ca.push(ba[l]), ba[l].setHover(this, !0, d)) : ba[l].isHover() && ba[l].setHover(this, !1, d);\n      }\n\n      ea(\"drag\", {\n        el: this.el,\n        pos: f,\n        e: d,\n        drag: this\n      });\n    }, this.destroy = function () {\n      this.params.unbind(this.el, \"mousedown\", this.downListener), this.params.unbind(document, \"mousemove\", this.moveListener), this.params.unbind(document, \"mouseup\", this.upListener), this.downListener = null, this.upListener = null, this.moveListener = null;\n    }, this.params.bind(this.el, \"mousedown\", this.downListener), this.params.handle ? _(this.params.handle, !1) : _(this.params.filter, this.params.filterExclude);\n  },\n      G = function G(a, b, c, d) {\n    this._class = c.droppable, this.params = b || {}, this.rank = b.rank || 0, this._activeClass = this.params.activeClass || c.active, this._hoverClass = this.params.hoverClass || c.hover, C.apply(this, arguments);\n    var e = !1;\n    this.allowLoopback = this.params.allowLoopback !== !1, this.setActive = function (a) {\n      this.params[a ? \"addClass\" : \"removeClass\"](this.el, this._activeClass);\n    }, this.updatePosition = function () {\n      this.position = this.params.getPosition(this.el), this.pagePosition = this.params.getPosition(this.el, !0), this.size = this.params.getSize(this.el);\n    }, this.canDrop = this.params.canDrop || function (a) {\n      return !0;\n    }, this.isHover = function () {\n      return e;\n    }, this.setHover = function (a, b, c) {\n      (b || null == this.el._katavorioDragHover || this.el._katavorioDragHover === a.el._katavorio) && (this.params[b ? \"addClass\" : \"removeClass\"](this.el, this._hoverClass), this.el._katavorioDragHover = b ? a.el._katavorio : null, e !== b && this.params.events[b ? \"over\" : \"out\"]({\n        el: this.el,\n        e: c,\n        drag: a,\n        drop: this\n      }), e = b);\n    }, this.drop = function (a, b) {\n      return this.params.events.drop({\n        drag: a,\n        e: b,\n        drop: this\n      });\n    }, this.destroy = function () {\n      this._class = null, this._activeClass = null, this._hoverClass = null, e = null;\n    };\n  },\n      H = function H() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (a) {\n      var b = 16 * Math.random() | 0,\n          c = \"x\" === a ? b : 3 & b | 8;\n      return c.toString(16);\n    });\n  },\n      I = function I(a, b) {\n    return a.rank < b.rank ? 1 : a.rank > b.rank ? -1 : 0;\n  },\n      J = function J(a) {\n    return null == a ? null : (a = \"string\" == typeof a || a.constructor === String ? document.getElementById(a) : a, null == a ? null : (a._katavorio = a._katavorio || H(), a));\n  };\n\n  a.Katavorio = function (a) {\n    var f = [],\n        g = {};\n    this._dragsByScope = {}, this._dropsByScope = {};\n\n    var h = 1,\n        i = function i(a, b) {\n      y(a, function (a) {\n        for (var c = 0; c < a.scopes.length; c++) {\n          b[a.scopes[c]] = b[a.scopes[c]] || [], b[a.scopes[c]].push(a);\n        }\n      });\n    },\n        j = function j(b, c) {\n      var d = 0;\n      return y(b, function (b) {\n        for (var e = 0; e < b.scopes.length; e++) {\n          if (c[b.scopes[e]]) {\n            var f = a.indexOf(c[b.scopes[e]], b);\n            -1 !== f && (c[b.scopes[e]].splice(f, 1), d++);\n          }\n        }\n      }), d > 0;\n    },\n        k = (this.getMatchingDroppables = function (a) {\n      for (var b = [], c = {}, d = 0; d < a.scopes.length; d++) {\n        var e = this._dropsByScope[a.scopes[d]];\n        if (e) for (var f = 0; f < e.length; f++) {\n          !e[f].canDrop(a) || c[e[f].uuid] || !e[f].allowLoopback && e[f].el === a.el || (c[e[f].uuid] = !0, b.push(e[f]));\n        }\n      }\n\n      return b.sort(I), b;\n    }, function (b) {\n      b = b || {};\n      var c,\n          d = {\n        events: {}\n      };\n\n      for (c in a) {\n        d[c] = a[c];\n      }\n\n      for (c in b) {\n        d[c] = b[c];\n      }\n\n      for (c = 0; c < t.length; c++) {\n        d.events[t[c]] = b[t[c]] || u;\n      }\n\n      return d.katavorio = this, d;\n    }.bind(this)),\n        l = function (a, b) {\n      for (var c = 0; c < t.length; c++) {\n        b[t[c]] && a.on(t[c], b[t[c]]);\n      }\n    }.bind(this),\n        m = {},\n        n = a.css || {},\n        o = a.scope || s;\n\n    for (var p in r) {\n      m[p] = r[p];\n    }\n\n    for (var p in n) {\n      m[p] = n[p];\n    }\n\n    var q = a.inputFilterSelector || A;\n    this.getInputFilterSelector = function () {\n      return q;\n    }, this.setInputFilterSelector = function (a) {\n      return q = a, this;\n    }, this.draggable = function (b, c) {\n      var d = [];\n      return y(b, function (b) {\n        if (b = J(b), null != b) if (null == b._katavorioDrag) {\n          var e = k(c);\n          b._katavorioDrag = new F(b, e, m, o), i(b._katavorioDrag, this._dragsByScope), d.push(b._katavorioDrag), a.addClass(b, e.selector ? m.delegatedDraggable : m.draggable);\n        } else l(b._katavorioDrag, c);\n      }.bind(this)), d;\n    }, this.droppable = function (b, c) {\n      var d = [];\n      return y(b, function (b) {\n        if (b = J(b), null != b) {\n          var e = new G(b, k(c), m, o);\n          b._katavorioDrop = b._katavorioDrop || [], b._katavorioDrop.push(e), i(e, this._dropsByScope), d.push(e), a.addClass(b, m.droppable);\n        }\n      }.bind(this)), d;\n    }, this.select = function (b) {\n      return y(b, function () {\n        var b = J(this);\n        b && b._katavorioDrag && (g[b._katavorio] || (f.push(b._katavorioDrag), g[b._katavorio] = [b, f.length - 1], a.addClass(b, m.selected)));\n      }), this;\n    }, this.deselect = function (b) {\n      return y(b, function () {\n        var b = J(this);\n\n        if (b && b._katavorio) {\n          var c = g[b._katavorio];\n\n          if (c) {\n            for (var d = [], e = 0; e < f.length; e++) {\n              f[e].el !== b && d.push(f[e]);\n            }\n\n            f = d, delete g[b._katavorio], a.removeClass(b, m.selected);\n          }\n        }\n      }), this;\n    }, this.deselectAll = function () {\n      for (var b in g) {\n        var c = g[b];\n        a.removeClass(c[0], m.selected);\n      }\n\n      f.length = 0, g = {};\n    }, this.markSelection = function (a) {\n      w(f, function (a) {\n        a.mark();\n      }, a);\n    }, this.markPosses = function (a) {\n      a.posses && y(a.posses, function (b) {\n        a.posseRoles[b] && C[b] && w(C[b].members, function (a) {\n          a.mark();\n        }, a);\n      });\n    }, this.unmarkSelection = function (a, b) {\n      w(f, function (a) {\n        a.unmark(b);\n      }, a);\n    }, this.unmarkPosses = function (a, b) {\n      a.posses && y(a.posses, function (c) {\n        a.posseRoles[c] && C[c] && w(C[c].members, function (a) {\n          a.unmark(b, !0);\n        }, a);\n      });\n    }, this.getSelection = function () {\n      return f.slice(0);\n    }, this.updateSelection = function (a, b, c) {\n      w(f, function (c) {\n        c.moveBy(a, b);\n      }, c);\n    };\n\n    var v = function v(a, b) {\n      b.posses && y(b.posses, function (c) {\n        b.posseRoles[c] && C[c] && w(C[c].members, function (b) {\n          a(b);\n        }, b);\n      });\n    };\n\n    this.updatePosses = function (a, b, c) {\n      v(function (c) {\n        c.moveBy(a, b);\n      }, c);\n    }, this.notifyPosseDragStop = function (a, b) {\n      v(function (a) {\n        a.stop(b, !0);\n      }, a);\n    }, this.notifySelectionDragStop = function (a, b) {\n      w(f, function (a) {\n        a.stop(b, !0);\n      }, a);\n    }, this.notifySelectionDragStart = function (a, b) {\n      w(f, function (a) {\n        a.notifyStart(b);\n      }, a);\n    }, this.setZoom = function (a) {\n      h = a;\n    }, this.getZoom = function () {\n      return h;\n    };\n\n    var x = function x(a, b, c, d) {\n      y(a, function (a) {\n        j(a, c), a[d](b), i(a, c);\n      });\n    };\n\n    y([\"set\", \"add\", \"remove\", \"toggle\"], function (a) {\n      this[a + \"Scope\"] = function (b, c) {\n        x(b._katavorioDrag, c, this._dragsByScope, a + \"Scope\"), x(b._katavorioDrop, c, this._dropsByScope, a + \"Scope\");\n      }.bind(this), this[a + \"DragScope\"] = function (b, c) {\n        x(b.constructor === F ? b : b._katavorioDrag, c, this._dragsByScope, a + \"Scope\");\n      }.bind(this), this[a + \"DropScope\"] = function (b, c) {\n        x(b.constructor === G ? b : b._katavorioDrop, c, this._dropsByScope, a + \"Scope\");\n      }.bind(this);\n    }.bind(this)), this.snapToGrid = function (a, b) {\n      for (var c in this._dragsByScope) {\n        w(this._dragsByScope[c], function (c) {\n          c.snap(a, b);\n        });\n      }\n    }, this.getDragsForScope = function (a) {\n      return this._dragsByScope[a];\n    }, this.getDropsForScope = function (a) {\n      return this._dropsByScope[a];\n    };\n\n    var z = function z(a, b, c) {\n      if (a = J(a), a[b]) {\n        var d = f.indexOf(a[b]);\n        d >= 0 && f.splice(d, 1), j(a[b], c) && y(a[b], function (a) {\n          a.destroy();\n        }), delete a[b];\n      }\n    },\n        B = function B(a, b, c, d) {\n      a = J(a), a[b] && a[b].off(c, d);\n    };\n\n    this.elementRemoved = function (a) {\n      this.destroyDraggable(a), this.destroyDroppable(a);\n    }, this.destroyDraggable = function (a, b, c) {\n      1 === arguments.length ? z(a, \"_katavorioDrag\", this._dragsByScope) : B(a, \"_katavorioDrag\", b, c);\n    }, this.destroyDroppable = function (a, b, c) {\n      1 === arguments.length ? z(a, \"_katavorioDrop\", this._dropsByScope) : B(a, \"_katavorioDrop\", b, c);\n    }, this.reset = function () {\n      this._dragsByScope = {}, this._dropsByScope = {}, f = [], g = {}, C = {};\n    };\n\n    var C = {},\n        D = function D(a, c, d) {\n      var f = e(c) ? c : c.id,\n          g = e(c) ? !0 : c.active !== !1,\n          h = C[f] || function () {\n        var a = {\n          name: f,\n          members: []\n        };\n        return C[f] = a, a;\n      }();\n\n      return y(a, function (a) {\n        if (a._katavorioDrag) {\n          if (d && null != a._katavorioDrag.posseRoles[h.name]) return;\n          b(h.members, a._katavorioDrag), b(a._katavorioDrag.posses, h.name), a._katavorioDrag.posseRoles[h.name] = g;\n        }\n      }), h;\n    };\n\n    this.addToPosse = function (a, b) {\n      for (var c = [], d = 1; d < arguments.length; d++) {\n        c.push(D(a, arguments[d]));\n      }\n\n      return 1 === c.length ? c[0] : c;\n    }, this.setPosse = function (a, b) {\n      for (var c = [], e = 1; e < arguments.length; e++) {\n        c.push(D(a, arguments[e], !0).name);\n      }\n\n      return y(a, function (a) {\n        if (a._katavorioDrag) {\n          var b = d(a._katavorioDrag.posses, c),\n              e = [];\n          Array.prototype.push.apply(e, a._katavorioDrag.posses);\n\n          for (var f = 0; f < b.length; f++) {\n            this.removeFromPosse(a, b[f]);\n          }\n        }\n      }.bind(this)), 1 === c.length ? c[0] : c;\n    }, this.removeFromPosse = function (a, b) {\n      if (arguments.length < 2) throw new TypeError(\"No posse id provided for remove operation\");\n\n      for (var d = 1; d < arguments.length; d++) {\n        b = arguments[d], y(a, function (a) {\n          if (a._katavorioDrag && a._katavorioDrag.posses) {\n            var d = a._katavorioDrag;\n            y(b, function (a) {\n              c(C[a].members, d), c(d.posses, a), delete d.posseRoles[a];\n            });\n          }\n        });\n      }\n    }, this.removeFromAllPosses = function (a) {\n      y(a, function (a) {\n        if (a._katavorioDrag && a._katavorioDrag.posses) {\n          var b = a._katavorioDrag;\n          y(b.posses, function (a) {\n            c(C[a].members, b);\n          }), b.posses.length = 0, b.posseRoles = {};\n        }\n      });\n    }, this.setPosseState = function (a, b, c) {\n      var d = C[b];\n      d && y(a, function (a) {\n        a._katavorioDrag && a._katavorioDrag.posses && (a._katavorioDrag.posseRoles[d.name] = c);\n      });\n    };\n  }, a.Katavorio.version = \"1.0.0\", \"undefined\" != typeof exports && (exports.Katavorio = a.Katavorio);\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  function a(a) {\n    return \"[object Array]\" === Object.prototype.toString.call(a);\n  }\n\n  function b(a) {\n    return \"[object Number]\" === Object.prototype.toString.call(a);\n  }\n\n  function c(a) {\n    return \"string\" == typeof a;\n  }\n\n  function d(a) {\n    return \"boolean\" == typeof a;\n  }\n\n  function e(a) {\n    return null == a;\n  }\n\n  function f(a) {\n    return null == a ? !1 : \"[object Object]\" === Object.prototype.toString.call(a);\n  }\n\n  function g(a) {\n    return \"[object Date]\" === Object.prototype.toString.call(a);\n  }\n\n  function h(a) {\n    return \"[object Function]\" === Object.prototype.toString.call(a);\n  }\n\n  function i(a) {\n    return h(a) && null != a.name && a.name.length > 0;\n  }\n\n  function j(a) {\n    for (var b in a) {\n      if (a.hasOwnProperty(b)) return !1;\n    }\n\n    return !0;\n  }\n\n  function k(b) {\n    if (c(b)) return \"\" + b;\n    if (d(b)) return !!b;\n    if (g(b)) return new Date(b.getTime());\n    if (h(b)) return b;\n\n    if (a(b)) {\n      for (var e = [], i = 0; i < b.length; i++) {\n        e.push(k(b[i]));\n      }\n\n      return e;\n    }\n\n    if (f(b)) {\n      var j = {};\n\n      for (var l in b) {\n        j[l] = k(b[l]);\n      }\n\n      return j;\n    }\n\n    return b;\n  }\n\n  function l(b, e, g, h) {\n    var i,\n        j,\n        l = {},\n        m = {};\n\n    for (g = g || [], h = h || [], j = 0; j < g.length; j++) {\n      l[g[j]] = !0;\n    }\n\n    for (j = 0; j < h.length; j++) {\n      m[h[j]] = !0;\n    }\n\n    var n = k(b);\n\n    for (j in e) {\n      if (null == n[j] || m[j]) n[j] = e[j];else if (c(e[j]) || d(e[j])) l[j] ? (i = [], i.push.apply(i, a(n[j]) ? n[j] : [n[j]]), i.push.apply(i, d(e[j]) ? e[j] : [e[j]]), n[j] = i) : n[j] = e[j];else if (a(e[j])) i = [], a(n[j]) && i.push.apply(i, n[j]), i.push.apply(i, e[j]), n[j] = i;else if (f(e[j])) {\n        f(n[j]) || (n[j] = {});\n\n        for (var o in e[j]) {\n          n[j][o] = e[j][o];\n        }\n      }\n    }\n\n    return n;\n  }\n\n  function m(a, b, c) {\n    if (null != a) {\n      var d = a,\n          e = d;\n      return b.replace(/([^\\.])+/g, function (a, b, d, f) {\n        var g = a.match(/([^\\[0-9]+){1}(\\[)([0-9+])/),\n            h = d + a.length >= f.length,\n            i = function i() {\n          return e[g[1]] || function () {\n            return e[g[1]] = [], e[g[1]];\n          }();\n        };\n\n        if (h) g ? i()[g[3]] = c : e[a] = c;else if (g) {\n          var j = i();\n\n          e = j[g[3]] || function () {\n            return j[g[3]] = {}, j[g[3]];\n          }();\n        } else e = e[a] || function () {\n          return e[a] = {}, e[a];\n        }();\n        return \"\";\n      }), a;\n    }\n  }\n\n  function n(a, b, c) {\n    for (var d = 0; d < c.length; d++) {\n      var e = c[d][0][c[d][1]].apply(c[d][0], c[d][2]);\n      if (e === b) return e;\n    }\n\n    return a;\n  }\n\n  function o(b, d, e, g) {\n    var i = function i(a) {\n      var b = a.match(/(\\${.*?})/g);\n      if (null != b) for (var c = 0; c < b.length; c++) {\n        var e = d[b[c].substring(2, b[c].length - 1)] || \"\";\n        null != e && (a = a.replace(b[c], e));\n      }\n      return a;\n    },\n        j = function j(b) {\n      if (null != b) {\n        if (c(b)) return i(b);\n\n        if (!h(b) || g || null != e && 0 !== (b.name || \"\").indexOf(e)) {\n          if (a(b)) {\n            for (var k = [], l = 0; l < b.length; l++) {\n              k.push(j(b[l]));\n            }\n\n            return k;\n          }\n\n          if (f(b)) {\n            var m = {};\n\n            for (var n in b) {\n              m[n] = j(b[n]);\n            }\n\n            return m;\n          }\n\n          return b;\n        }\n\n        return b(d);\n      }\n    };\n\n    return j(b);\n  }\n\n  function p(a, b) {\n    if (a) for (var c = 0; c < a.length; c++) {\n      if (b(a[c])) return c;\n    }\n    return -1;\n  }\n\n  function q(a, b) {\n    var c = p(a, b);\n    return c > -1 && a.splice(c, 1), -1 !== c;\n  }\n\n  function r(a, b) {\n    var c = a.indexOf(b);\n    return c > -1 && a.splice(c, 1), -1 !== c;\n  }\n\n  function s(a, b, c) {\n    -1 === p(a, c) && a.push(b);\n  }\n\n  function t(a, b, c, d) {\n    var e = a[b];\n    return null == e && (e = [], a[b] = e), e[d ? \"unshift\" : \"push\"](c), e;\n  }\n\n  function u(a, b, c) {\n    return -1 === a.indexOf(b) ? (c ? a.unshift(b) : a.push(b), !0) : !1;\n  }\n\n  function v(b, c, d) {\n    var e;\n    c = a(c) ? c : [c];\n\n    var f = function f(a) {\n      for (var c = a.__proto__; null != c;) {\n        if (null != c.prototype) {\n          for (var d in c.prototype) {\n            c.prototype.hasOwnProperty(d) && !b.prototype.hasOwnProperty(d) && (b.prototype[d] = c.prototype[d]);\n          }\n\n          c = c.prototype.__proto__;\n        } else c = null;\n      }\n    };\n\n    for (e = 0; e < c.length; e++) {\n      for (var g in c[e].prototype) {\n        c[e].prototype.hasOwnProperty(g) && !b.prototype.hasOwnProperty(g) && (b.prototype[g] = c[e].prototype[g]);\n      }\n\n      f(c[e]);\n    }\n\n    var h = function h(a, b) {\n      return function () {\n        for (e = 0; e < c.length; e++) {\n          c[e].prototype[a] && c[e].prototype[a].apply(this, arguments);\n        }\n\n        return b.apply(this, arguments);\n      };\n    },\n        i = function i(a) {\n      for (var c in a) {\n        b.prototype[c] = h(c, a[c]);\n      }\n    };\n\n    if (arguments.length > 2) for (e = 2; e < arguments.length; e++) {\n      i(arguments[e]);\n    }\n    return b;\n  }\n\n  function w() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (a) {\n      var b = 16 * Math.random() | 0,\n          c = \"x\" === a ? b : 3 & b | 8;\n      return c.toString(16);\n    });\n  }\n\n  function x(a) {\n    if (null == a) return null;\n\n    for (var b = a.replace(/^\\s\\s*/, \"\"), c = /\\s/, d = b.length; c.test(b.charAt(--d));) {\n      ;\n    }\n\n    return b.slice(0, d + 1);\n  }\n\n  function y(a, b) {\n    a = null == a.length || \"string\" == typeof a ? [a] : a;\n\n    for (var c = 0; c < a.length; c++) {\n      b(a[c]);\n    }\n  }\n\n  function z(a, b) {\n    for (var c = [], d = 0; d < a.length; d++) {\n      c.push(b(a[d]));\n    }\n\n    return c;\n  }\n\n  function A(a, b, c) {\n    c = c || \"parent\";\n\n    var d = function d(a) {\n      return a ? b[a] : null;\n    },\n        e = function e(a) {\n      return a ? d(a[c]) : null;\n    },\n        f = function f(a, b) {\n      if (null == a) return b;\n      var c = [\"anchor\", \"anchors\", \"cssClass\", \"connector\", \"paintStyle\", \"hoverPaintStyle\", \"endpoint\", \"endpoints\"];\n      \"override\" === b.mergeStrategy && Array.prototype.push.apply(c, [\"events\", \"overlays\"]);\n      var d = l(a, b, [], c);\n      return f(e(a), d);\n    },\n        g = function g(a) {\n      if (null == a) return {};\n      if (\"string\" == typeof a) return d(a);\n\n      if (a.length) {\n        for (var b = !1, c = 0, e = void 0; !b && c < a.length;) {\n          e = g(a[c]), e ? b = !0 : c++;\n        }\n\n        return e;\n      }\n    },\n        h = g(a);\n\n    return h ? f(e(h), h) : {};\n  }\n\n  function B() {\n    for (var a = [], b = 0; b < arguments.length; b++) {\n      a[b] = arguments[b];\n    }\n\n    if (E.logEnabled && \"undefined\" != typeof console) try {\n      var c = arguments[arguments.length - 1];\n      console.log(c);\n    } catch (d) {}\n  }\n\n  function C(a, b, c) {\n    return function () {\n      var d = null;\n\n      try {\n        null != b && (d = b.apply(this, arguments));\n      } catch (e) {\n        B(\"jsPlumb function failed : \" + e);\n      }\n\n      if (null != a && (null == c || d !== c)) try {\n        d = a.apply(this, arguments);\n      } catch (e) {\n        B(\"wrapped function failed : \" + e);\n      }\n      return d;\n    };\n  }\n\n  var D = this;\n  D.jsPlumbUtil = D.jsPlumbUtil || {};\n  var E = D.jsPlumbUtil;\n  \"undefined\" != typeof exports && (exports.jsPlumbUtil = E), E.isArray = a, E.isNumber = b, E.isString = c, E.isBoolean = d, E.isNull = e, E.isObject = f, E.isDate = g, E.isFunction = h, E.isNamedFunction = i, E.isEmpty = j, E.clone = k, E.merge = l, E.replace = m, E.functionChain = n, E.populate = o, E.findWithFunction = p, E.removeWithFunction = q, E.remove = r, E.addWithFunction = s, E.addToList = t, E.suggest = u, E.extend = v, E.uuid = w, E.fastTrim = x, E.each = y, E.map = z, E.mergeWithParents = A, E.logEnabled = !0, E.log = B, E.wrap = C;\n\n  var F = function () {\n    function a() {\n      var a = this;\n      this._listeners = {}, this.eventsSuspended = !1, this.tick = !1, this.eventsToDieOn = {\n        ready: !0\n      }, this.queue = [], this.bind = function (b, c, d) {\n        var e = function e(b) {\n          t(a._listeners, b, c, d), c.__jsPlumb = c.__jsPlumb || {}, c.__jsPlumb[w()] = b;\n        };\n\n        if (\"string\" == typeof b) e(b);else if (null != b.length) for (var f = 0; f < b.length; f++) {\n          e(b[f]);\n        }\n        return a;\n      }, this.fire = function (a, b, c) {\n        if (this.tick) this.queue.unshift(arguments);else {\n          if (this.tick = !0, !this.eventsSuspended && this._listeners[a]) {\n            var d = this._listeners[a].length,\n                e = 0,\n                f = !1,\n                g = null;\n            if (!this.shouldFireEvent || this.shouldFireEvent(a, b, c)) for (; !f && d > e && g !== !1;) {\n              if (this.eventsToDieOn[a]) this._listeners[a][e].apply(this, [b, c]);else try {\n                g = this._listeners[a][e].apply(this, [b, c]);\n              } catch (h) {\n                B(\"jsPlumb: fire failed for event \" + a + \" : \" + h);\n              }\n              e++, (null == this._listeners || null == this._listeners[a]) && (f = !0);\n            }\n          }\n\n          this.tick = !1, this._drain();\n        }\n        return this;\n      }, this._drain = function () {\n        var b = a.queue.pop();\n        b && a.fire.apply(a, b);\n      }, this.unbind = function (a, b) {\n        if (0 === arguments.length) this._listeners = {};else if (1 === arguments.length) {\n          if (\"string\" == typeof a) delete this._listeners[a];else if (a.__jsPlumb) {\n            var c = void 0;\n\n            for (var d in a.__jsPlumb) {\n              c = a.__jsPlumb[d], r(this._listeners[c] || [], a);\n            }\n          }\n        } else 2 === arguments.length && r(this._listeners[a] || [], b);\n        return this;\n      }, this.getListener = function (b) {\n        return a._listeners[b];\n      }, this.setSuspendEvents = function (b) {\n        a.eventsSuspended = b;\n      }, this.isSuspendEvents = function () {\n        return a.eventsSuspended;\n      }, this.silently = function (b) {\n        a.setSuspendEvents(!0);\n\n        try {\n          b();\n        } catch (c) {\n          B(\"Cannot execute silent function \" + c);\n        }\n\n        a.setSuspendEvents(!1);\n      }, this.cleanupListeners = function () {\n        for (var b in a._listeners) {\n          a._listeners[b] = null;\n        }\n      };\n    }\n\n    return a;\n  }();\n\n  E.EventGenerator = F;\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this;\n  a.jsPlumbUtil.matchesSelector = function (a, b, c) {\n    c = c || a.parentNode;\n\n    for (var d = c.querySelectorAll(b), e = 0; e < d.length; e++) {\n      if (d[e] === a) return !0;\n    }\n\n    return !1;\n  }, a.jsPlumbUtil.consume = function (a, b) {\n    a.stopPropagation ? a.stopPropagation() : a.returnValue = !1, !b && a.preventDefault && a.preventDefault();\n  }, a.jsPlumbUtil.sizeElement = function (a, b, c, d, e) {\n    a && (a.style.height = e + \"px\", a.height = e, a.style.width = d + \"px\", a.width = d, a.style.left = b + \"px\", a.style.top = c + \"px\");\n  };\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  var a = {\n    deriveAnchor: function deriveAnchor(a, b, c, d) {\n      return {\n        top: [\"TopRight\", \"TopLeft\"],\n        bottom: [\"BottomRight\", \"BottomLeft\"]\n      }[a][b];\n    }\n  },\n      b = this,\n      c = function c(a) {\n    this.count = 0, this.instance = a, this.lists = {}, this.instance.addList = function (a, b) {\n      return this.listManager.addList(a, b);\n    }, this.instance.removeList = function (a) {\n      this.listManager.removeList(a);\n    }, this.instance.bind(\"manageElement\", function (a) {\n      for (var b = this.instance.getSelector(a.el, \"[jtk-scrollable-list]\"), c = 0; c < b.length; c++) {\n        this.addList(b[c]);\n      }\n    }.bind(this)), this.instance.bind(\"unmanageElement\", function (a) {\n      this.removeList(a.el);\n    }), this.instance.bind(\"connection\", function (a, b) {\n      null == b && (this._maybeUpdateParentList(a.source), this._maybeUpdateParentList(a.target));\n    }.bind(this));\n  };\n\n  b.jsPlumbListManager = c, c.prototype = {\n    addList: function addList(b, c) {\n      var e = this.instance.extend({}, a);\n      c = this.instance.extend(e, c || {});\n      var f = [this.instance.getInstanceIndex(), this.count++].join(\"_\");\n      this.lists[f] = new d(this.instance, b, c, f);\n    },\n    removeList: function removeList(a) {\n      var b = this.lists[a._jsPlumbList];\n      b && (b.destroy(), delete this.lists[a._jsPlumbList]);\n    },\n    _maybeUpdateParentList: function _maybeUpdateParentList(a) {\n      for (var b = a.parentNode, c = this.instance.getContainer(); null != b && b !== c;) {\n        if (null != b._jsPlumbList && null != this.lists[b._jsPlumbList]) return void b._jsPlumbScrollHandler();\n        b = b.parentNode;\n      }\n    }\n  };\n\n  var d = function d(a, b, c, _d2) {\n    function e(a, b, d, e) {\n      return c.anchor ? c.anchor : c.deriveAnchor(a, b, d, e);\n    }\n\n    function f(a, b, d, e) {\n      return c.deriveEndpoint ? c.deriveEndpoint(a, b, d, e) : c.endpoint ? c.endpoint : d.type;\n    }\n\n    function g(b) {\n      for (var c = b.parentNode, d = a.getContainer(); null != c && c !== d;) {\n        if (a.hasClass(c, \"jtk-managed\")) return void a.recalculateOffsets(c);\n        c = c.parentNode;\n      }\n    }\n\n    b._jsPlumbList = _d2;\n\n    var h = function h(c) {\n      for (var d = a.getSelector(b, \".jtk-managed\"), h = a.getId(b), i = 0; i < d.length; i++) {\n        if (d[i].offsetTop < b.scrollTop) d[i]._jsPlumbProxies || (d[i]._jsPlumbProxies = d[i]._jsPlumbProxies || [], a.select({\n          source: d[i]\n        }).each(function (c) {\n          a.proxyConnection(c, 0, b, h, function () {\n            return f(\"top\", 0, c.endpoints[0], c);\n          }, function () {\n            return e(\"top\", 0, c.endpoints[0], c);\n          }), d[i]._jsPlumbProxies.push([c, 0]);\n        }), a.select({\n          target: d[i]\n        }).each(function (c) {\n          a.proxyConnection(c, 1, b, h, function () {\n            return f(\"top\", 1, c.endpoints[1], c);\n          }, function () {\n            return e(\"top\", 1, c.endpoints[1], c);\n          }), d[i]._jsPlumbProxies.push([c, 1]);\n        }));else if (d[i].offsetTop > b.scrollTop + b.offsetHeight) d[i]._jsPlumbProxies || (d[i]._jsPlumbProxies = d[i]._jsPlumbProxies || [], a.select({\n          source: d[i]\n        }).each(function (c) {\n          a.proxyConnection(c, 0, b, h, function () {\n            return f(\"bottom\", 0, c.endpoints[0], c);\n          }, function () {\n            return e(\"bottom\", 0, c.endpoints[0], c);\n          }), d[i]._jsPlumbProxies.push([c, 0]);\n        }), a.select({\n          target: d[i]\n        }).each(function (c) {\n          a.proxyConnection(c, 1, b, h, function () {\n            return f(\"bottom\", 1, c.endpoints[1], c);\n          }, function () {\n            return e(\"bottom\", 1, c.endpoints[1], c);\n          }), d[i]._jsPlumbProxies.push([c, 1]);\n        }));else if (d[i]._jsPlumbProxies) {\n          for (var j = 0; j < d[i]._jsPlumbProxies.length; j++) {\n            a.unproxyConnection(d[i]._jsPlumbProxies[j][0], d[i]._jsPlumbProxies[j][1], h);\n          }\n\n          delete d[i]._jsPlumbProxies;\n        }\n        a.revalidate(d[i]);\n      }\n\n      g(b);\n    };\n\n    a.setAttribute(b, \"jtk-scrollable-list\", \"true\"), b._jsPlumbScrollHandler = h, a.on(b, \"scroll\", h), h(), this.destroy = function () {\n      a.off(b, \"scroll\", h), delete b._jsPlumbScrollHandler;\n\n      for (var c = a.getSelector(b, \".jtk-managed\"), d = a.getId(b), e = 0; e < c.length; e++) {\n        if (c[e]._jsPlumbProxies) {\n          for (var f = 0; f < c[e]._jsPlumbProxies.length; f++) {\n            a.unproxyConnection(c[e]._jsPlumbProxies[f][0], c[e]._jsPlumbProxies[f][1], d);\n          }\n\n          delete c[e]._jsPlumbProxies;\n        }\n      }\n    };\n  };\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this,\n      b = a.jsPlumbUtil,\n      c = function c() {\n    return \"\" + new Date().getTime();\n  },\n      d = function d(a) {\n    if (a._jsPlumb.paintStyle && a._jsPlumb.hoverPaintStyle) {\n      var b = {};\n      o.extend(b, a._jsPlumb.paintStyle), o.extend(b, a._jsPlumb.hoverPaintStyle), delete a._jsPlumb.hoverPaintStyle, b.gradient && a._jsPlumb.paintStyle.fill && delete b.gradient, a._jsPlumb.hoverPaintStyle = b;\n    }\n  },\n      e = [\"tap\", \"dbltap\", \"click\", \"dblclick\", \"mouseover\", \"mouseout\", \"mousemove\", \"mousedown\", \"mouseup\", \"contextmenu\"],\n      f = function f(a, b, c, d) {\n    var e = a.getAttachedElements();\n    if (e) for (var f = 0, g = e.length; g > f; f++) {\n      d && d === e[f] || e[f].setHover(b, !0, c);\n    }\n  },\n      g = function g(a) {\n    return null == a ? null : a.split(\" \");\n  },\n      h = function h(a, b, c) {\n    for (var d in b) {\n      a[d] = c;\n    }\n  },\n      i = function i(a, c, d) {\n    if (a.getDefaultType) {\n      var e = a.getTypeDescriptor(),\n          f = {},\n          g = a.getDefaultType(),\n          i = b.merge({}, g);\n      h(f, g, \"__default\");\n\n      for (var j = 0, k = a._jsPlumb.types.length; k > j; j++) {\n        var l = a._jsPlumb.types[j];\n\n        if (\"__default\" !== l) {\n          var m = a._jsPlumb.instance.getType(l, e);\n\n          if (null != m) {\n            var n = [\"anchor\", \"anchors\", \"connector\", \"paintStyle\", \"hoverPaintStyle\", \"endpoint\", \"endpoints\", \"connectorOverlays\", \"connectorStyle\", \"connectorHoverStyle\", \"endpointStyle\", \"endpointHoverStyle\"],\n                o = [];\n            \"override\" === m.mergeStrategy ? Array.prototype.push.apply(n, [\"events\", \"overlays\", \"cssClass\"]) : o.push(\"cssClass\"), i = b.merge(i, m, o, n), h(f, m, l);\n          }\n        }\n      }\n\n      c && (i = b.populate(i, c, \"_\")), a.applyType(i, d, f), d || a.repaint();\n    }\n  },\n      j = a.jsPlumbUIComponent = function (a) {\n    b.EventGenerator.apply(this, arguments);\n    var c = this,\n        d = arguments,\n        e = c.idPrefix,\n        f = e + new Date().getTime();\n    this._jsPlumb = {\n      instance: a._jsPlumb,\n      parameters: a.parameters || {},\n      paintStyle: null,\n      hoverPaintStyle: null,\n      paintStyleInUse: null,\n      hover: !1,\n      beforeDetach: a.beforeDetach,\n      beforeDrop: a.beforeDrop,\n      overlayPlacements: [],\n      hoverClass: a.hoverClass || a._jsPlumb.Defaults.HoverClass,\n      types: [],\n      typeCache: {}\n    }, this.cacheTypeItem = function (a, b, c) {\n      this._jsPlumb.typeCache[c] = this._jsPlumb.typeCache[c] || {}, this._jsPlumb.typeCache[c][a] = b;\n    }, this.getCachedTypeItem = function (a, b) {\n      return this._jsPlumb.typeCache[b] ? this._jsPlumb.typeCache[b][a] : null;\n    }, this.getId = function () {\n      return f;\n    };\n    var g = a.overlays || [],\n        h = {};\n\n    if (this.defaultOverlayKeys) {\n      for (var i = 0; i < this.defaultOverlayKeys.length; i++) {\n        Array.prototype.push.apply(g, this._jsPlumb.instance.Defaults[this.defaultOverlayKeys[i]] || []);\n      }\n\n      for (i = 0; i < g.length; i++) {\n        var j = o.convertToFullOverlaySpec(g[i]);\n        h[j[1].id] = j;\n      }\n    }\n\n    var k = {\n      overlays: h,\n      parameters: a.parameters || {},\n      scope: a.scope || this._jsPlumb.instance.getDefaultScope()\n    };\n    if (this.getDefaultType = function () {\n      return k;\n    }, this.appendToDefaultType = function (a) {\n      for (var b in a) {\n        k[b] = a[b];\n      }\n    }, a.events) for (var l in a.events) {\n      c.bind(l, a.events[l]);\n    }\n    this.clone = function () {\n      var a = Object.create(this.constructor.prototype);\n      return this.constructor.apply(a, d), a;\n    }.bind(this), this.isDetachAllowed = function (a) {\n      var c = !0;\n      if (this._jsPlumb.beforeDetach) try {\n        c = this._jsPlumb.beforeDetach(a);\n      } catch (d) {\n        b.log(\"jsPlumb: beforeDetach callback failed\", d);\n      }\n      return c;\n    }, this.isDropAllowed = function (a, c, d, e, f, g, h) {\n      var i = this._jsPlumb.instance.checkCondition(\"beforeDrop\", {\n        sourceId: a,\n        targetId: c,\n        scope: d,\n        connection: e,\n        dropEndpoint: f,\n        source: g,\n        target: h\n      });\n\n      if (this._jsPlumb.beforeDrop) try {\n        i = this._jsPlumb.beforeDrop({\n          sourceId: a,\n          targetId: c,\n          scope: d,\n          connection: e,\n          dropEndpoint: f,\n          source: g,\n          target: h\n        });\n      } catch (j) {\n        b.log(\"jsPlumb: beforeDrop callback failed\", j);\n      }\n      return i;\n    };\n    var m = [];\n\n    this.setListenerComponent = function (a) {\n      for (var b = 0; b < m.length; b++) {\n        m[b][3] = a;\n      }\n    };\n  },\n      k = function k(a, b) {\n    var c = a._jsPlumb.types[b],\n        d = a._jsPlumb.instance.getType(c, a.getTypeDescriptor());\n\n    null != d && d.cssClass && a.canvas && a._jsPlumb.instance.removeClass(a.canvas, d.cssClass);\n  };\n\n  b.extend(a.jsPlumbUIComponent, b.EventGenerator, {\n    getParameter: function getParameter(a) {\n      return this._jsPlumb.parameters[a];\n    },\n    setParameter: function setParameter(a, b) {\n      this._jsPlumb.parameters[a] = b;\n    },\n    getParameters: function getParameters() {\n      return this._jsPlumb.parameters;\n    },\n    setParameters: function setParameters(a) {\n      this._jsPlumb.parameters = a;\n    },\n    getClass: function getClass() {\n      return o.getClass(this.canvas);\n    },\n    hasClass: function hasClass(a) {\n      return o.hasClass(this.canvas, a);\n    },\n    addClass: function addClass(a) {\n      o.addClass(this.canvas, a);\n    },\n    removeClass: function removeClass(a) {\n      o.removeClass(this.canvas, a);\n    },\n    updateClasses: function updateClasses(a, b) {\n      o.updateClasses(this.canvas, a, b);\n    },\n    setType: function setType(a, b, c) {\n      this.clearTypes(), this._jsPlumb.types = g(a) || [], i(this, b, c);\n    },\n    getType: function getType() {\n      return this._jsPlumb.types;\n    },\n    reapplyTypes: function reapplyTypes(a, b) {\n      i(this, a, b);\n    },\n    hasType: function hasType(a) {\n      return -1 !== this._jsPlumb.types.indexOf(a);\n    },\n    addType: function addType(a, b, c) {\n      var d = g(a),\n          e = !1;\n\n      if (null != d) {\n        for (var f = 0, h = d.length; h > f; f++) {\n          this.hasType(d[f]) || (this._jsPlumb.types.push(d[f]), e = !0);\n        }\n\n        e && i(this, b, c);\n      }\n    },\n    removeType: function removeType(a, b, c) {\n      var d = g(a),\n          e = !1,\n          f = function (a) {\n        var b = this._jsPlumb.types.indexOf(a);\n\n        return -1 !== b ? (k(this, b), this._jsPlumb.types.splice(b, 1), !0) : !1;\n      }.bind(this);\n\n      if (null != d) {\n        for (var h = 0, j = d.length; j > h; h++) {\n          e = f(d[h]) || e;\n        }\n\n        e && i(this, b, c);\n      }\n    },\n    clearTypes: function clearTypes(a, b) {\n      for (var c = this._jsPlumb.types.length, d = 0; c > d; d++) {\n        k(this, 0), this._jsPlumb.types.splice(0, 1);\n      }\n\n      i(this, a, b);\n    },\n    toggleType: function toggleType(a, b, c) {\n      var d = g(a);\n\n      if (null != d) {\n        for (var e = 0, f = d.length; f > e; e++) {\n          var h = this._jsPlumb.types.indexOf(d[e]);\n\n          -1 !== h ? (k(this, h), this._jsPlumb.types.splice(h, 1)) : this._jsPlumb.types.push(d[e]);\n        }\n\n        i(this, b, c);\n      }\n    },\n    applyType: function applyType(a, b) {\n      if (this.setPaintStyle(a.paintStyle, b), this.setHoverPaintStyle(a.hoverPaintStyle, b), a.parameters) for (var c in a.parameters) {\n        this.setParameter(c, a.parameters[c]);\n      }\n      this._jsPlumb.paintStyleInUse = this.getPaintStyle();\n    },\n    setPaintStyle: function setPaintStyle(a, b) {\n      this._jsPlumb.paintStyle = a, this._jsPlumb.paintStyleInUse = this._jsPlumb.paintStyle, d(this), b || this.repaint();\n    },\n    getPaintStyle: function getPaintStyle() {\n      return this._jsPlumb.paintStyle;\n    },\n    setHoverPaintStyle: function setHoverPaintStyle(a, b) {\n      this._jsPlumb.hoverPaintStyle = a, d(this), b || this.repaint();\n    },\n    getHoverPaintStyle: function getHoverPaintStyle() {\n      return this._jsPlumb.hoverPaintStyle;\n    },\n    destroy: function destroy(a) {\n      (a || null == this.typeId) && (this.cleanupListeners(), this.clone = null, this._jsPlumb = null);\n    },\n    isHover: function isHover() {\n      return this._jsPlumb.hover;\n    },\n    setHover: function setHover(a, b, d) {\n      if (this._jsPlumb && !this._jsPlumb.instance.currentlyDragging && !this._jsPlumb.instance.isHoverSuspended()) {\n        this._jsPlumb.hover = a;\n        var e = a ? \"addClass\" : \"removeClass\";\n        null != this.canvas && (null != this._jsPlumb.instance.hoverClass && this._jsPlumb.instance[e](this.canvas, this._jsPlumb.instance.hoverClass), null != this._jsPlumb.hoverClass && this._jsPlumb.instance[e](this.canvas, this._jsPlumb.hoverClass)), null != this._jsPlumb.hoverPaintStyle && (this._jsPlumb.paintStyleInUse = a ? this._jsPlumb.hoverPaintStyle : this._jsPlumb.paintStyle, this._jsPlumb.instance.isSuspendDrawing() || (d = d || c(), this.repaint({\n          timestamp: d,\n          recalc: !1\n        }))), this.getAttachedElements && !b && f(this, a, c(), this);\n      }\n    }\n  });\n\n  var l = 0,\n      m = function m() {\n    var a = l + 1;\n    return l++, a;\n  },\n      n = a.jsPlumbInstance = function (d) {\n    this.version = \"2.12.9\", this.Defaults = {\n      Anchor: \"Bottom\",\n      Anchors: [null, null],\n      ConnectionsDetachable: !0,\n      ConnectionOverlays: [],\n      Connector: \"Bezier\",\n      Container: null,\n      DoNotThrowErrors: !1,\n      DragOptions: {},\n      DropOptions: {},\n      Endpoint: \"Dot\",\n      EndpointOverlays: [],\n      Endpoints: [null, null],\n      EndpointStyle: {\n        fill: \"#456\"\n      },\n      EndpointStyles: [null, null],\n      EndpointHoverStyle: null,\n      EndpointHoverStyles: [null, null],\n      HoverPaintStyle: null,\n      LabelStyle: {\n        color: \"black\"\n      },\n      LogEnabled: !1,\n      Overlays: [],\n      MaxConnections: 1,\n      PaintStyle: {\n        \"stroke-width\": 4,\n        stroke: \"#456\"\n      },\n      ReattachConnections: !1,\n      RenderMode: \"svg\",\n      Scope: \"jsPlumb_DefaultScope\"\n    }, d && o.extend(this.Defaults, d), this.logEnabled = this.Defaults.LogEnabled, this._connectionTypes = {}, this._endpointTypes = {}, b.EventGenerator.apply(this);\n\n    var f = this,\n        g = m(),\n        h = f.bind,\n        i = {},\n        k = 1,\n        l = function l(a) {\n      if (null == a) return null;\n      if (3 === a.nodeType || 8 === a.nodeType) return {\n        el: a,\n        text: !0\n      };\n      var c = f.getElement(a);\n      return {\n        el: c,\n        id: b.isString(a) && null == c ? a : T(c)\n      };\n    };\n\n    this.getInstanceIndex = function () {\n      return g;\n    }, this.setZoom = function (a, b) {\n      return k = a, f.fire(\"zoom\", k), b && f.repaintEverything(), !0;\n    }, this.getZoom = function () {\n      return k;\n    };\n\n    for (var n in this.Defaults) {\n      i[n] = this.Defaults[n];\n    }\n\n    var p,\n        q = [];\n    this.unbindContainer = function () {\n      if (null != p && q.length > 0) for (var a = 0; a < q.length; a++) {\n        f.off(p, q[a][0], q[a][1]);\n      }\n    }, this.setContainer = function (a) {\n      this.unbindContainer(), a = this.getElement(a), this.select().each(function (b) {\n        b.moveParent(a);\n      }), this.selectEndpoints().each(function (b) {\n        b.moveParent(a);\n      });\n      var b = p;\n      p = a, q.length = 0;\n\n      for (var c = {\n        endpointclick: \"endpointClick\",\n        endpointdblclick: \"endpointDblClick\"\n      }, d = function d(a, b, _d3) {\n        var e = b.srcElement || b.target,\n            g = (e && e.parentNode ? e.parentNode._jsPlumb : null) || (e ? e._jsPlumb : null) || (e && e.parentNode && e.parentNode.parentNode ? e.parentNode.parentNode._jsPlumb : null);\n\n        if (g) {\n          g.fire(a, g, b);\n          var h = _d3 ? c[_d3 + a] || a : a;\n          f.fire(h, g.component || g, b);\n        }\n      }, g = function g(a, b, c) {\n        q.push([a, c]), f.on(p, a, b, c);\n      }, h = function h(a) {\n        g(a, \".jtk-connector\", function (b) {\n          d(a, b);\n        }), g(a, \".jtk-endpoint\", function (b) {\n          d(a, b, \"endpoint\");\n        }), g(a, \".jtk-overlay\", function (b) {\n          d(a, b);\n        });\n      }, i = 0; i < e.length; i++) {\n        h(e[i]);\n      }\n\n      for (var j in w) {\n        var k = w[j].el;\n        k.parentNode === b && (b.removeChild(k), p.appendChild(k));\n      }\n    }, this.getContainer = function () {\n      return p;\n    }, this.bind = function (a, b) {\n      \"ready\" === a && s ? b() : h.apply(f, [a, b]);\n    }, f.importDefaults = function (a) {\n      for (var b in a) {\n        f.Defaults[b] = a[b];\n      }\n\n      return a.Container && f.setContainer(a.Container), f;\n    }, f.restoreDefaults = function () {\n      return f.Defaults = o.extend({}, i), f;\n    };\n\n    var r = null,\n        s = !1,\n        t = [],\n        u = {},\n        v = {},\n        w = {},\n        x = {},\n        y = {},\n        z = !1,\n        A = [],\n        B = !1,\n        C = null,\n        D = this.Defaults.Scope,\n        E = 1,\n        F = function F() {\n      return \"\" + E++;\n    },\n        G = function (a, b) {\n      p ? p.appendChild(a) : b ? this.getElement(b).appendChild(a) : this.appendToRoot(a);\n    }.bind(this),\n        H = function H(a, b, d, e) {\n      if (!B) {\n        var g,\n            h = T(a),\n            i = f.getDragManager();\n        i && (g = i.getElementsForDraggable(h)), null == d && (d = c());\n        var j = oa({\n          elId: h,\n          offset: b,\n          recalc: !1,\n          timestamp: d\n        });\n        if (g && j && j.o) for (var k in g) {\n          oa({\n            elId: g[k].id,\n            offset: {\n              left: j.o.left + g[k].offset.left,\n              top: j.o.top + g[k].offset.top\n            },\n            recalc: !1,\n            timestamp: d\n          });\n        }\n        if (f.anchorManager.redraw(h, b, d, null, e), g) for (var l in g) {\n          f.anchorManager.redraw(g[l].id, b, d, g[l].offset, e, !0);\n        }\n      }\n    },\n        I = function I(a) {\n      return v[a];\n    },\n        J = function J(a, b) {\n      for (var c = a.scope.split(/\\s/), d = b.scope.split(/\\s/), e = 0; e < c.length; e++) {\n        for (var f = 0; f < d.length; f++) {\n          if (d[f] === c[e]) return !0;\n        }\n      }\n\n      return !1;\n    },\n        K = function K(a, b) {\n      var c = o.extend({}, a);\n\n      for (var d in b) {\n        b[d] && (c[d] = b[d]);\n      }\n\n      return c;\n    },\n        L = function (a, c) {\n      var d = o.extend({}, a);\n      if (c && o.extend(d, c), d.source && (d.source.endpoint ? d.sourceEndpoint = d.source : d.source = f.getElement(d.source)), d.target && (d.target.endpoint ? d.targetEndpoint = d.target : d.target = f.getElement(d.target)), a.uuids && (d.sourceEndpoint = I(a.uuids[0]), d.targetEndpoint = I(a.uuids[1])), d.sourceEndpoint && d.sourceEndpoint.isFull()) return void b.log(f, \"could not add connection; source endpoint is full\");\n      if (d.targetEndpoint && d.targetEndpoint.isFull()) return void b.log(f, \"could not add connection; target endpoint is full\");\n\n      if (!d.type && d.sourceEndpoint && (d.type = d.sourceEndpoint.connectionType), d.sourceEndpoint && d.sourceEndpoint.connectorOverlays) {\n        d.overlays = d.overlays || [];\n\n        for (var e = 0, g = d.sourceEndpoint.connectorOverlays.length; g > e; e++) {\n          d.overlays.push(d.sourceEndpoint.connectorOverlays[e]);\n        }\n      }\n\n      d.sourceEndpoint && d.sourceEndpoint.scope && (d.scope = d.sourceEndpoint.scope), !d[\"pointer-events\"] && d.sourceEndpoint && d.sourceEndpoint.connectorPointerEvents && (d[\"pointer-events\"] = d.sourceEndpoint.connectorPointerEvents);\n\n      var h = function h(a, b, c) {\n        var e = K(b, {\n          anchor: d.anchors ? d.anchors[c] : d.anchor,\n          endpoint: d.endpoints ? d.endpoints[c] : d.endpoint,\n          paintStyle: d.endpointStyles ? d.endpointStyles[c] : d.endpointStyle,\n          hoverPaintStyle: d.endpointHoverStyles ? d.endpointHoverStyles[c] : d.endpointHoverStyle\n        });\n        return f.addEndpoint(a, e);\n      },\n          i = function i(a, b, c, e) {\n        if (d[a] && !d[a].endpoint && !d[a + \"Endpoint\"] && !d.newConnection) {\n          var f = T(d[a]),\n              g = c[f];\n\n          if (g = g ? g[e] : null) {\n            if (!g.enabled) return !1;\n            var i = o.extend({}, g.def);\n            delete i.label;\n            var j = null != g.endpoint && g.endpoint._jsPlumb ? g.endpoint : h(d[a], i, b);\n            if (j.isFull()) return !1;\n            d[a + \"Endpoint\"] = j, !d.scope && i.scope && (d.scope = i.scope), g.uniqueEndpoint ? g.endpoint ? j.finalEndpoint = g.endpoint : (g.endpoint = j, j.setDeleteOnEmpty(!1)) : j.setDeleteOnEmpty(!0), 0 === b && g.def.connectorOverlays && (d.overlays = d.overlays || [], Array.prototype.push.apply(d.overlays, g.def.connectorOverlays));\n          }\n        }\n      };\n\n      return i(\"source\", 0, this.sourceEndpointDefinitions, d.type || \"default\") !== !1 && i(\"target\", 1, this.targetEndpointDefinitions, d.type || \"default\") !== !1 ? (d.sourceEndpoint && d.targetEndpoint && (J(d.sourceEndpoint, d.targetEndpoint) || (d = null)), d) : void 0;\n    }.bind(f),\n        M = function M(a) {\n      var b = f.Defaults.ConnectionType || f.getDefaultConnectionType();\n      a._jsPlumb = f, a.newConnection = M, a.newEndpoint = O, a.endpointsByUUID = v, a.endpointsByElement = u, a.finaliseConnection = N, a.id = \"con_\" + F();\n      var c = new b(a);\n      return c.isDetachable() && (c.endpoints[0].initDraggable(\"_jsPlumbSource\"), c.endpoints[1].initDraggable(\"_jsPlumbTarget\")), c;\n    },\n        N = f.finaliseConnection = function (a, b, c, d) {\n      if (b = b || {}, a.suspendedEndpoint || t.push(a), a.pending = null, a.endpoints[0].isTemporarySource = !1, d !== !1 && f.anchorManager.newConnection(a), H(a.source), !b.doNotFireConnectionEvent && b.fireEvent !== !1) {\n        var e = {\n          connection: a,\n          source: a.source,\n          target: a.target,\n          sourceId: a.sourceId,\n          targetId: a.targetId,\n          sourceEndpoint: a.endpoints[0],\n          targetEndpoint: a.endpoints[1]\n        };\n        f.fire(\"connection\", e, c);\n      }\n    },\n        O = function O(a, b) {\n      var c = f.Defaults.EndpointType || o.Endpoint,\n          d = o.extend({}, a);\n      d._jsPlumb = f, d.newConnection = M, d.newEndpoint = O, d.endpointsByUUID = v, d.endpointsByElement = u, d.fireDetachEvent = W, d.elementId = b || T(d.source);\n      var e = new c(d);\n      return e.id = \"ep_\" + F(), na(d.elementId, d.source), o.headless || f.getDragManager().endpointAdded(d.source, b), e;\n    },\n        P = function P(a, b, c) {\n      var d = u[a];\n      if (d && d.length) for (var e = 0, f = d.length; f > e; e++) {\n        for (var g = 0, h = d[e].connections.length; h > g; g++) {\n          var i = b(d[e].connections[g]);\n          if (i) return;\n        }\n\n        c && c(d[e]);\n      }\n    },\n        Q = function Q(a, b, c) {\n      b = \"block\" === b;\n      var d = null;\n      c && (d = function d(a) {\n        a.setVisible(b, !0, !0);\n      });\n      var e = l(a);\n      P(e.id, function (a) {\n        if (b && c) {\n          var d = a.sourceId === e.id ? 1 : 0;\n          a.endpoints[d].isVisible() && a.setVisible(!0);\n        } else a.setVisible(b);\n      }, d);\n    },\n        R = function R(a, b) {\n      var c = null;\n      b && (c = function c(a) {\n        var b = a.isVisible();\n        a.setVisible(!b);\n      }), P(a, function (a) {\n        var b = a.isVisible();\n        a.setVisible(!b);\n      }, c);\n    },\n        S = function S(a) {\n      var b = x[a];\n      return b ? {\n        o: b,\n        s: A[a]\n      } : oa({\n        elId: a\n      });\n    },\n        T = function T(a, c, d) {\n      if (b.isString(a)) return a;\n      if (null == a) return null;\n      var e = f.getAttribute(a, \"id\");\n      return e && \"undefined\" !== e || (2 === arguments.length && void 0 !== arguments[1] ? e = c : (1 === arguments.length || 3 === arguments.length && !arguments[2]) && (e = \"jsPlumb_\" + g + \"_\" + F()), d || f.setAttribute(a, \"id\", e)), e;\n    };\n\n    this.setConnectionBeingDragged = function (a) {\n      z = a;\n    }, this.isConnectionBeingDragged = function () {\n      return z;\n    }, this.getManagedElements = function () {\n      return w;\n    }, this.connectorClass = \"jtk-connector\", this.connectorOutlineClass = \"jtk-connector-outline\", this.connectedClass = \"jtk-connected\", this.hoverClass = \"jtk-hover\", this.endpointClass = \"jtk-endpoint\", this.endpointConnectedClass = \"jtk-endpoint-connected\", this.endpointFullClass = \"jtk-endpoint-full\", this.endpointDropAllowedClass = \"jtk-endpoint-drop-allowed\", this.endpointDropForbiddenClass = \"jtk-endpoint-drop-forbidden\", this.overlayClass = \"jtk-overlay\", this.draggingClass = \"jtk-dragging\", this.elementDraggingClass = \"jtk-element-dragging\", this.sourceElementDraggingClass = \"jtk-source-element-dragging\", this.targetElementDraggingClass = \"jtk-target-element-dragging\", this.endpointAnchorClassPrefix = \"jtk-endpoint-anchor\", this.hoverSourceClass = \"jtk-source-hover\", this.hoverTargetClass = \"jtk-target-hover\", this.dragSelectClass = \"jtk-drag-select\", this.Anchors = {}, this.Connectors = {\n      svg: {}\n    }, this.Endpoints = {\n      svg: {}\n    }, this.Overlays = {\n      svg: {}\n    }, this.ConnectorRenderers = {}, this.SVG = \"svg\", this.addEndpoint = function (a, c, d) {\n      d = d || {};\n      var e = o.extend({}, d);\n      o.extend(e, c), e.endpoint = e.endpoint || f.Defaults.Endpoint, e.paintStyle = e.paintStyle || f.Defaults.EndpointStyle;\n\n      for (var g = [], h = b.isArray(a) || null != a.length && !b.isString(a) ? a : [a], i = 0, j = h.length; j > i; i++) {\n        e.source = f.getElement(h[i]), la(e.source);\n        var k = T(e.source),\n            l = O(e, k),\n            m = na(k, e.source).info.o;\n        b.addToList(u, k, l), B || l.paint({\n          anchorLoc: l.anchor.compute({\n            xy: [m.left, m.top],\n            wh: A[k],\n            element: l,\n            timestamp: C\n          }),\n          timestamp: C\n        }), g.push(l);\n      }\n\n      return 1 === g.length ? g[0] : g;\n    }, this.addEndpoints = function (a, c, d) {\n      for (var e = [], g = 0, h = c.length; h > g; g++) {\n        var i = f.addEndpoint(a, c[g], d);\n        b.isArray(i) ? Array.prototype.push.apply(e, i) : e.push(i);\n      }\n\n      return e;\n    }, this.animate = function (a, c, d) {\n      if (!this.animationSupported) return !1;\n      d = d || {};\n      var e = f.getElement(a),\n          g = T(e),\n          h = o.animEvents.step,\n          i = o.animEvents.complete;\n      d[h] = b.wrap(d[h], function () {\n        f.revalidate(g);\n      }), d[i] = b.wrap(d[i], function () {\n        f.revalidate(g);\n      }), f.doAnimate(e, c, d);\n    }, this.checkCondition = function (a, c) {\n      var d = f.getListener(a),\n          e = !0;\n\n      if (d && d.length > 0) {\n        var g = Array.prototype.slice.call(arguments, 1);\n\n        try {\n          for (var h = 0, i = d.length; i > h; h++) {\n            e = e && d[h].apply(d[h], g);\n          }\n        } catch (j) {\n          b.log(f, \"cannot check condition [\" + a + \"]\" + j);\n        }\n      }\n\n      return e;\n    }, this.connect = function (a, c) {\n      var d,\n          e = L(a, c);\n\n      if (e) {\n        if (null == e.source && null == e.sourceEndpoint) return void b.log(\"Cannot establish connection - source does not exist\");\n        if (null == e.target && null == e.targetEndpoint) return void b.log(\"Cannot establish connection - target does not exist\");\n        la(e.source), d = M(e), N(d, e);\n      }\n\n      return d;\n    };\n\n    var U = [{\n      el: \"source\",\n      elId: \"sourceId\",\n      epDefs: \"sourceEndpointDefinitions\"\n    }, {\n      el: \"target\",\n      elId: \"targetId\",\n      epDefs: \"targetEndpointDefinitions\"\n    }],\n        V = function (a, b, c, d) {\n      var e,\n          f,\n          g,\n          h = U[c],\n          i = a[h.elId],\n          j = (a[h.el], a.endpoints[c]),\n          k = {\n        index: c,\n        originalSourceId: 0 === c ? i : a.sourceId,\n        newSourceId: a.sourceId,\n        originalTargetId: 1 === c ? i : a.targetId,\n        newTargetId: a.targetId,\n        connection: a\n      };\n      if (b.constructor === o.Endpoint) e = b, e.addConnection(a), b = e.element;else if (f = T(b), g = this[h.epDefs][f], f === a[h.elId]) e = null;else if (g) for (var l in g) {\n        if (!g[l].enabled) return;\n        e = null != g[l].endpoint && g[l].endpoint._jsPlumb ? g[l].endpoint : this.addEndpoint(b, g[l].def), g[l].uniqueEndpoint && (g[l].endpoint = e), e.addConnection(a);\n      } else e = a.makeEndpoint(0 === c, b, f);\n      return null != e && (j.detachFromConnection(a), a.endpoints[c] = e, a[h.el] = e.element, a[h.elId] = e.elementId, k[0 === c ? \"newSourceId\" : \"newTargetId\"] = e.elementId, X(k), d || a.repaint()), k.element = b, k;\n    }.bind(this);\n\n    this.setSource = function (a, b, c) {\n      var d = V(a, b, 0, c);\n      this.anchorManager.sourceChanged(d.originalSourceId, d.newSourceId, a, d.el);\n    }, this.setTarget = function (a, b, c) {\n      var d = V(a, b, 1, c);\n      this.anchorManager.updateOtherEndpoint(d.originalSourceId, d.originalTargetId, d.newTargetId, a);\n    }, this.deleteEndpoint = function (a, b, c) {\n      var d = \"string\" == typeof a ? v[a] : a;\n      return d && f.deleteObject({\n        endpoint: d,\n        dontUpdateHover: b,\n        deleteAttachedObjects: c\n      }), f;\n    }, this.deleteEveryEndpoint = function () {\n      var a = f.setSuspendDrawing(!0);\n\n      for (var b in u) {\n        var c = u[b];\n        if (c && c.length) for (var d = 0, e = c.length; e > d; d++) {\n          f.deleteEndpoint(c[d], !0);\n        }\n      }\n\n      u = {}, w = {}, v = {}, x = {}, y = {}, f.anchorManager.reset();\n      var g = f.getDragManager();\n      return g && g.reset(), a || f.setSuspendDrawing(!1), f;\n    };\n\n    var W = function W(a, b, c) {\n      var d = f.Defaults.ConnectionType || f.getDefaultConnectionType(),\n          e = a.constructor === d,\n          g = e ? {\n        connection: a,\n        source: a.source,\n        target: a.target,\n        sourceId: a.sourceId,\n        targetId: a.targetId,\n        sourceEndpoint: a.endpoints[0],\n        targetEndpoint: a.endpoints[1]\n      } : a;\n      b && f.fire(\"connectionDetached\", g, c), f.fire(\"internal.connectionDetached\", g, c), f.anchorManager.connectionDetached(g);\n    },\n        X = f.fireMoveEvent = function (a, b) {\n      f.fire(\"connectionMoved\", a, b);\n    };\n\n    this.unregisterEndpoint = function (a) {\n      a._jsPlumb.uuid && (v[a._jsPlumb.uuid] = null), f.anchorManager.deleteEndpoint(a);\n\n      for (var b in u) {\n        var c = u[b];\n\n        if (c) {\n          for (var d = [], e = 0, g = c.length; g > e; e++) {\n            c[e] !== a && d.push(c[e]);\n          }\n\n          u[b] = d;\n        }\n\n        u[b].length < 1 && delete u[b];\n      }\n    };\n\n    var Y = \"isDetachAllowed\",\n        Z = \"beforeDetach\",\n        $ = \"checkCondition\";\n    this.deleteConnection = function (a, c) {\n      return null != a && (c = c || {}, c.force || b.functionChain(!0, !1, [[a.endpoints[0], Y, [a]], [a.endpoints[1], Y, [a]], [a, Y, [a]], [f, $, [Z, a]]])) ? (a.setHover(!1), W(a, !a.pending && c.fireEvent !== !1, c.originalEvent), a.endpoints[0].detachFromConnection(a), a.endpoints[1].detachFromConnection(a), b.removeWithFunction(t, function (b) {\n        return a.id === b.id;\n      }), a.cleanup(), a.destroy(), !0) : !1;\n    }, this.deleteEveryConnection = function (a) {\n      a = a || {};\n      var b = t.length,\n          c = 0;\n      return f.batch(function () {\n        for (var d = 0; b > d; d++) {\n          c += f.deleteConnection(t[0], a) ? 1 : 0;\n        }\n      }), c;\n    }, this.deleteConnectionsForElement = function (a, b) {\n      b = b || {}, a = f.getElement(a);\n      var c = T(a),\n          d = u[c];\n      if (d && d.length) for (var e = 0, g = d.length; g > e; e++) {\n        d[e].deleteEveryConnection(b);\n      }\n      return f;\n    }, this.deleteObject = function (a) {\n      var c = {\n        endpoints: {},\n        connections: {},\n        endpointCount: 0,\n        connectionCount: 0\n      },\n          d = a.deleteAttachedObjects !== !1,\n          e = function e(b) {\n        null != b && null == c.connections[b.id] && (a.dontUpdateHover || null == b._jsPlumb || b.setHover(!1), c.connections[b.id] = b, c.connectionCount++);\n      },\n          g = function g(b) {\n        if (null != b && null == c.endpoints[b.id] && (a.dontUpdateHover || null == b._jsPlumb || b.setHover(!1), c.endpoints[b.id] = b, c.endpointCount++, d)) for (var f = 0; f < b.connections.length; f++) {\n          var g = b.connections[f];\n          e(g);\n        }\n      };\n\n      a.connection ? e(a.connection) : g(a.endpoint);\n\n      for (var h in c.connections) {\n        var i = c.connections[h];\n\n        if (i._jsPlumb) {\n          b.removeWithFunction(t, function (a) {\n            return i.id === a.id;\n          }), W(i, a.fireEvent === !1 ? !1 : !i.pending, a.originalEvent);\n          var j = null == a.deleteAttachedObjects ? null : !a.deleteAttachedObjects;\n          i.endpoints[0].detachFromConnection(i, null, j), i.endpoints[1].detachFromConnection(i, null, j), i.cleanup(!0), i.destroy(!0);\n        }\n      }\n\n      for (var k in c.endpoints) {\n        var l = c.endpoints[k];\n        l._jsPlumb && (f.unregisterEndpoint(l), l.cleanup(!0), l.destroy(!0));\n      }\n\n      return c;\n    };\n\n    var _ = function _(a, b, c, d) {\n      for (var e = 0, f = a.length; f > e; e++) {\n        a[e][b].apply(a[e], c);\n      }\n\n      return d(a);\n    },\n        aa = function aa(a, b, c) {\n      for (var d = [], e = 0, f = a.length; f > e; e++) {\n        d.push([a[e][b].apply(a[e], c), a[e]]);\n      }\n\n      return d;\n    },\n        ba = function ba(a, b, c) {\n      return function () {\n        return _(a, b, arguments, c);\n      };\n    },\n        ca = function ca(a, b) {\n      return function () {\n        return aa(a, b, arguments);\n      };\n    },\n        da = function da(a, b) {\n      var c = [];\n      if (a) if (\"string\" == typeof a) {\n        if (\"*\" === a) return a;\n        c.push(a);\n      } else if (b) c = a;else if (a.length) for (var d = 0, e = a.length; e > d; d++) {\n        c.push(l(a[d]).id);\n      } else c.push(l(a).id);\n      return c;\n    },\n        ea = function ea(a, b, c) {\n      return \"*\" === a ? !0 : a.length > 0 ? -1 !== a.indexOf(b) : !c;\n    };\n\n    this.getConnections = function (a, b) {\n      a ? a.constructor === String && (a = {\n        scope: a\n      }) : a = {};\n\n      for (var c = a.scope || f.getDefaultScope(), d = da(c, !0), e = da(a.source), g = da(a.target), h = !b && d.length > 1 ? {} : [], i = function i(a, c) {\n        if (!b && d.length > 1) {\n          var e = h[a];\n          null == e && (e = h[a] = []), e.push(c);\n        } else h.push(c);\n      }, j = 0, k = t.length; k > j; j++) {\n        var l = t[j],\n            m = l.proxies && l.proxies[0] ? l.proxies[0].originalEp.elementId : l.sourceId,\n            n = l.proxies && l.proxies[1] ? l.proxies[1].originalEp.elementId : l.targetId;\n        ea(d, l.scope) && ea(e, m) && ea(g, n) && i(l.scope, l);\n      }\n\n      return h;\n    };\n\n    var fa = function fa(a, b) {\n      return function (c) {\n        for (var d = 0, e = a.length; e > d; d++) {\n          c(a[d]);\n        }\n\n        return b(a);\n      };\n    },\n        ga = function ga(a) {\n      return function (b) {\n        return a[b];\n      };\n    },\n        ha = function ha(a, b) {\n      var c,\n          d,\n          e = {\n        length: a.length,\n        each: fa(a, b),\n        get: ga(a)\n      },\n          f = [\"setHover\", \"removeAllOverlays\", \"setLabel\", \"addClass\", \"addOverlay\", \"removeOverlay\", \"removeOverlays\", \"showOverlay\", \"hideOverlay\", \"showOverlays\", \"hideOverlays\", \"setPaintStyle\", \"setHoverPaintStyle\", \"setSuspendEvents\", \"setParameter\", \"setParameters\", \"setVisible\", \"repaint\", \"addType\", \"toggleType\", \"removeType\", \"removeClass\", \"setType\", \"bind\", \"unbind\"],\n          g = [\"getLabel\", \"getOverlay\", \"isHover\", \"getParameter\", \"getParameters\", \"getPaintStyle\", \"getHoverPaintStyle\", \"isVisible\", \"hasType\", \"getType\", \"isSuspendEvents\"];\n\n      for (c = 0, d = f.length; d > c; c++) {\n        e[f[c]] = ba(a, f[c], b);\n      }\n\n      for (c = 0, d = g.length; d > c; c++) {\n        e[g[c]] = ca(a, g[c]);\n      }\n\n      return e;\n    },\n        ia = function ia(a) {\n      var b = ha(a, ia);\n      return o.extend(b, {\n        setDetachable: ba(a, \"setDetachable\", ia),\n        setReattach: ba(a, \"setReattach\", ia),\n        setConnector: ba(a, \"setConnector\", ia),\n        \"delete\": function _delete() {\n          for (var b = 0, c = a.length; c > b; b++) {\n            f.deleteConnection(a[b]);\n          }\n        },\n        isDetachable: ca(a, \"isDetachable\"),\n        isReattach: ca(a, \"isReattach\")\n      });\n    },\n        ja = function ja(a) {\n      var b = ha(a, ja);\n      return o.extend(b, {\n        setEnabled: ba(a, \"setEnabled\", ja),\n        setAnchor: ba(a, \"setAnchor\", ja),\n        isEnabled: ca(a, \"isEnabled\"),\n        deleteEveryConnection: function deleteEveryConnection() {\n          for (var b = 0, c = a.length; c > b; b++) {\n            a[b].deleteEveryConnection();\n          }\n        },\n        \"delete\": function _delete() {\n          for (var b = 0, c = a.length; c > b; b++) {\n            f.deleteEndpoint(a[b]);\n          }\n        }\n      });\n    };\n\n    this.select = function (a) {\n      return a = a || {}, a.scope = a.scope || \"*\", ia(a.connections || f.getConnections(a, !0));\n    }, this.selectEndpoints = function (a) {\n      a = a || {}, a.scope = a.scope || \"*\";\n      var b = !a.element && !a.source && !a.target,\n          c = b ? \"*\" : da(a.element),\n          d = b ? \"*\" : da(a.source),\n          e = b ? \"*\" : da(a.target),\n          f = da(a.scope, !0),\n          g = [];\n\n      for (var h in u) {\n        var i = ea(c, h, !0),\n            j = ea(d, h, !0),\n            k = \"*\" !== d,\n            l = ea(e, h, !0),\n            m = \"*\" !== e;\n        if (i || j || l) a: for (var n = 0, o = u[h].length; o > n; n++) {\n          var p = u[h][n];\n\n          if (ea(f, p.scope, !0)) {\n            var q = k && d.length > 0 && !p.isSource,\n                r = m && e.length > 0 && !p.isTarget;\n            if (q || r) continue a;\n            g.push(p);\n          }\n        }\n      }\n\n      return ja(g);\n    }, this.getAllConnections = function () {\n      return t;\n    }, this.getDefaultScope = function () {\n      return D;\n    }, this.getEndpoint = I, this.getEndpoints = function (a) {\n      return u[l(a).id] || [];\n    }, this.getDefaultEndpointType = function () {\n      return o.Endpoint;\n    }, this.getDefaultConnectionType = function () {\n      return o.Connection;\n    }, this.getId = T, this.draw = H, this.info = l, this.appendElement = G;\n    var ka = !1;\n    this.isHoverSuspended = function () {\n      return ka;\n    }, this.setHoverSuspended = function (a) {\n      ka = a;\n    }, this.hide = function (a, b) {\n      return Q(a, \"none\", b), f;\n    }, this.idstamp = F;\n\n    var la = function la(a) {\n      if (!p && a) {\n        var b = f.getElement(a);\n        b.offsetParent && f.setContainer(b.offsetParent);\n      }\n    },\n        ma = function ma() {\n      f.Defaults.Container && f.setContainer(f.Defaults.Container);\n    },\n        na = f.manage = function (a, b, c) {\n      return w[a] || (w[a] = {\n        el: b,\n        endpoints: [],\n        connections: []\n      }, w[a].info = oa({\n        elId: a,\n        timestamp: C\n      }), f.addClass(b, \"jtk-managed\"), c || f.fire(\"manageElement\", {\n        id: a,\n        info: w[a].info,\n        el: b\n      })), w[a];\n    },\n        oa = (f.unmanage = function (a) {\n      if (w[a]) {\n        var b = w[a].el;\n        f.removeClass(b, \"jtk-managed\"), delete w[a], f.fire(\"unmanageElement\", {\n          id: a,\n          el: b\n        });\n      }\n    }, function (a) {\n      var b,\n          c = a.timestamp,\n          d = a.recalc,\n          e = a.offset,\n          g = a.elId;\n      return B && !c && (c = C), !d && c && c === y[g] ? {\n        o: a.offset || x[g],\n        s: A[g]\n      } : (d || !e && null == x[g] ? (b = w[g] ? w[g].el : null, null != b && (A[g] = f.getSize(b), x[g] = f.getOffset(b), y[g] = c)) : (x[g] = e || x[g], null == A[g] && (b = w[g].el, null != b && (A[g] = f.getSize(b))), y[g] = c), x[g] && !x[g].right && (x[g].right = x[g].left + A[g][0], x[g].bottom = x[g].top + A[g][1], x[g].width = A[g][0], x[g].height = A[g][1], x[g].centerx = x[g].left + x[g].width / 2, x[g].centery = x[g].top + x[g].height / 2), {\n        o: x[g],\n        s: A[g]\n      });\n    });\n\n    this.updateOffset = oa, this.init = function () {\n      s || (ma(), f.anchorManager = new a.jsPlumb.AnchorManager({\n        jsPlumbInstance: f\n      }), s = !0, f.fire(\"ready\", f));\n    }.bind(this), this.log = r, this.jsPlumbUIComponent = j, this.makeAnchor = function () {\n      var c,\n          d = function d(b, c) {\n        if (a.jsPlumb.Anchors[b]) return new a.jsPlumb.Anchors[b](c);\n        if (!f.Defaults.DoNotThrowErrors) throw {\n          msg: \"jsPlumb: unknown anchor type '\" + b + \"'\"\n        };\n      };\n\n      if (0 === arguments.length) return null;\n      var e = arguments[0],\n          g = arguments[1],\n          h = (arguments[2], null);\n      if (e.compute && e.getOrientation) return e;\n      if (\"string\" == typeof e) h = d(arguments[0], {\n        elementId: g,\n        jsPlumbInstance: f\n      });else if (b.isArray(e)) if (b.isArray(e[0]) || b.isString(e[0])) 2 === e.length && b.isObject(e[1]) ? b.isString(e[0]) ? (c = a.jsPlumb.extend({\n        elementId: g,\n        jsPlumbInstance: f\n      }, e[1]), h = d(e[0], c)) : (c = a.jsPlumb.extend({\n        elementId: g,\n        jsPlumbInstance: f,\n        anchors: e[0]\n      }, e[1]), h = new a.jsPlumb.DynamicAnchor(c)) : h = new o.DynamicAnchor({\n        anchors: e,\n        selector: null,\n        elementId: g,\n        jsPlumbInstance: f\n      });else {\n        var i = {\n          x: e[0],\n          y: e[1],\n          orientation: e.length >= 4 ? [e[2], e[3]] : [0, 0],\n          offsets: e.length >= 6 ? [e[4], e[5]] : [0, 0],\n          elementId: g,\n          jsPlumbInstance: f,\n          cssClass: 7 === e.length ? e[6] : null\n        };\n        h = new a.jsPlumb.Anchor(i), h.clone = function () {\n          return new a.jsPlumb.Anchor(i);\n        };\n      }\n      return h.id || (h.id = \"anchor_\" + F()), h;\n    }, this.makeAnchors = function (c, d, e) {\n      for (var g = [], h = 0, i = c.length; i > h; h++) {\n        \"string\" == typeof c[h] ? g.push(a.jsPlumb.Anchors[c[h]]({\n          elementId: d,\n          jsPlumbInstance: e\n        })) : b.isArray(c[h]) && g.push(f.makeAnchor(c[h], d, e));\n      }\n\n      return g;\n    }, this.makeDynamicAnchor = function (b, c) {\n      return new a.jsPlumb.DynamicAnchor({\n        anchors: b,\n        selector: c,\n        elementId: null,\n        jsPlumbInstance: f\n      });\n    }, this.targetEndpointDefinitions = {}, this.sourceEndpointDefinitions = {};\n\n    var pa = function pa(a, b, c, d, e) {\n      for (var f = a.target || a.srcElement, g = !1, h = d.getSelector(b, c), i = 0; i < h.length; i++) {\n        if (h[i] === f) {\n          g = !0;\n          break;\n        }\n      }\n\n      return e ? !g : g;\n    },\n        qa = function qa(c, d, e, g, h) {\n      var i = new j(d),\n          k = d._jsPlumb.EndpointDropHandler({\n        jsPlumb: f,\n        enabled: function enabled() {\n          return c.def.enabled;\n        },\n        isFull: function isFull() {\n          var a = f.select({\n            target: c.id\n          }).length;\n          return c.def.maxConnections > 0 && a >= c.def.maxConnections;\n        },\n        element: c.el,\n        elementId: c.id,\n        isSource: g,\n        isTarget: h,\n        addClass: function addClass(a) {\n          f.addClass(c.el, a);\n        },\n        removeClass: function removeClass(a) {\n          f.removeClass(c.el, a);\n        },\n        onDrop: function onDrop(a) {\n          var b = a.endpoints[0];\n          b.anchor.unlock();\n        },\n        isDropAllowed: function isDropAllowed() {\n          return i.isDropAllowed.apply(i, arguments);\n        },\n        isRedrop: function isRedrop(a) {\n          return null != a.suspendedElement && null != a.suspendedEndpoint && a.suspendedEndpoint.element === c.el;\n        },\n        getEndpoint: function getEndpoint(b) {\n          var e = c.def.endpoint;\n\n          if (null == e || null == e._jsPlumb) {\n            var g = f.deriveEndpointAndAnchorSpec(b.getType().join(\" \"), !0),\n                h = g.endpoints ? a.jsPlumb.extend(d, {\n              endpoint: c.def.def.endpoint || g.endpoints[1]\n            }) : d;\n            g.anchors && (h = a.jsPlumb.extend(h, {\n              anchor: c.def.def.anchor || g.anchors[1]\n            })), e = f.addEndpoint(c.el, h), e._mtNew = !0;\n          }\n\n          if (d.uniqueEndpoint && (c.def.endpoint = e), e.setDeleteOnEmpty(!0), b.isDetachable() && e.initDraggable(), null != e.anchor.positionFinder) {\n            var i = f.getUIPosition(arguments, f.getZoom()),\n                j = f.getOffset(c.el),\n                k = f.getSize(c.el),\n                l = null == i ? [0, 0] : e.anchor.positionFinder(i, j, k, e.anchor.constructorParams);\n            e.anchor.x = l[0], e.anchor.y = l[1];\n          }\n\n          return e;\n        },\n        maybeCleanup: function maybeCleanup(a) {\n          a._mtNew && 0 === a.connections.length ? f.deleteObject({\n            endpoint: a\n          }) : delete a._mtNew;\n        }\n      }),\n          l = a.jsPlumb.dragEvents.drop;\n\n      return e.scope = e.scope || d.scope || f.Defaults.Scope, e[l] = b.wrap(e[l], k, !0), e.rank = d.rank || 0, h && (e[a.jsPlumb.dragEvents.over] = function () {\n        return !0;\n      }), d.allowLoopback === !1 && (e.canDrop = function (a) {\n        var b = a.getDragElement()._jsPlumbRelatedElement;\n\n        return b !== c.el;\n      }), f.initDroppable(c.el, e, \"internal\"), k;\n    };\n\n    this.makeTarget = function (b, c, d) {\n      var e = a.jsPlumb.extend({\n        _jsPlumb: this\n      }, d);\n      a.jsPlumb.extend(e, c);\n\n      for (var g = e.maxConnections || -1, h = function (b) {\n        var c = l(b),\n            d = c.id,\n            h = a.jsPlumb.extend({}, e.dropOptions || {}),\n            i = e.connectionType || \"default\";\n        this.targetEndpointDefinitions[d] = this.targetEndpointDefinitions[d] || {}, la(d), c.el._isJsPlumbGroup && null == h.rank && (h.rank = -1);\n        var j = {\n          def: a.jsPlumb.extend({}, e),\n          uniqueEndpoint: e.uniqueEndpoint,\n          maxConnections: g,\n          enabled: !0\n        };\n        e.createEndpoint && (j.uniqueEndpoint = !0, j.endpoint = f.addEndpoint(b, j.def), j.endpoint.setDeleteOnEmpty(!1)), c.def = j, this.targetEndpointDefinitions[d][i] = j, qa(c, e, h, e.isSource === !0, !0), c.el._katavorioDrop[c.el._katavorioDrop.length - 1].targetDef = j;\n      }.bind(this), i = b.length && b.constructor !== String ? b : [b], j = 0, k = i.length; k > j; j++) {\n        h(i[j]);\n      }\n\n      return this;\n    }, this.unmakeTarget = function (a, b) {\n      var c = l(a);\n      return f.destroyDroppable(c.el, \"internal\"), b || delete this.targetEndpointDefinitions[c.id], this;\n    }, this.makeSource = function (c, d, e) {\n      var g = a.jsPlumb.extend({\n        _jsPlumb: this\n      }, e);\n      a.jsPlumb.extend(g, d);\n      var h = g.connectionType || \"default\",\n          i = f.deriveEndpointAndAnchorSpec(h);\n      g.endpoint = g.endpoint || i.endpoints[0], g.anchor = g.anchor || i.anchors[0];\n\n      for (var j = g.maxConnections || -1, m = g.onMaxConnections, n = function (d) {\n        var e = d.id,\n            i = this.getElement(d.el);\n        this.sourceEndpointDefinitions[e] = this.sourceEndpointDefinitions[e] || {}, la(e);\n        var l = {\n          def: a.jsPlumb.extend({}, g),\n          uniqueEndpoint: g.uniqueEndpoint,\n          maxConnections: j,\n          enabled: !0\n        };\n        g.createEndpoint && (l.uniqueEndpoint = !0, l.endpoint = f.addEndpoint(c, l.def), l.endpoint.setDeleteOnEmpty(!1)), this.sourceEndpointDefinitions[e][h] = l, d.def = l;\n        var n = a.jsPlumb.dragEvents.stop,\n            o = a.jsPlumb.dragEvents.drag,\n            p = a.jsPlumb.extend({}, g.dragOptions || {}),\n            q = p.drag,\n            r = p.stop,\n            s = null,\n            t = !1;\n        p.scope = p.scope || g.scope, p[o] = b.wrap(p[o], function () {\n          q && q.apply(this, arguments), t = !1;\n        }), p[n] = b.wrap(p[n], function () {\n          if (r && r.apply(this, arguments), this.currentlyDragging = !1, null != s._jsPlumb) {\n            var a = g.anchor || this.Defaults.Anchor,\n                b = s.anchor,\n                c = s.connections[0],\n                d = this.makeAnchor(a, e, this),\n                h = s.element;\n\n            if (null != d.positionFinder) {\n              var i = f.getOffset(h),\n                  j = this.getSize(h),\n                  k = {\n                left: i.left + b.x * j[0],\n                top: i.top + b.y * j[1]\n              },\n                  l = d.positionFinder(k, i, j, d.constructorParams);\n              d.x = l[0], d.y = l[1];\n            }\n\n            s.setAnchor(d, !0), s.repaint(), this.repaint(s.elementId), null != c && this.repaint(c.targetId);\n          }\n        }.bind(this));\n\n        var u = function (c) {\n          if (3 !== c.which && 2 !== c.button) {\n            var l = this.sourceEndpointDefinitions[e][h];\n\n            if (l.enabled) {\n              if (e = this.getId(this.getElement(d.el)), g.filter) {\n                var n = b.isString(g.filter) ? pa(c, d.el, g.filter, this, g.filterExclude) : g.filter(c, d.el);\n                if (n === !1) return;\n              }\n\n              var o = this.select({\n                source: e\n              }).length;\n              if (l.maxConnections >= 0 && o >= l.maxConnections) return m && m({\n                element: d.el,\n                maxConnections: j\n              }, c), !1;\n              var q = a.jsPlumb.getPositionOnElement(c, i, k),\n                  r = {};\n              a.jsPlumb.extend(r, l.def), r.isTemporarySource = !0, r.anchor = [q[0], q[1], 0, 0], r.dragOptions = p, l.def.scope && (r.scope = l.def.scope), s = this.addEndpoint(e, r), t = !0, s.setDeleteOnEmpty(!0), l.uniqueEndpoint && (l.endpoint ? s.finalEndpoint = l.endpoint : (l.endpoint = s, s.setDeleteOnEmpty(!1)));\n\n              var u = function u() {\n                f.off(s.canvas, \"mouseup\", u), f.off(d.el, \"mouseup\", u), t && (t = !1, f.deleteEndpoint(s));\n              };\n\n              f.on(s.canvas, \"mouseup\", u), f.on(d.el, \"mouseup\", u);\n              var v = {};\n              if (l.def.extract) for (var w in l.def.extract) {\n                var x = (c.srcElement || c.target).getAttribute(w);\n                x && (v[l.def.extract[w]] = x);\n              }\n              f.trigger(s.canvas, \"mousedown\", c, v), b.consume(c);\n            }\n          }\n        }.bind(this);\n\n        this.on(d.el, \"mousedown\", u), l.trigger = u, g.filter && (b.isString(g.filter) || b.isFunction(g.filter)) && f.setDragFilter(d.el, g.filter);\n        var v = a.jsPlumb.extend({}, g.dropOptions || {});\n        qa(d, g, v, !0, g.isTarget === !0);\n      }.bind(this), o = c.length && c.constructor !== String ? c : [c], p = 0, q = o.length; q > p; p++) {\n        n(l(o[p]));\n      }\n\n      return this;\n    }, this.unmakeSource = function (a, b, c) {\n      var d = l(a);\n      f.destroyDroppable(d.el, \"internal\");\n      var e = this.sourceEndpointDefinitions[d.id];\n      if (e) for (var g in e) {\n        if (null == b || b === g) {\n          var h = e[g].trigger;\n          h && f.off(d.el, \"mousedown\", h), c || delete this.sourceEndpointDefinitions[d.id][g];\n        }\n      }\n      return this;\n    }, this.unmakeEverySource = function () {\n      for (var a in this.sourceEndpointDefinitions) {\n        f.unmakeSource(a, null, !0);\n      }\n\n      return this.sourceEndpointDefinitions = {}, this;\n    };\n\n    var ra = function (a, c, d) {\n      c = b.isArray(c) ? c : [c];\n      var e = T(a);\n      d = d || \"default\";\n\n      for (var f = 0; f < c.length; f++) {\n        var g = this[c[f]][e];\n        if (g && g[d]) return g[d].def.scope || this.Defaults.Scope;\n      }\n    }.bind(this),\n        sa = function (a, c, d, e) {\n      d = b.isArray(d) ? d : [d];\n      var f = T(a);\n      e = e || \"default\";\n\n      for (var g = 0; g < d.length; g++) {\n        var h = this[d[g]][f];\n        h && h[e] && (h[e].def.scope = c);\n      }\n    }.bind(this);\n\n    this.getScope = function (a, b) {\n      return ra(a, [\"sourceEndpointDefinitions\", \"targetEndpointDefinitions\"]);\n    }, this.getSourceScope = function (a) {\n      return ra(a, \"sourceEndpointDefinitions\");\n    }, this.getTargetScope = function (a) {\n      return ra(a, \"targetEndpointDefinitions\");\n    }, this.setScope = function (a, b, c) {\n      this.setSourceScope(a, b, c), this.setTargetScope(a, b, c);\n    }, this.setSourceScope = function (a, b, c) {\n      sa(a, b, \"sourceEndpointDefinitions\", c), this.setDragScope(a, b);\n    }, this.setTargetScope = function (a, b, c) {\n      sa(a, b, \"targetEndpointDefinitions\", c), this.setDropScope(a, b);\n    }, this.unmakeEveryTarget = function () {\n      for (var a in this.targetEndpointDefinitions) {\n        f.unmakeTarget(a, !0);\n      }\n\n      return this.targetEndpointDefinitions = {}, this;\n    };\n\n    var ta = function (a, c, d, e, g) {\n      var h,\n          i,\n          j,\n          k = \"source\" === a ? this.sourceEndpointDefinitions : this.targetEndpointDefinitions;\n\n      if (g = g || \"default\", c.length && !b.isString(c)) {\n        h = [];\n\n        for (var m = 0, n = c.length; n > m; m++) {\n          i = l(c[m]), k[i.id] && k[i.id][g] && (h[m] = k[i.id][g].enabled, j = e ? !h[m] : d, k[i.id][g].enabled = j, f[j ? \"removeClass\" : \"addClass\"](i.el, \"jtk-\" + a + \"-disabled\"));\n        }\n      } else {\n        i = l(c);\n        var o = i.id;\n        k[o] && k[o][g] && (h = k[o][g].enabled, j = e ? !h : d, k[o][g].enabled = j, f[j ? \"removeClass\" : \"addClass\"](i.el, \"jtk-\" + a + \"-disabled\"));\n      }\n\n      return h;\n    }.bind(this),\n        ua = function (a, c) {\n      return b.isString(a) || !a.length ? c.apply(this, [a]) : a.length ? c.apply(this, [a[0]]) : void 0;\n    }.bind(this);\n\n    this.toggleSourceEnabled = function (a, b) {\n      return ta(\"source\", a, null, !0, b), this.isSourceEnabled(a, b);\n    }, this.setSourceEnabled = function (a, b, c) {\n      return ta(\"source\", a, b, null, c);\n    }, this.isSource = function (a, b) {\n      return b = b || \"default\", ua(a, function (a) {\n        var c = this.sourceEndpointDefinitions[l(a).id];\n        return null != c && null != c[b];\n      }.bind(this));\n    }, this.isSourceEnabled = function (a, b) {\n      return b = b || \"default\", ua(a, function (a) {\n        var c = this.sourceEndpointDefinitions[l(a).id];\n        return c && c[b] && c[b].enabled === !0;\n      }.bind(this));\n    }, this.toggleTargetEnabled = function (a, b) {\n      return ta(\"target\", a, null, !0, b), this.isTargetEnabled(a, b);\n    }, this.isTarget = function (a, b) {\n      return b = b || \"default\", ua(a, function (a) {\n        var c = this.targetEndpointDefinitions[l(a).id];\n        return null != c && null != c[b];\n      }.bind(this));\n    }, this.isTargetEnabled = function (a, b) {\n      return b = b || \"default\", ua(a, function (a) {\n        var c = this.targetEndpointDefinitions[l(a).id];\n        return c && c[b] && c[b].enabled === !0;\n      }.bind(this));\n    }, this.setTargetEnabled = function (a, b, c) {\n      return ta(\"target\", a, b, null, c);\n    }, this.ready = function (a) {\n      f.bind(\"ready\", a);\n    };\n\n    var va = function va(a, b) {\n      if (\"object\" == typeof a && a.length) for (var c = 0, d = a.length; d > c; c++) {\n        b(a[c]);\n      } else b(a);\n      return f;\n    };\n\n    this.repaint = function (a, b, c) {\n      return va(a, function (a) {\n        H(a, b, c);\n      });\n    }, this.revalidate = function (a, b, c) {\n      return va(a, function (a) {\n        var d = c ? a : f.getId(a);\n        f.updateOffset({\n          elId: d,\n          recalc: !0,\n          timestamp: b\n        });\n        var e = f.getDragManager();\n        e && e.updateOffsets(d), f.repaint(a);\n      });\n    }, this.repaintEverything = function () {\n      var a,\n          b = c();\n\n      for (a in u) {\n        f.updateOffset({\n          elId: a,\n          recalc: !0,\n          timestamp: b\n        });\n      }\n\n      for (a in u) {\n        H(a, null, b);\n      }\n\n      return this;\n    }, this.removeAllEndpoints = function (a, b, c) {\n      c = c || [];\n\n      var d = function d(a) {\n        var e,\n            g,\n            h = l(a),\n            i = u[h.id];\n        if (i) for (c.push(h), e = 0, g = i.length; g > e; e++) {\n          f.deleteEndpoint(i[e], !1);\n        }\n        if (delete u[h.id], b && h.el && 3 !== h.el.nodeType && 8 !== h.el.nodeType) for (e = 0, g = h.el.childNodes.length; g > e; e++) {\n          d(h.el.childNodes[e]);\n        }\n      };\n\n      return d(a), this;\n    };\n\n    var wa = function wa(a, b) {\n      f.removeAllEndpoints(a.id, !0, b);\n\n      for (var c = f.getDragManager(), d = function d(a) {\n        c && c.elementRemoved(a.id), f.anchorManager.clearFor(a.id), f.anchorManager.removeFloatingConnection(a.id), f.isSource(a.el) && f.unmakeSource(a.el), f.isTarget(a.el) && f.unmakeTarget(a.el), f.destroyDraggable(a.el), f.destroyDroppable(a.el), delete f.floatingConnections[a.id], delete w[a.id], delete x[a.id], a.el && (f.removeElement(a.el), a.el._jsPlumb = null);\n      }, e = 1; e < b.length; e++) {\n        d(b[e]);\n      }\n\n      d(a);\n    };\n\n    this.remove = function (a, b) {\n      var c = l(a),\n          d = [];\n      return c.text && c.el.parentNode ? c.el.parentNode.removeChild(c.el) : c.id && f.batch(function () {\n        wa(c, d);\n      }, b === !0), f;\n    }, this.empty = function (a, b) {\n      var c = [],\n          d = function d(a, b) {\n        var e = l(a);\n        if (e.text) e.el.parentNode.removeChild(e.el);else if (e.el) {\n          for (; e.el.childNodes.length > 0;) {\n            d(e.el.childNodes[0]);\n          }\n\n          b || wa(e, c);\n        }\n      };\n\n      return f.batch(function () {\n        d(a, !0);\n      }, b === !1), f;\n    }, this.reset = function (a) {\n      f.silently(function () {\n        ka = !1, f.removeAllGroups(), f.removeGroupManager(), f.deleteEveryEndpoint(), a || f.unbind(), this.targetEndpointDefinitions = {}, this.sourceEndpointDefinitions = {}, t.length = 0, this.doReset && this.doReset();\n      }.bind(this));\n    };\n\n    var xa = function xa(a) {\n      a.canvas && a.canvas.parentNode && a.canvas.parentNode.removeChild(a.canvas), a.cleanup(), a.destroy();\n    };\n\n    this.clear = function () {\n      f.select().each(xa), f.selectEndpoints().each(xa), u = {}, v = {};\n    }, this.setDefaultScope = function (a) {\n      return D = a, f;\n    }, this.deriveEndpointAndAnchorSpec = function (a, b) {\n      for (var c = ((b ? \"\" : \"default \") + a).split(/[\\s]/), d = null, e = null, g = null, h = null, i = 0; i < c.length; i++) {\n        var j = f.getType(c[i], \"connection\");\n        j && (j.endpoints && (d = j.endpoints), j.endpoint && (e = j.endpoint), j.anchors && (h = j.anchors), j.anchor && (g = j.anchor));\n      }\n\n      return {\n        endpoints: d ? d : [e, e],\n        anchors: h ? h : [g, g]\n      };\n    }, this.setId = function (a, c, d) {\n      var e;\n      b.isString(a) ? e = a : (a = this.getElement(a), e = this.getId(a));\n      var f = this.getConnections({\n        source: e,\n        scope: \"*\"\n      }, !0),\n          g = this.getConnections({\n        target: e,\n        scope: \"*\"\n      }, !0);\n      c = \"\" + c, d ? a = this.getElement(c) : (a = this.getElement(e), this.setAttribute(a, \"id\", c)), u[c] = u[e] || [];\n\n      for (var h = 0, i = u[c].length; i > h; h++) {\n        u[c][h].setElementId(c), u[c][h].setReferenceElement(a);\n      }\n\n      delete u[e], this.sourceEndpointDefinitions[c] = this.sourceEndpointDefinitions[e], delete this.sourceEndpointDefinitions[e], this.targetEndpointDefinitions[c] = this.targetEndpointDefinitions[e], delete this.targetEndpointDefinitions[e], this.anchorManager.changeId(e, c);\n      var j = this.getDragManager();\n      j && j.changeId(e, c), w[c] = w[e], delete w[e];\n\n      var k = function k(b, d, e) {\n        for (var f = 0, g = b.length; g > f; f++) {\n          b[f].endpoints[d].setElementId(c), b[f].endpoints[d].setReferenceElement(a), b[f][e + \"Id\"] = c, b[f][e] = a;\n        }\n      };\n\n      k(f, 0, \"source\"), k(g, 1, \"target\"), this.repaint(c);\n    }, this.setDebugLog = function (a) {\n      r = a;\n    }, this.setSuspendDrawing = function (a, b) {\n      var c = B;\n      return B = a, C = a ? new Date().getTime() : null, b && this.repaintEverything(), c;\n    }, this.isSuspendDrawing = function () {\n      return B;\n    }, this.getSuspendedAt = function () {\n      return C;\n    }, this.batch = function (a, c) {\n      var d = this.isSuspendDrawing();\n      d || this.setSuspendDrawing(!0);\n\n      try {\n        a();\n      } catch (e) {\n        b.log(\"Function run while suspended failed\", e);\n      }\n\n      d || this.setSuspendDrawing(!1, !c);\n    }, this.doWhileSuspended = this.batch, this.getCachedData = S, this.timestamp = c, this.show = function (a, b) {\n      return Q(a, \"block\", b), f;\n    }, this.toggleVisible = R, this.addListener = this.bind;\n    var ya = [];\n    this.registerFloatingConnection = function (a, c, d) {\n      ya[a.id] = c, b.addToList(u, a.id, d);\n    }, this.getFloatingConnectionFor = function (a) {\n      return ya[a];\n    }, this.listManager = new a.jsPlumbListManager(this);\n  };\n\n  b.extend(a.jsPlumbInstance, b.EventGenerator, {\n    setAttribute: function setAttribute(a, b, c) {\n      this.setAttribute(a, b, c);\n    },\n    getAttribute: function getAttribute(b, c) {\n      return this.getAttribute(a.jsPlumb.getElement(b), c);\n    },\n    convertToFullOverlaySpec: function convertToFullOverlaySpec(a) {\n      return b.isString(a) && (a = [a, {}]), a[1].id = a[1].id || b.uuid(), a;\n    },\n    registerConnectionType: function registerConnectionType(b, c) {\n      if (this._connectionTypes[b] = a.jsPlumb.extend({}, c), c.overlays) {\n        for (var d = {}, e = 0; e < c.overlays.length; e++) {\n          var f = this.convertToFullOverlaySpec(c.overlays[e]);\n          d[f[1].id] = f;\n        }\n\n        this._connectionTypes[b].overlays = d;\n      }\n    },\n    registerConnectionTypes: function registerConnectionTypes(a) {\n      for (var b in a) {\n        this.registerConnectionType(b, a[b]);\n      }\n    },\n    registerEndpointType: function registerEndpointType(b, c) {\n      if (this._endpointTypes[b] = a.jsPlumb.extend({}, c), c.overlays) {\n        for (var d = {}, e = 0; e < c.overlays.length; e++) {\n          var f = this.convertToFullOverlaySpec(c.overlays[e]);\n          d[f[1].id] = f;\n        }\n\n        this._endpointTypes[b].overlays = d;\n      }\n    },\n    registerEndpointTypes: function registerEndpointTypes(a) {\n      for (var b in a) {\n        this.registerEndpointType(b, a[b]);\n      }\n    },\n    getType: function getType(a, b) {\n      return \"connection\" === b ? this._connectionTypes[a] : this._endpointTypes[a];\n    },\n    setIdChanged: function setIdChanged(a, b) {\n      this.setId(a, b, !0);\n    },\n    setParent: function setParent(a, b) {\n      var c = this.getElement(a),\n          d = this.getId(c),\n          e = this.getElement(b),\n          f = this.getId(e),\n          g = this.getDragManager();\n      c.parentNode.removeChild(c), e.appendChild(c), g && g.setParent(c, d, e, f);\n    },\n    extend: function extend(a, b, c) {\n      var d;\n      if (c) for (d = 0; d < c.length; d++) {\n        a[c[d]] = b[c[d]];\n      } else for (d in b) {\n        a[d] = b[d];\n      }\n      return a;\n    },\n    floatingConnections: {},\n    getFloatingAnchorIndex: function getFloatingAnchorIndex(a) {\n      return a.endpoints[0].isFloating() ? 0 : a.endpoints[1].isFloating() ? 1 : -1;\n    },\n    proxyConnection: function proxyConnection(a, b, c, d, e, f) {\n      var g,\n          h = a.endpoints[b].elementId,\n          i = a.endpoints[b];\n      a.proxies = a.proxies || [], g = a.proxies[b] ? a.proxies[b].ep : this.addEndpoint(c, {\n        endpoint: e(a, b),\n        anchor: f(a, b),\n        parameters: {\n          isProxyEndpoint: !0\n        }\n      }), g.setDeleteOnEmpty(!0), a.proxies[b] = {\n        ep: g,\n        originalEp: i\n      }, 0 === b ? this.anchorManager.sourceChanged(h, d, a, c) : (this.anchorManager.updateOtherEndpoint(a.endpoints[0].elementId, h, d, a), a.target = c, a.targetId = d), i.detachFromConnection(a, null, !0), g.connections = [a], a.endpoints[b] = g, i.setVisible(!1), a.setVisible(!0), this.revalidate(c);\n    },\n    unproxyConnection: function unproxyConnection(a, b, c) {\n      if (null != a._jsPlumb && null != a.proxies && null != a.proxies[b]) {\n        var d = a.proxies[b].originalEp.element,\n            e = a.proxies[b].originalEp.elementId;\n        a.endpoints[b] = a.proxies[b].originalEp, 0 === b ? this.anchorManager.sourceChanged(c, e, a, d) : (this.anchorManager.updateOtherEndpoint(a.endpoints[0].elementId, c, e, a), a.target = d, a.targetId = e), a.proxies[b].ep.detachFromConnection(a, null), a.proxies[b].originalEp.addConnection(a), a.isVisible() && a.proxies[b].originalEp.setVisible(!0), delete a.proxies[b];\n      }\n    }\n  });\n  var o = new n();\n  a.jsPlumb = o, o.getInstance = function (a, b) {\n    var c = new n(a);\n    if (b) for (var d in b) {\n      c[d] = b[d];\n    }\n    return c.init(), c;\n  }, o.each = function (a, b) {\n    if (null != a) if (\"string\" == typeof a) b(o.getElement(a));else if (null != a.length) for (var c = 0; c < a.length; c++) {\n      b(o.getElement(a[c]));\n    } else b(a);\n  }, \"undefined\" != typeof exports && (exports.jsPlumb = o);\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this,\n      b = a.jsPlumb,\n      c = a.jsPlumbUtil,\n      d = \"__label\",\n      e = function e(a, c) {\n    var e = {\n      cssClass: c.cssClass,\n      labelStyle: a.labelStyle,\n      id: d,\n      component: a,\n      _jsPlumb: a._jsPlumb.instance\n    },\n        f = b.extend(e, c);\n    return new b.Overlays[a._jsPlumb.instance.getRenderMode()].Label(f);\n  },\n      f = function f(a, d) {\n    var e = null;\n\n    if (c.isArray(d)) {\n      var f = d[0],\n          g = b.extend({\n        component: a,\n        _jsPlumb: a._jsPlumb.instance\n      }, d[1]);\n      3 === d.length && b.extend(g, d[2]), e = new b.Overlays[a._jsPlumb.instance.getRenderMode()][f](g);\n    } else e = d.constructor === String ? new b.Overlays[a._jsPlumb.instance.getRenderMode()][d]({\n      component: a,\n      _jsPlumb: a._jsPlumb.instance\n    }) : d;\n\n    return e.id = e.id || c.uuid(), a.cacheTypeItem(\"overlay\", e, e.id), a._jsPlumb.overlays[e.id] = e, e;\n  };\n\n  b.OverlayCapableJsPlumbUIComponent = function (b) {\n    a.jsPlumbUIComponent.apply(this, arguments), this._jsPlumb.overlays = {}, this._jsPlumb.overlayPositions = {}, b.label && (this.getDefaultType().overlays[d] = [\"Label\", {\n      label: b.label,\n      location: b.labelLocation || this.defaultLabelLocation || .5,\n      labelStyle: b.labelStyle || this._jsPlumb.instance.Defaults.LabelStyle,\n      id: d\n    }]), this.setListenerComponent = function (a) {\n      if (this._jsPlumb) for (var b in this._jsPlumb.overlays) {\n        this._jsPlumb.overlays[b].setListenerComponent(a);\n      }\n    };\n  }, b.OverlayCapableJsPlumbUIComponent.applyType = function (a, b) {\n    if (b.overlays) {\n      var c,\n          d = {};\n\n      for (c in b.overlays) {\n        var e = a._jsPlumb.overlays[b.overlays[c][1].id];\n        if (e) e.updateFrom(b.overlays[c][1]), d[b.overlays[c][1].id] = !0;else {\n          var f = a.getCachedTypeItem(\"overlay\", b.overlays[c][1].id);\n          null != f ? (f.reattach(a._jsPlumb.instance, a), f.setVisible(!0), f.updateFrom(b.overlays[c][1]), a._jsPlumb.overlays[f.id] = f) : f = a.addOverlay(b.overlays[c], !0), d[f.id] = !0;\n        }\n      }\n\n      for (c in a._jsPlumb.overlays) {\n        null == d[a._jsPlumb.overlays[c].id] && a.removeOverlay(a._jsPlumb.overlays[c].id, !0);\n      }\n    }\n  }, c.extend(b.OverlayCapableJsPlumbUIComponent, a.jsPlumbUIComponent, {\n    setHover: function setHover(a, b) {\n      if (this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged()) for (var c in this._jsPlumb.overlays) {\n        this._jsPlumb.overlays[c][a ? \"addClass\" : \"removeClass\"](this._jsPlumb.instance.hoverClass);\n      }\n    },\n    addOverlay: function addOverlay(a, b) {\n      var d = f(this, a);\n\n      if (this.getData && \"Label\" === d.type && c.isArray(a)) {\n        var e = this.getData(),\n            g = a[1];\n\n        if (e) {\n          var h = g.labelLocationAttribute || \"labelLocation\",\n              i = e ? e[h] : null;\n          i && (d.loc = i);\n        }\n      }\n\n      return b || this.repaint(), d;\n    },\n    getOverlay: function getOverlay(a) {\n      return this._jsPlumb.overlays[a];\n    },\n    getOverlays: function getOverlays() {\n      return this._jsPlumb.overlays;\n    },\n    hideOverlay: function hideOverlay(a) {\n      var b = this.getOverlay(a);\n      b && b.hide();\n    },\n    hideOverlays: function hideOverlays() {\n      for (var a in this._jsPlumb.overlays) {\n        this._jsPlumb.overlays[a].hide();\n      }\n    },\n    showOverlay: function showOverlay(a) {\n      var b = this.getOverlay(a);\n      b && b.show();\n    },\n    showOverlays: function showOverlays() {\n      for (var a in this._jsPlumb.overlays) {\n        this._jsPlumb.overlays[a].show();\n      }\n    },\n    removeAllOverlays: function removeAllOverlays(a) {\n      for (var b in this._jsPlumb.overlays) {\n        this._jsPlumb.overlays[b].cleanup && this._jsPlumb.overlays[b].cleanup();\n      }\n\n      this._jsPlumb.overlays = {}, this._jsPlumb.overlayPositions = null, this._jsPlumb.overlayPlacements = {}, a || this.repaint();\n    },\n    removeOverlay: function removeOverlay(a, b) {\n      var c = this._jsPlumb.overlays[a];\n      c && (c.setVisible(!1), !b && c.cleanup && c.cleanup(), delete this._jsPlumb.overlays[a], this._jsPlumb.overlayPositions && delete this._jsPlumb.overlayPositions[a], this._jsPlumb.overlayPlacements && delete this._jsPlumb.overlayPlacements[a]);\n    },\n    removeOverlays: function removeOverlays() {\n      for (var a = 0, b = arguments.length; b > a; a++) {\n        this.removeOverlay(arguments[a]);\n      }\n    },\n    moveParent: function moveParent(a) {\n      if (this.bgCanvas && (this.bgCanvas.parentNode.removeChild(this.bgCanvas), a.appendChild(this.bgCanvas)), this.canvas && this.canvas.parentNode) {\n        this.canvas.parentNode.removeChild(this.canvas), a.appendChild(this.canvas);\n\n        for (var b in this._jsPlumb.overlays) {\n          if (this._jsPlumb.overlays[b].isAppendedAtTopLevel) {\n            var c = this._jsPlumb.overlays[b].getElement();\n\n            c.parentNode.removeChild(c), a.appendChild(c);\n          }\n        }\n      }\n    },\n    getLabel: function getLabel() {\n      var a = this.getOverlay(d);\n      return null != a ? a.getLabel() : null;\n    },\n    getLabelOverlay: function getLabelOverlay() {\n      return this.getOverlay(d);\n    },\n    setLabel: function setLabel(a) {\n      var b = this.getOverlay(d);\n      if (b) a.constructor === String || a.constructor === Function ? b.setLabel(a) : (a.label && b.setLabel(a.label), a.location && b.setLocation(a.location));else {\n        var c = a.constructor === String || a.constructor === Function ? {\n          label: a\n        } : a;\n        b = e(this, c), this._jsPlumb.overlays[d] = b;\n      }\n      this._jsPlumb.instance.isSuspendDrawing() || this.repaint();\n    },\n    cleanup: function cleanup(a) {\n      for (var b in this._jsPlumb.overlays) {\n        this._jsPlumb.overlays[b].cleanup(a), this._jsPlumb.overlays[b].destroy(a);\n      }\n\n      a && (this._jsPlumb.overlays = {}, this._jsPlumb.overlayPositions = null);\n    },\n    setVisible: function setVisible(a) {\n      this[a ? \"showOverlays\" : \"hideOverlays\"]();\n    },\n    setAbsoluteOverlayPosition: function setAbsoluteOverlayPosition(a, b) {\n      this._jsPlumb.overlayPositions[a.id] = b;\n    },\n    getAbsoluteOverlayPosition: function getAbsoluteOverlayPosition(a) {\n      return this._jsPlumb.overlayPositions ? this._jsPlumb.overlayPositions[a.id] : null;\n    },\n    _clazzManip: function _clazzManip(a, b, c) {\n      if (!c) for (var d in this._jsPlumb.overlays) {\n        this._jsPlumb.overlays[d][a + \"Class\"](b);\n      }\n    },\n    addClass: function addClass(a, b) {\n      this._clazzManip(\"add\", a, b);\n    },\n    removeClass: function removeClass(a, b) {\n      this._clazzManip(\"remove\", a, b);\n    }\n  });\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this,\n      b = a.jsPlumb,\n      c = a.jsPlumbUtil,\n      d = function d(a, b, c) {\n    var d = !1;\n    return {\n      drag: function drag() {\n        if (d) return d = !1, !0;\n\n        if (b.element) {\n          var e = c.getUIPosition(arguments, c.getZoom());\n          null != e && c.setPosition(b.element, e), c.repaint(b.element, e), a.paint({\n            anchorPoint: a.anchor.getCurrentLocation({\n              element: a\n            })\n          });\n        }\n      },\n      stopDrag: function stopDrag() {\n        d = !0;\n      }\n    };\n  },\n      e = function e(a, b, c, d) {\n    var e = b.createElement(\"div\", {\n      position: \"absolute\"\n    });\n    b.appendElement(e);\n    var f = b.getId(e);\n    b.setPosition(e, c), e.style.width = d[0] + \"px\", e.style.height = d[1] + \"px\", b.manage(f, e, !0), a.id = f, a.element = e;\n  },\n      f = function f(a, c, d, e, _f, g, h, i) {\n    var j = new b.FloatingAnchor({\n      reference: c,\n      referenceCanvas: e,\n      jsPlumbInstance: g\n    });\n    return h({\n      paintStyle: a,\n      endpoint: d,\n      anchor: j,\n      source: _f,\n      scope: i\n    });\n  },\n      g = [\"connectorStyle\", \"connectorHoverStyle\", \"connectorOverlays\", \"connector\", \"connectionType\", \"connectorClass\", \"connectorHoverClass\"],\n      h = function h(a, b) {\n    var c = 0;\n    if (null != b) for (var d = 0; d < a.connections.length; d++) {\n      if (a.connections[d].sourceId === b || a.connections[d].targetId === b) {\n        c = d;\n        break;\n      }\n    }\n    return a.connections[c];\n  };\n\n  b.Endpoint = function (a) {\n    var i = a._jsPlumb,\n        j = a.newConnection,\n        k = a.newEndpoint;\n    this.idPrefix = \"_jsplumb_e_\", this.defaultLabelLocation = [.5, .5], this.defaultOverlayKeys = [\"Overlays\", \"EndpointOverlays\"], b.OverlayCapableJsPlumbUIComponent.apply(this, arguments), this.appendToDefaultType({\n      connectionType: a.connectionType,\n      maxConnections: null == a.maxConnections ? this._jsPlumb.instance.Defaults.MaxConnections : a.maxConnections,\n      paintStyle: a.endpointStyle || a.paintStyle || a.style || this._jsPlumb.instance.Defaults.EndpointStyle || b.Defaults.EndpointStyle,\n      hoverPaintStyle: a.endpointHoverStyle || a.hoverPaintStyle || this._jsPlumb.instance.Defaults.EndpointHoverStyle || b.Defaults.EndpointHoverStyle,\n      connectorStyle: a.connectorStyle,\n      connectorHoverStyle: a.connectorHoverStyle,\n      connectorClass: a.connectorClass,\n      connectorHoverClass: a.connectorHoverClass,\n      connectorOverlays: a.connectorOverlays,\n      connector: a.connector,\n      connectorTooltip: a.connectorTooltip\n    }), this._jsPlumb.enabled = !(a.enabled === !1), this._jsPlumb.visible = !0, this.element = b.getElement(a.source), this._jsPlumb.uuid = a.uuid, this._jsPlumb.floatingEndpoint = null;\n    var l = null;\n    this._jsPlumb.uuid && (a.endpointsByUUID[this._jsPlumb.uuid] = this), this.elementId = a.elementId, this.dragProxy = a.dragProxy, this._jsPlumb.connectionCost = a.connectionCost, this._jsPlumb.connectionsDirected = a.connectionsDirected, this._jsPlumb.currentAnchorClass = \"\", this._jsPlumb.events = {};\n    var m = a.deleteOnEmpty === !0;\n\n    this.setDeleteOnEmpty = function (a) {\n      m = a;\n    };\n\n    var n = function () {\n      var a = i.endpointAnchorClassPrefix + \"-\" + this._jsPlumb.currentAnchorClass;\n      this._jsPlumb.currentAnchorClass = this.anchor.getCssClass();\n      var c = i.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? \"-\" + this._jsPlumb.currentAnchorClass : \"\");\n      this.removeClass(a), this.addClass(c), b.updateClasses(this.element, c, a);\n    }.bind(this);\n\n    this.prepareAnchor = function (a) {\n      var b = this._jsPlumb.instance.makeAnchor(a, this.elementId, i);\n\n      return b.bind(\"anchorChanged\", function (a) {\n        this.fire(\"anchorChanged\", {\n          endpoint: this,\n          anchor: a\n        }), n();\n      }.bind(this)), b;\n    }, this.setPreparedAnchor = function (a, b) {\n      return this._jsPlumb.instance.continuousAnchorFactory.clear(this.elementId), this.anchor = a, n(), b || this._jsPlumb.instance.repaint(this.elementId), this;\n    }, this.setAnchor = function (a, b) {\n      var c = this.prepareAnchor(a);\n      return this.setPreparedAnchor(c, b), this;\n    };\n\n    var o = function (a) {\n      if (this.connections.length > 0) for (var b = 0; b < this.connections.length; b++) {\n        this.connections[b].setHover(a, !1);\n      } else this.setHover(a);\n    }.bind(this);\n\n    this.bind(\"mouseover\", function () {\n      o(!0);\n    }), this.bind(\"mouseout\", function () {\n      o(!1);\n    }), a._transient || this._jsPlumb.instance.anchorManager.add(this, this.elementId), this.prepareEndpoint = function (d, e) {\n      var f,\n          g = function g(a, c) {\n        var d = i.getRenderMode();\n        if (b.Endpoints[d][a]) return new b.Endpoints[d][a](c);\n        if (!i.Defaults.DoNotThrowErrors) throw {\n          msg: \"jsPlumb: unknown endpoint type '\" + a + \"'\"\n        };\n      },\n          h = {\n        _jsPlumb: this._jsPlumb.instance,\n        cssClass: a.cssClass,\n        container: a.container,\n        tooltip: a.tooltip,\n        connectorTooltip: a.connectorTooltip,\n        endpoint: this\n      };\n\n      return c.isString(d) ? f = g(d, h) : c.isArray(d) ? (h = c.merge(d[1], h), f = g(d[0], h)) : f = d.clone(), f.clone = function () {\n        return c.isString(d) ? g(d, h) : c.isArray(d) ? (h = c.merge(d[1], h), g(d[0], h)) : void 0;\n      }.bind(this), f.typeId = e, f;\n    }, this.setEndpoint = function (a, b) {\n      var c = this.prepareEndpoint(a);\n      this.setPreparedEndpoint(c, !0);\n    }, this.setPreparedEndpoint = function (a, b) {\n      null != this.endpoint && (this.endpoint.cleanup(), this.endpoint.destroy()), this.endpoint = a, this.type = this.endpoint.type, this.canvas = this.endpoint.canvas;\n    }, b.extend(this, a, g), this.isSource = a.isSource || !1, this.isTemporarySource = a.isTemporarySource || !1, this.isTarget = a.isTarget || !1, this.connections = a.connections || [], this.connectorPointerEvents = a[\"connector-pointer-events\"], this.scope = a.scope || i.getDefaultScope(), this.timestamp = null, this.reattachConnections = a.reattach || i.Defaults.ReattachConnections, this.connectionsDetachable = i.Defaults.ConnectionsDetachable, (a.connectionsDetachable === !1 || a.detachable === !1) && (this.connectionsDetachable = !1), this.dragAllowedWhenFull = a.dragAllowedWhenFull !== !1, a.onMaxConnections && this.bind(\"maxConnections\", a.onMaxConnections), this.addConnection = function (a) {\n      this.connections.push(a), this[(this.connections.length > 0 ? \"add\" : \"remove\") + \"Class\"](i.endpointConnectedClass), this[(this.isFull() ? \"add\" : \"remove\") + \"Class\"](i.endpointFullClass);\n    }, this.detachFromConnection = function (a, b, c) {\n      b = null == b ? this.connections.indexOf(a) : b, b >= 0 && (this.connections.splice(b, 1), this[(this.connections.length > 0 ? \"add\" : \"remove\") + \"Class\"](i.endpointConnectedClass), this[(this.isFull() ? \"add\" : \"remove\") + \"Class\"](i.endpointFullClass)), !c && m && 0 === this.connections.length && i.deleteObject({\n        endpoint: this,\n        fireEvent: !1,\n        deleteAttachedObjects: c !== !0\n      });\n    }, this.deleteEveryConnection = function (a) {\n      for (var b = this.connections.length, c = 0; b > c; c++) {\n        i.deleteConnection(this.connections[0], a);\n      }\n    }, this.detachFrom = function (a, b, c) {\n      for (var d = [], e = 0; e < this.connections.length; e++) {\n        (this.connections[e].endpoints[1] === a || this.connections[e].endpoints[0] === a) && d.push(this.connections[e]);\n      }\n\n      for (var f = 0, g = d.length; g > f; f++) {\n        i.deleteConnection(d[0]);\n      }\n\n      return this;\n    }, this.getElement = function () {\n      return this.element;\n    }, this.setElement = function (d) {\n      var e = this._jsPlumb.instance.getId(d),\n          f = this.elementId;\n\n      return c.removeWithFunction(a.endpointsByElement[this.elementId], function (a) {\n        return a.id === this.id;\n      }.bind(this)), this.element = b.getElement(d), this.elementId = i.getId(this.element), i.anchorManager.rehomeEndpoint(this, f, this.element), i.dragManager.endpointAdded(this.element), c.addToList(a.endpointsByElement, e, this), this;\n    }, this.makeInPlaceCopy = function () {\n      var b = this.anchor.getCurrentLocation({\n        element: this\n      }),\n          c = this.anchor.getOrientation(this),\n          d = this.anchor.getCssClass(),\n          e = {\n        bind: function bind() {},\n        compute: function compute() {\n          return [b[0], b[1]];\n        },\n        getCurrentLocation: function getCurrentLocation() {\n          return [b[0], b[1]];\n        },\n        getOrientation: function getOrientation() {\n          return c;\n        },\n        getCssClass: function getCssClass() {\n          return d;\n        }\n      };\n      return k({\n        dropOptions: a.dropOptions,\n        anchor: e,\n        source: this.element,\n        paintStyle: this.getPaintStyle(),\n        endpoint: a.hideOnDrag ? \"Blank\" : this.endpoint,\n        _transient: !0,\n        scope: this.scope,\n        reference: this\n      });\n    }, this.connectorSelector = function () {\n      return this.connections[0];\n    }, this.setStyle = this.setPaintStyle, this.paint = function (a) {\n      a = a || {};\n      var b = a.timestamp,\n          c = !(a.recalc === !1);\n\n      if (!b || this.timestamp !== b) {\n        var d = i.updateOffset({\n          elId: this.elementId,\n          timestamp: b\n        }),\n            e = a.offset ? a.offset.o : d.o;\n\n        if (null != e) {\n          var f = a.anchorPoint,\n              g = a.connectorPaintStyle;\n\n          if (null == f) {\n            var j = a.dimensions || d.s,\n                k = {\n              xy: [e.left, e.top],\n              wh: j,\n              element: this,\n              timestamp: b\n            };\n\n            if (c && this.anchor.isDynamic && this.connections.length > 0) {\n              var l = h(this, a.elementWithPrecedence),\n                  m = l.endpoints[0] === this ? 1 : 0,\n                  n = 0 === m ? l.sourceId : l.targetId,\n                  o = i.getCachedData(n),\n                  p = o.o,\n                  q = o.s;\n              k.index = 0 === m ? 1 : 0, k.connection = l, k.txy = [p.left, p.top], k.twh = q, k.tElement = l.endpoints[m];\n            } else this.connections.length > 0 && (k.connection = this.connections[0]);\n\n            f = this.anchor.compute(k);\n          }\n\n          this.endpoint.compute(f, this.anchor.getOrientation(this), this._jsPlumb.paintStyleInUse, g || this.paintStyleInUse), this.endpoint.paint(this._jsPlumb.paintStyleInUse, this.anchor), this.timestamp = b;\n\n          for (var r in this._jsPlumb.overlays) {\n            if (this._jsPlumb.overlays.hasOwnProperty(r)) {\n              var s = this._jsPlumb.overlays[r];\n              s.isVisible() && (this._jsPlumb.overlayPlacements[r] = s.draw(this.endpoint, this._jsPlumb.paintStyleInUse), s.paint(this._jsPlumb.overlayPlacements[r]));\n            }\n          }\n        }\n      }\n    }, this.getTypeDescriptor = function () {\n      return \"endpoint\";\n    }, this.isVisible = function () {\n      return this._jsPlumb.visible;\n    }, this.repaint = this.paint;\n    var p = !1;\n\n    this.initDraggable = function () {\n      if (!p && b.isDragSupported(this.element)) {\n        var g,\n            h = {\n          id: null,\n          element: null\n        },\n            m = null,\n            n = !1,\n            o = null,\n            q = d(this, h, i),\n            r = a.dragOptions || {},\n            s = {},\n            t = b.dragEvents.start,\n            u = b.dragEvents.stop,\n            v = b.dragEvents.drag,\n            w = b.dragEvents.beforeStart,\n            x = function x(a) {\n          g = a.e.payload || {};\n        },\n            y = function (c) {\n          m = this.connectorSelector();\n          var d = !0;\n          this.isEnabled() || (d = !1), null != m || this.isSource || this.isTemporarySource || (d = !1), !this.isSource || !this.isFull() || null != m && this.dragAllowedWhenFull || (d = !1), null == m || m.isDetachable(this) || (this.isFull() ? d = !1 : m = null);\n          var l = i.checkCondition(null == m ? \"beforeDrag\" : \"beforeStartDetach\", {\n            endpoint: this,\n            source: this.element,\n            sourceId: this.elementId,\n            connection: m\n          });\n          if (l === !1 ? d = !1 : \"object\" == typeof l ? b.extend(l, g || {}) : l = g || {}, d === !1) return i.stopDrag && i.stopDrag(this.canvas), q.stopDrag(), !1;\n\n          for (var p = 0; p < this.connections.length; p++) {\n            this.connections[p].setHover(!1);\n          }\n\n          this.addClass(\"endpointDrag\"), i.setConnectionBeingDragged(!0), m && !this.isFull() && this.isSource && (m = null), i.updateOffset({\n            elId: this.elementId\n          });\n\n          var r = this._jsPlumb.instance.getOffset(this.canvas),\n              s = this.canvas,\n              t = this._jsPlumb.instance.getSize(this.canvas);\n\n          e(h, i, r, t), i.setAttributes(this.canvas, {\n            dragId: h.id,\n            elId: this.elementId\n          });\n          var u = this.dragProxy || this.endpoint;\n\n          if (null == this.dragProxy && null != this.connectionType) {\n            var v = this._jsPlumb.instance.deriveEndpointAndAnchorSpec(this.connectionType);\n\n            v.endpoints[1] && (u = v.endpoints[1]);\n          }\n\n          var w = this._jsPlumb.instance.makeAnchor(\"Center\");\n\n          w.isFloating = !0, this._jsPlumb.floatingEndpoint = f(this.getPaintStyle(), w, u, this.canvas, h.element, i, k, this.scope);\n          var x = this._jsPlumb.floatingEndpoint.anchor;\n          if (null == m) this.setHover(!1, !1), m = j({\n            sourceEndpoint: this,\n            targetEndpoint: this._jsPlumb.floatingEndpoint,\n            source: this.element,\n            target: h.element,\n            anchors: [this.anchor, this._jsPlumb.floatingEndpoint.anchor],\n            paintStyle: a.connectorStyle,\n            hoverPaintStyle: a.connectorHoverStyle,\n            connector: a.connector,\n            overlays: a.connectorOverlays,\n            type: this.connectionType,\n            cssClass: this.connectorClass,\n            hoverClass: this.connectorHoverClass,\n            scope: a.scope,\n            data: l\n          }), m.pending = !0, m.addClass(i.draggingClass), this._jsPlumb.floatingEndpoint.addClass(i.draggingClass), this._jsPlumb.floatingEndpoint.anchor = x, i.fire(\"connectionDrag\", m), i.anchorManager.newConnection(m);else {\n            n = !0, m.setHover(!1);\n            var y = m.endpoints[0].id === this.id ? 0 : 1;\n            this.detachFromConnection(m, null, !0);\n            var z = i.getDragScope(s);\n            i.setAttribute(this.canvas, \"originalScope\", z), i.fire(\"connectionDrag\", m), 0 === y ? (o = [m.source, m.sourceId, s, z], i.anchorManager.sourceChanged(m.endpoints[y].elementId, h.id, m, h.element)) : (o = [m.target, m.targetId, s, z], m.target = h.element, m.targetId = h.id, i.anchorManager.updateOtherEndpoint(m.sourceId, m.endpoints[y].elementId, m.targetId, m)), m.suspendedEndpoint = m.endpoints[y], m.suspendedElement = m.endpoints[y].getElement(), m.suspendedElementId = m.endpoints[y].elementId, m.suspendedElementType = 0 === y ? \"source\" : \"target\", m.suspendedEndpoint.setHover(!1), this._jsPlumb.floatingEndpoint.referenceEndpoint = m.suspendedEndpoint, m.endpoints[y] = this._jsPlumb.floatingEndpoint, m.addClass(i.draggingClass), this._jsPlumb.floatingEndpoint.addClass(i.draggingClass);\n          }\n          i.registerFloatingConnection(h, m, this._jsPlumb.floatingEndpoint), i.currentlyDragging = !0;\n        }.bind(this),\n            z = function () {\n          if (i.setConnectionBeingDragged(!1), m && null != m.endpoints) {\n            var a = i.getDropEvent(arguments),\n                b = i.getFloatingAnchorIndex(m);\n\n            if (m.endpoints[0 === b ? 1 : 0].anchor.unlock(), m.removeClass(i.draggingClass), this._jsPlumb && (m.deleteConnectionNow || m.endpoints[b] === this._jsPlumb.floatingEndpoint) && n && m.suspendedEndpoint) {\n              0 === b ? (m.floatingElement = m.source, m.floatingId = m.sourceId, m.floatingEndpoint = m.endpoints[0], m.floatingIndex = 0, m.source = o[0], m.sourceId = o[1]) : (m.floatingElement = m.target, m.floatingId = m.targetId, m.floatingEndpoint = m.endpoints[1], m.floatingIndex = 1, m.target = o[0], m.targetId = o[1]);\n              var c = this._jsPlumb.floatingEndpoint;\n              i.setDragScope(o[2], o[3]), m.endpoints[b] = m.suspendedEndpoint, m.isReattach() || m._forceReattach || m._forceDetach || !i.deleteConnection(m, {\n                originalEvent: a\n              }) ? (m.setHover(!1), m._forceDetach = null, m._forceReattach = null, this._jsPlumb.floatingEndpoint.detachFromConnection(m), m.suspendedEndpoint.addConnection(m), 1 === b ? i.anchorManager.updateOtherEndpoint(m.sourceId, m.floatingId, m.targetId, m) : i.anchorManager.sourceChanged(m.floatingId, m.sourceId, m, m.source), i.repaint(o[1])) : i.deleteObject({\n                endpoint: c\n              });\n            }\n\n            this.deleteAfterDragStop ? i.deleteObject({\n              endpoint: this\n            }) : this._jsPlumb && this.paint({\n              recalc: !1\n            }), i.fire(\"connectionDragStop\", m, a), m.pending && i.fire(\"connectionAborted\", m, a), i.currentlyDragging = !1, m.suspendedElement = null, m.suspendedEndpoint = null, m = null;\n          }\n\n          h && h.element && i.remove(h.element, !1, !1), l && i.deleteObject({\n            endpoint: l\n          }), this._jsPlumb && (this.canvas.style.visibility = \"visible\", this.anchor.unlock(), this._jsPlumb.floatingEndpoint = null);\n        }.bind(this);\n\n        r = b.extend(s, r), r.scope = this.scope || r.scope, r[w] = c.wrap(r[w], x, !1), r[t] = c.wrap(r[t], y, !1), r[v] = c.wrap(r[v], q.drag), r[u] = c.wrap(r[u], z), r.multipleDrop = !1, r.canDrag = function () {\n          return this.isSource || this.isTemporarySource || this.connections.length > 0 && this.connectionsDetachable !== !1;\n        }.bind(this), i.initDraggable(this.canvas, r, \"internal\"), this.canvas._jsPlumbRelatedElement = this.element, p = !0;\n      }\n    };\n\n    var q = a.endpoint || this._jsPlumb.instance.Defaults.Endpoint || b.Defaults.Endpoint;\n    this.setEndpoint(q, !0);\n    var r = a.anchor ? a.anchor : a.anchors ? a.anchors : i.Defaults.Anchor || \"Top\";\n    this.setAnchor(r, !0);\n    var s = [\"default\", a.type || \"\"].join(\" \");\n    this.addType(s, a.data, !0), this.canvas = this.endpoint.canvas, this.canvas._jsPlumb = this, this.initDraggable();\n\n    var t = function (d, e, f, g) {\n      if (b.isDropSupported(this.element)) {\n        var h = a.dropOptions || i.Defaults.DropOptions || b.Defaults.DropOptions;\n        h = b.extend({}, h), h.scope = h.scope || this.scope;\n        var j = b.dragEvents.drop,\n            k = b.dragEvents.over,\n            l = b.dragEvents.out,\n            m = this,\n            n = i.EndpointDropHandler({\n          getEndpoint: function getEndpoint() {\n            return m;\n          },\n          jsPlumb: i,\n          enabled: function enabled() {\n            return null != f ? f.isEnabled() : !0;\n          },\n          isFull: function isFull() {\n            return f.isFull();\n          },\n          element: this.element,\n          elementId: this.elementId,\n          isSource: this.isSource,\n          isTarget: this.isTarget,\n          addClass: function addClass(a) {\n            m.addClass(a);\n          },\n          removeClass: function removeClass(a) {\n            m.removeClass(a);\n          },\n          isDropAllowed: function isDropAllowed() {\n            return m.isDropAllowed.apply(m, arguments);\n          },\n          reference: g,\n          isRedrop: function isRedrop(a, b) {\n            return a.suspendedEndpoint && b.reference && a.suspendedEndpoint.id === b.reference.id;\n          }\n        });\n        h[j] = c.wrap(h[j], n, !0), h[k] = c.wrap(h[k], function () {\n          var a = b.getDragObject(arguments),\n              c = i.getAttribute(b.getElement(a), \"dragId\"),\n              d = i.getFloatingConnectionFor(c);\n\n          if (null != d) {\n            var e = i.getFloatingAnchorIndex(d),\n                f = this.isTarget && 0 !== e || d.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id === d.suspendedEndpoint.id;\n\n            if (f) {\n              var g = i.checkCondition(\"checkDropAllowed\", {\n                sourceEndpoint: d.endpoints[e],\n                targetEndpoint: this,\n                connection: d\n              });\n              this[(g ? \"add\" : \"remove\") + \"Class\"](i.endpointDropAllowedClass), this[(g ? \"remove\" : \"add\") + \"Class\"](i.endpointDropForbiddenClass), d.endpoints[e].anchor.over(this.anchor, this);\n            }\n          }\n        }.bind(this)), h[l] = c.wrap(h[l], function () {\n          var a = b.getDragObject(arguments),\n              c = null == a ? null : i.getAttribute(b.getElement(a), \"dragId\"),\n              d = c ? i.getFloatingConnectionFor(c) : null;\n\n          if (null != d) {\n            var e = i.getFloatingAnchorIndex(d),\n                f = this.isTarget && 0 !== e || d.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id === d.suspendedEndpoint.id;\n            f && (this.removeClass(i.endpointDropAllowedClass), this.removeClass(i.endpointDropForbiddenClass), d.endpoints[e].anchor.out());\n          }\n        }.bind(this)), i.initDroppable(d, h, \"internal\", e);\n      }\n    }.bind(this);\n\n    return this.anchor.isFloating || t(this.canvas, !(a._transient || this.anchor.isFloating), this, a.reference), this;\n  }, c.extend(b.Endpoint, b.OverlayCapableJsPlumbUIComponent, {\n    setVisible: function setVisible(a, b, c) {\n      if (this._jsPlumb.visible = a, this.canvas && (this.canvas.style.display = a ? \"block\" : \"none\"), this[a ? \"showOverlays\" : \"hideOverlays\"](), !b) for (var d = 0; d < this.connections.length; d++) {\n        if (this.connections[d].setVisible(a), !c) {\n          var e = this === this.connections[d].endpoints[0] ? 1 : 0;\n          1 === this.connections[d].endpoints[e].connections.length && this.connections[d].endpoints[e].setVisible(a, !0, !0);\n        }\n      }\n    },\n    getAttachedElements: function getAttachedElements() {\n      return this.connections;\n    },\n    applyType: function applyType(a, c) {\n      this.setPaintStyle(a.endpointStyle || a.paintStyle, c), this.setHoverPaintStyle(a.endpointHoverStyle || a.hoverPaintStyle, c), null != a.maxConnections && (this._jsPlumb.maxConnections = a.maxConnections), a.scope && (this.scope = a.scope), b.extend(this, a, g), null != a.cssClass && this.canvas && this._jsPlumb.instance.addClass(this.canvas, a.cssClass), b.OverlayCapableJsPlumbUIComponent.applyType(this, a);\n    },\n    isEnabled: function isEnabled() {\n      return this._jsPlumb.enabled;\n    },\n    setEnabled: function setEnabled(a) {\n      this._jsPlumb.enabled = a;\n    },\n    cleanup: function cleanup() {\n      var a = this._jsPlumb.instance.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? \"-\" + this._jsPlumb.currentAnchorClass : \"\");\n      b.removeClass(this.element, a), this.anchor = null, this.endpoint.cleanup(!0), this.endpoint.destroy(), this.endpoint = null, this._jsPlumb.instance.destroyDraggable(this.canvas, \"internal\"), this._jsPlumb.instance.destroyDroppable(this.canvas, \"internal\");\n    },\n    setHover: function setHover(a) {\n      this.endpoint && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged() && this.endpoint.setHover(a);\n    },\n    isFull: function isFull() {\n      return 0 === this._jsPlumb.maxConnections ? !0 : !(this.isFloating() || this._jsPlumb.maxConnections < 0 || this.connections.length < this._jsPlumb.maxConnections);\n    },\n    isFloating: function isFloating() {\n      return null != this.anchor && this.anchor.isFloating;\n    },\n    isConnectedTo: function isConnectedTo(a) {\n      var b = !1;\n      if (a) for (var c = 0; c < this.connections.length; c++) {\n        if (this.connections[c].endpoints[1] === a || this.connections[c].endpoints[0] === a) {\n          b = !0;\n          break;\n        }\n      }\n      return b;\n    },\n    getConnectionCost: function getConnectionCost() {\n      return this._jsPlumb.connectionCost;\n    },\n    setConnectionCost: function setConnectionCost(a) {\n      this._jsPlumb.connectionCost = a;\n    },\n    areConnectionsDirected: function areConnectionsDirected() {\n      return this._jsPlumb.connectionsDirected;\n    },\n    setConnectionsDirected: function setConnectionsDirected(a) {\n      this._jsPlumb.connectionsDirected = a;\n    },\n    setElementId: function setElementId(a) {\n      this.elementId = a, this.anchor.elementId = a;\n    },\n    setReferenceElement: function setReferenceElement(a) {\n      this.element = b.getElement(a);\n    },\n    setDragAllowedWhenFull: function setDragAllowedWhenFull(a) {\n      this.dragAllowedWhenFull = a;\n    },\n    equals: function equals(a) {\n      return this.anchor.equals(a.anchor);\n    },\n    getUuid: function getUuid() {\n      return this._jsPlumb.uuid;\n    },\n    computeAnchor: function computeAnchor(a) {\n      return this.anchor.compute(a);\n    }\n  }), a.jsPlumbInstance.prototype.EndpointDropHandler = function (a) {\n    return function (b) {\n      var d = a.jsPlumb;\n      a.removeClass(d.endpointDropAllowedClass), a.removeClass(d.endpointDropForbiddenClass);\n      var e = d.getDropEvent(arguments),\n          f = d.getDragObject(arguments),\n          g = d.getAttribute(f, \"dragId\"),\n          h = (d.getAttribute(f, \"elId\"), d.getAttribute(f, \"originalScope\")),\n          i = d.getFloatingConnectionFor(g);\n\n      if (null != i) {\n        var j = null != i.suspendedEndpoint;\n\n        if (!j || null != i.suspendedEndpoint._jsPlumb) {\n          var k = a.getEndpoint(i);\n\n          if (null != k) {\n            if (a.isRedrop(i, a)) return i._forceReattach = !0, i.setHover(!1), void (a.maybeCleanup && a.maybeCleanup(k));\n            var l = d.getFloatingAnchorIndex(i);\n            if (0 === l && !a.isSource || 1 === l && !a.isTarget) return void (a.maybeCleanup && a.maybeCleanup(k));\n            a.onDrop && a.onDrop(i), h && d.setDragScope(f, h);\n            var m = a.isFull(b);\n\n            if (m && k.fire(\"maxConnections\", {\n              endpoint: this,\n              connection: i,\n              maxConnections: k._jsPlumb.maxConnections\n            }, e), !m && a.enabled()) {\n              var n = !0;\n              0 === l ? (i.floatingElement = i.source, i.floatingId = i.sourceId, i.floatingEndpoint = i.endpoints[0], i.floatingIndex = 0, i.source = a.element, i.sourceId = a.elementId) : (i.floatingElement = i.target, i.floatingId = i.targetId, i.floatingEndpoint = i.endpoints[1], i.floatingIndex = 1, i.target = a.element, i.targetId = a.elementId), j && i.suspendedEndpoint.id !== k.id && (i.isDetachAllowed(i) && i.endpoints[l].isDetachAllowed(i) && i.suspendedEndpoint.isDetachAllowed(i) && d.checkCondition(\"beforeDetach\", i) || (n = !1));\n\n              var o = function (b) {\n                i.endpoints[l].detachFromConnection(i), i.suspendedEndpoint && i.suspendedEndpoint.detachFromConnection(i), i.endpoints[l] = k, k.addConnection(i);\n                var f = k.getParameters();\n\n                for (var g in f) {\n                  i.setParameter(g, f[g]);\n                }\n\n                if (j) {\n                  var h = i.suspendedEndpoint.elementId;\n                  d.fireMoveEvent({\n                    index: l,\n                    originalSourceId: 0 === l ? h : i.sourceId,\n                    newSourceId: 0 === l ? k.elementId : i.sourceId,\n                    originalTargetId: 1 === l ? h : i.targetId,\n                    newTargetId: 1 === l ? k.elementId : i.targetId,\n                    originalSourceEndpoint: 0 === l ? i.suspendedEndpoint : i.endpoints[0],\n                    newSourceEndpoint: 0 === l ? k : i.endpoints[0],\n                    originalTargetEndpoint: 1 === l ? i.suspendedEndpoint : i.endpoints[1],\n                    newTargetEndpoint: 1 === l ? k : i.endpoints[1],\n                    connection: i\n                  }, e);\n                } else f.draggable && d.initDraggable(this.element, a.dragOptions, \"internal\", d);\n\n                if (1 === l ? d.anchorManager.updateOtherEndpoint(i.sourceId, i.floatingId, i.targetId, i) : d.anchorManager.sourceChanged(i.floatingId, i.sourceId, i, i.source), i.endpoints[0].finalEndpoint) {\n                  var m = i.endpoints[0];\n                  m.detachFromConnection(i), i.endpoints[0] = i.endpoints[0].finalEndpoint, i.endpoints[0].addConnection(i);\n                }\n\n                c.isObject(b) && i.mergeData(b), d.finaliseConnection(i, null, e, !1), i.setHover(!1), d.revalidate(i.endpoints[0].element);\n              }.bind(this),\n                  p = function p() {\n                i.suspendedEndpoint && (i.endpoints[l] = i.suspendedEndpoint, i.setHover(!1), i._forceDetach = !0, 0 === l ? (i.source = i.suspendedEndpoint.element, i.sourceId = i.suspendedEndpoint.elementId) : (i.target = i.suspendedEndpoint.element, i.targetId = i.suspendedEndpoint.elementId), i.suspendedEndpoint.addConnection(i), 1 === l ? d.anchorManager.updateOtherEndpoint(i.sourceId, i.floatingId, i.targetId, i) : d.anchorManager.sourceChanged(i.floatingId, i.sourceId, i, i.source), d.repaint(i.sourceId), i._forceDetach = !1);\n              };\n\n              if (n = n && a.isDropAllowed(i.sourceId, i.targetId, i.scope, i, k)) return o(n), !0;\n              p();\n            }\n\n            a.maybeCleanup && a.maybeCleanup(k), d.currentlyDragging = !1;\n          }\n        }\n      }\n    };\n  };\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this,\n      b = a.jsPlumb,\n      c = a.jsPlumbUtil,\n      d = function d(a, _d4, e, f, g) {\n    if (b.Connectors[_d4] = b.Connectors[_d4] || {}, null == b.Connectors[_d4][e]) {\n      if (null == b.Connectors[e]) {\n        if (a.Defaults.DoNotThrowErrors) return null;\n        throw new TypeError(\"jsPlumb: unknown connector type '\" + e + \"'\");\n      }\n\n      b.Connectors[_d4][e] = function () {\n        b.Connectors[e].apply(this, arguments), b.ConnectorRenderers[_d4].apply(this, arguments);\n      }, c.extend(b.Connectors[_d4][e], [b.Connectors[e], b.ConnectorRenderers[_d4]]);\n    }\n\n    return new b.Connectors[_d4][e](f, g);\n  },\n      e = function e(a, b, c) {\n    return a ? c.makeAnchor(a, b, c) : null;\n  },\n      f = function f(a, b, d, e) {\n    null != b && (b._jsPlumbConnections = b._jsPlumbConnections || {}, e ? delete b._jsPlumbConnections[a.id] : b._jsPlumbConnections[a.id] = !0, c.isEmpty(b._jsPlumbConnections) ? d.removeClass(b, d.connectedClass) : d.addClass(b, d.connectedClass));\n  };\n\n  b.Connection = function (a) {\n    var d = a.newEndpoint;\n    this.id = a.id, this.connector = null, this.idPrefix = \"_jsplumb_c_\", this.defaultLabelLocation = .5, this.defaultOverlayKeys = [\"Overlays\", \"ConnectionOverlays\"], this.previousConnection = a.previousConnection, this.source = b.getElement(a.source), this.target = b.getElement(a.target), b.OverlayCapableJsPlumbUIComponent.apply(this, arguments), a.sourceEndpoint ? (this.source = a.sourceEndpoint.getElement(), this.sourceId = a.sourceEndpoint.elementId) : this.sourceId = this._jsPlumb.instance.getId(this.source), a.targetEndpoint ? (this.target = a.targetEndpoint.getElement(), this.targetId = a.targetEndpoint.elementId) : this.targetId = this._jsPlumb.instance.getId(this.target), this.scope = a.scope, this.endpoints = [], this.endpointStyles = [];\n    var e = this._jsPlumb.instance;\n    e.manage(this.sourceId, this.source), e.manage(this.targetId, this.target), this._jsPlumb.visible = !0, this._jsPlumb.params = {\n      cssClass: a.cssClass,\n      container: a.container,\n      \"pointer-events\": a[\"pointer-events\"],\n      editorParams: a.editorParams,\n      overlays: a.overlays\n    }, this._jsPlumb.lastPaintedAt = null, this.bind(\"mouseover\", function () {\n      this.setHover(!0);\n    }.bind(this)), this.bind(\"mouseout\", function () {\n      this.setHover(!1);\n    }.bind(this)), this.makeEndpoint = function (b, c, f, g, h) {\n      return f = f || this._jsPlumb.instance.getId(c), this.prepareEndpoint(e, d, this, g, b ? 0 : 1, a, c, f, h);\n    }, a.type && (a.endpoints = a.endpoints || this._jsPlumb.instance.deriveEndpointAndAnchorSpec(a.type).endpoints);\n    var f = this.makeEndpoint(!0, this.source, this.sourceId, a.sourceEndpoint),\n        g = this.makeEndpoint(!1, this.target, this.targetId, a.targetEndpoint);\n    f && c.addToList(a.endpointsByElement, this.sourceId, f), g && c.addToList(a.endpointsByElement, this.targetId, g), this.scope || (this.scope = this.endpoints[0].scope), null != a.deleteEndpointsOnEmpty && (this.endpoints[0].setDeleteOnEmpty(a.deleteEndpointsOnEmpty), this.endpoints[1].setDeleteOnEmpty(a.deleteEndpointsOnEmpty));\n    var h = e.Defaults.ConnectionsDetachable;\n    a.detachable === !1 && (h = !1), this.endpoints[0].connectionsDetachable === !1 && (h = !1), this.endpoints[1].connectionsDetachable === !1 && (h = !1);\n    var i = a.reattach || this.endpoints[0].reattachConnections || this.endpoints[1].reattachConnections || e.Defaults.ReattachConnections;\n    this.appendToDefaultType({\n      detachable: h,\n      reattach: i,\n      paintStyle: this.endpoints[0].connectorStyle || this.endpoints[1].connectorStyle || a.paintStyle || e.Defaults.PaintStyle || b.Defaults.PaintStyle,\n      hoverPaintStyle: this.endpoints[0].connectorHoverStyle || this.endpoints[1].connectorHoverStyle || a.hoverPaintStyle || e.Defaults.HoverPaintStyle || b.Defaults.HoverPaintStyle\n    });\n    var j = e.getSuspendedAt();\n\n    if (!e.isSuspendDrawing()) {\n      var k = e.getCachedData(this.sourceId),\n          l = k.o,\n          m = k.s,\n          n = e.getCachedData(this.targetId),\n          o = n.o,\n          p = n.s,\n          q = j || e.timestamp(),\n          r = this.endpoints[0].anchor.compute({\n        xy: [l.left, l.top],\n        wh: m,\n        element: this.endpoints[0],\n        elementId: this.endpoints[0].elementId,\n        txy: [o.left, o.top],\n        twh: p,\n        tElement: this.endpoints[1],\n        timestamp: q\n      });\n      this.endpoints[0].paint({\n        anchorLoc: r,\n        timestamp: q\n      }), r = this.endpoints[1].anchor.compute({\n        xy: [o.left, o.top],\n        wh: p,\n        element: this.endpoints[1],\n        elementId: this.endpoints[1].elementId,\n        txy: [l.left, l.top],\n        twh: m,\n        tElement: this.endpoints[0],\n        timestamp: q\n      }), this.endpoints[1].paint({\n        anchorLoc: r,\n        timestamp: q\n      });\n    }\n\n    this.getTypeDescriptor = function () {\n      return \"connection\";\n    }, this.getAttachedElements = function () {\n      return this.endpoints;\n    }, this.isDetachable = function (a) {\n      return this._jsPlumb.detachable === !1 ? !1 : null != a ? a.connectionsDetachable === !0 : this._jsPlumb.detachable === !0;\n    }, this.setDetachable = function (a) {\n      this._jsPlumb.detachable = a === !0;\n    }, this.isReattach = function () {\n      return this._jsPlumb.reattach === !0 || this.endpoints[0].reattachConnections === !0 || this.endpoints[1].reattachConnections === !0;\n    }, this.setReattach = function (a) {\n      this._jsPlumb.reattach = a === !0;\n    }, this._jsPlumb.cost = a.cost || this.endpoints[0].getConnectionCost(), this._jsPlumb.directed = a.directed, null == a.directed && (this._jsPlumb.directed = this.endpoints[0].areConnectionsDirected());\n    var s = b.extend({}, this.endpoints[1].getParameters());\n    b.extend(s, this.endpoints[0].getParameters()), b.extend(s, this.getParameters()), this.setParameters(s), this.setConnector(this.endpoints[0].connector || this.endpoints[1].connector || a.connector || e.Defaults.Connector || b.Defaults.Connector, !0);\n    var t = null != a.data && c.isObject(a.data) ? a.data : {};\n    this.getData = function () {\n      return t;\n    }, this.setData = function (a) {\n      t = a || {};\n    }, this.mergeData = function (a) {\n      t = b.extend(t, a);\n    };\n    var u = [\"default\", this.endpoints[0].connectionType, this.endpoints[1].connectionType, a.type].join(\" \");\n    /[^\\s]/.test(u) && this.addType(u, a.data, !0), this.updateConnectedClass();\n  }, c.extend(b.Connection, b.OverlayCapableJsPlumbUIComponent, {\n    applyType: function applyType(a, c, d) {\n      var e = null;\n      null != a.connector && (e = this.getCachedTypeItem(\"connector\", d.connector), null == e && (e = this.prepareConnector(a.connector, d.connector), this.cacheTypeItem(\"connector\", e, d.connector)), this.setPreparedConnector(e)), null != a.detachable && this.setDetachable(a.detachable), null != a.reattach && this.setReattach(a.reattach), a.scope && (this.scope = a.scope), null != a.cssClass && this.canvas && this._jsPlumb.instance.addClass(this.canvas, a.cssClass);\n      var f = null;\n      a.anchor ? (f = this.getCachedTypeItem(\"anchors\", d.anchor), null == f && (f = [this._jsPlumb.instance.makeAnchor(a.anchor), this._jsPlumb.instance.makeAnchor(a.anchor)], this.cacheTypeItem(\"anchors\", f, d.anchor))) : a.anchors && (f = this.getCachedTypeItem(\"anchors\", d.anchors), null == f && (f = [this._jsPlumb.instance.makeAnchor(a.anchors[0]), this._jsPlumb.instance.makeAnchor(a.anchors[1])], this.cacheTypeItem(\"anchors\", f, d.anchors))), null != f && (this.endpoints[0].anchor = f[0], this.endpoints[1].anchor = f[1], this.endpoints[1].anchor.isDynamic && this._jsPlumb.instance.repaint(this.endpoints[1].elementId)), b.OverlayCapableJsPlumbUIComponent.applyType(this, a);\n    },\n    addClass: function addClass(a, b) {\n      b && (this.endpoints[0].addClass(a), this.endpoints[1].addClass(a), this.suspendedEndpoint && this.suspendedEndpoint.addClass(a)), this.connector && this.connector.addClass(a);\n    },\n    removeClass: function removeClass(a, b) {\n      b && (this.endpoints[0].removeClass(a), this.endpoints[1].removeClass(a), this.suspendedEndpoint && this.suspendedEndpoint.removeClass(a)), this.connector && this.connector.removeClass(a);\n    },\n    isVisible: function isVisible() {\n      return this._jsPlumb.visible;\n    },\n    setVisible: function setVisible(a) {\n      this._jsPlumb.visible = a, this.connector && this.connector.setVisible(a), this.repaint();\n    },\n    cleanup: function cleanup() {\n      this.updateConnectedClass(!0), this.endpoints = null, this.source = null, this.target = null, null != this.connector && (this.connector.cleanup(!0), this.connector.destroy(!0)), this.connector = null;\n    },\n    updateConnectedClass: function updateConnectedClass(a) {\n      this._jsPlumb && (f(this, this.source, this._jsPlumb.instance, a), f(this, this.target, this._jsPlumb.instance, a));\n    },\n    setHover: function setHover(b) {\n      this.connector && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged() && (this.connector.setHover(b), a.jsPlumb[b ? \"addClass\" : \"removeClass\"](this.source, this._jsPlumb.instance.hoverSourceClass), a.jsPlumb[b ? \"addClass\" : \"removeClass\"](this.target, this._jsPlumb.instance.hoverTargetClass));\n    },\n    getUuids: function getUuids() {\n      return [this.endpoints[0].getUuid(), this.endpoints[1].getUuid()];\n    },\n    getCost: function getCost() {\n      return this._jsPlumb ? this._jsPlumb.cost : -(1 / 0);\n    },\n    setCost: function setCost(a) {\n      this._jsPlumb.cost = a;\n    },\n    isDirected: function isDirected() {\n      return this._jsPlumb.directed;\n    },\n    getConnector: function getConnector() {\n      return this.connector;\n    },\n    prepareConnector: function prepareConnector(a, b) {\n      var e,\n          f = {\n        _jsPlumb: this._jsPlumb.instance,\n        cssClass: this._jsPlumb.params.cssClass,\n        container: this._jsPlumb.params.container,\n        \"pointer-events\": this._jsPlumb.params[\"pointer-events\"]\n      },\n          g = this._jsPlumb.instance.getRenderMode();\n\n      return c.isString(a) ? e = d(this._jsPlumb.instance, g, a, f, this) : c.isArray(a) && (e = 1 === a.length ? d(this._jsPlumb.instance, g, a[0], f, this) : d(this._jsPlumb.instance, g, a[0], c.merge(a[1], f), this)), null != b && (e.typeId = b), e;\n    },\n    setPreparedConnector: function setPreparedConnector(a, b, c, d) {\n      if (this.connector !== a) {\n        var e,\n            f = \"\";\n        if (null != this.connector && (e = this.connector, f = e.getClass(), this.connector.cleanup(), this.connector.destroy()), this.connector = a, d && this.cacheTypeItem(\"connector\", a, d), this.canvas = this.connector.canvas, this.bgCanvas = this.connector.bgCanvas, this.connector.reattach(this._jsPlumb.instance), this.addClass(f), this.canvas && (this.canvas._jsPlumb = this), this.bgCanvas && (this.bgCanvas._jsPlumb = this), null != e) for (var g = this.getOverlays(), h = 0; h < g.length; h++) {\n          g[h].transfer && g[h].transfer(this.connector);\n        }\n        c || this.setListenerComponent(this.connector), b || this.repaint();\n      }\n    },\n    setConnector: function setConnector(a, b, c, d) {\n      var e = this.prepareConnector(a, d);\n      this.setPreparedConnector(e, b, c, d);\n    },\n    paint: function paint(a) {\n      if (!this._jsPlumb.instance.isSuspendDrawing() && this._jsPlumb.visible) {\n        a = a || {};\n        var b = a.timestamp,\n            c = !1,\n            d = c ? this.sourceId : this.targetId,\n            e = c ? this.targetId : this.sourceId,\n            f = c ? 0 : 1,\n            g = c ? 1 : 0;\n\n        if (null == b || b !== this._jsPlumb.lastPaintedAt) {\n          var h = this._jsPlumb.instance.updateOffset({\n            elId: e\n          }).o,\n              i = this._jsPlumb.instance.updateOffset({\n            elId: d\n          }).o,\n              j = this.endpoints[g],\n              k = this.endpoints[f],\n              l = j.anchor.getCurrentLocation({\n            xy: [h.left, h.top],\n            wh: [h.width, h.height],\n            element: j,\n            timestamp: b\n          }),\n              m = k.anchor.getCurrentLocation({\n            xy: [i.left, i.top],\n            wh: [i.width, i.height],\n            element: k,\n            timestamp: b\n          });\n\n          this.connector.resetBounds(), this.connector.compute({\n            sourcePos: l,\n            targetPos: m,\n            sourceOrientation: j.anchor.getOrientation(j),\n            targetOrientation: k.anchor.getOrientation(k),\n            sourceEndpoint: this.endpoints[g],\n            targetEndpoint: this.endpoints[f],\n            \"stroke-width\": this._jsPlumb.paintStyleInUse.strokeWidth,\n            sourceInfo: h,\n            targetInfo: i\n          });\n          var n = {\n            minX: 1 / 0,\n            minY: 1 / 0,\n            maxX: -(1 / 0),\n            maxY: -(1 / 0)\n          };\n\n          for (var o in this._jsPlumb.overlays) {\n            if (this._jsPlumb.overlays.hasOwnProperty(o)) {\n              var p = this._jsPlumb.overlays[o];\n              p.isVisible() && (this._jsPlumb.overlayPlacements[o] = p.draw(this.connector, this._jsPlumb.paintStyleInUse, this.getAbsoluteOverlayPosition(p)), n.minX = Math.min(n.minX, this._jsPlumb.overlayPlacements[o].minX), n.maxX = Math.max(n.maxX, this._jsPlumb.overlayPlacements[o].maxX), n.minY = Math.min(n.minY, this._jsPlumb.overlayPlacements[o].minY), n.maxY = Math.max(n.maxY, this._jsPlumb.overlayPlacements[o].maxY));\n            }\n          }\n\n          var q = parseFloat(this._jsPlumb.paintStyleInUse.strokeWidth || 1) / 2,\n              r = parseFloat(this._jsPlumb.paintStyleInUse.strokeWidth || 0),\n              s = {\n            xmin: Math.min(this.connector.bounds.minX - (q + r), n.minX),\n            ymin: Math.min(this.connector.bounds.minY - (q + r), n.minY),\n            xmax: Math.max(this.connector.bounds.maxX + (q + r), n.maxX),\n            ymax: Math.max(this.connector.bounds.maxY + (q + r), n.maxY)\n          };\n          this.connector.paintExtents = s, this.connector.paint(this._jsPlumb.paintStyleInUse, null, s);\n\n          for (var t in this._jsPlumb.overlays) {\n            if (this._jsPlumb.overlays.hasOwnProperty(t)) {\n              var u = this._jsPlumb.overlays[t];\n              u.isVisible() && u.paint(this._jsPlumb.overlayPlacements[t], s);\n            }\n          }\n        }\n\n        this._jsPlumb.lastPaintedAt = b;\n      }\n    },\n    repaint: function repaint(a) {\n      var b = jsPlumb.extend(a || {}, {});\n      b.elId = this.sourceId, this.paint(b);\n    },\n    prepareEndpoint: function prepareEndpoint(a, c, d, f, g, h, i, j, k) {\n      var l;\n      if (f) d.endpoints[g] = f, f.addConnection(d);else {\n        h.endpoints || (h.endpoints = [null, null]);\n        var m = k || h.endpoints[g] || h.endpoint || a.Defaults.Endpoints[g] || b.Defaults.Endpoints[g] || a.Defaults.Endpoint || b.Defaults.Endpoint;\n        h.endpointStyles || (h.endpointStyles = [null, null]), h.endpointHoverStyles || (h.endpointHoverStyles = [null, null]);\n        var n = h.endpointStyles[g] || h.endpointStyle || a.Defaults.EndpointStyles[g] || b.Defaults.EndpointStyles[g] || a.Defaults.EndpointStyle || b.Defaults.EndpointStyle;\n        null == n.fill && null != h.paintStyle && (n.fill = h.paintStyle.stroke), null == n.outlineStroke && null != h.paintStyle && (n.outlineStroke = h.paintStyle.outlineStroke), null == n.outlineWidth && null != h.paintStyle && (n.outlineWidth = h.paintStyle.outlineWidth);\n        var o = h.endpointHoverStyles[g] || h.endpointHoverStyle || a.Defaults.EndpointHoverStyles[g] || b.Defaults.EndpointHoverStyles[g] || a.Defaults.EndpointHoverStyle || b.Defaults.EndpointHoverStyle;\n        null != h.hoverPaintStyle && (null == o && (o = {}), null == o.fill && (o.fill = h.hoverPaintStyle.stroke));\n        var p = h.anchors ? h.anchors[g] : h.anchor ? h.anchor : e(a.Defaults.Anchors[g], j, a) || e(b.Defaults.Anchors[g], j, a) || e(a.Defaults.Anchor, j, a) || e(b.Defaults.Anchor, j, a),\n            q = h.uuids ? h.uuids[g] : null;\n        l = c({\n          paintStyle: n,\n          hoverPaintStyle: o,\n          endpoint: m,\n          connections: [d],\n          uuid: q,\n          anchor: p,\n          source: i,\n          scope: h.scope,\n          reattach: h.reattach || a.Defaults.ReattachConnections,\n          detachable: h.detachable || a.Defaults.ConnectionsDetachable\n        }), null == f && l.setDeleteOnEmpty(!0), d.endpoints[g] = l, h.drawEndpoints === !1 && l.setVisible(!1, !0, !0);\n      }\n      return l;\n    },\n    replaceEndpoint: function replaceEndpoint(a, b) {\n      var c = this.endpoints[a],\n          d = c.elementId,\n          e = this._jsPlumb.instance.getEndpoints(d),\n          f = e.indexOf(c),\n          g = this.makeEndpoint(0 === a, c.element, d, null, b);\n\n      this.endpoints[a] = g, e.splice(f, 1, g), this._jsPlumb.instance.deleteObject({\n        endpoint: c,\n        deleteAttachedObjects: !1\n      }), this._jsPlumb.instance.fire(\"endpointReplaced\", {\n        previous: c,\n        current: g\n      }), this._jsPlumb.instance.anchorManager.updateOtherEndpoint(this.endpoints[0].elementId, this.endpoints[1].elementId, this.endpoints[1].elementId, this);\n    }\n  });\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this,\n      b = a.jsPlumbUtil,\n      c = a.jsPlumb;\n  c.AnchorManager = function (a) {\n    var d = {},\n        e = {},\n        f = {},\n        g = {},\n        h = this,\n        i = {},\n        j = a.jsPlumbInstance,\n        k = {},\n        l = function l(a, b, c, d, e, f, g) {\n      for (var h = [], i = b[e ? 0 : 1] / (d.length + 1), j = 0; j < d.length; j++) {\n        var k = (j + 1) * i,\n            l = f * b[e ? 1 : 0];\n        g && (k = b[e ? 0 : 1] - k);\n        var m = e ? k : l,\n            n = c[0] + m,\n            o = m / b[0],\n            p = e ? l : k,\n            q = c[1] + p,\n            r = p / b[1];\n        h.push([n, q, o, r, d[j][1], d[j][2]]);\n      }\n\n      return h;\n    },\n        m = function m(a, b) {\n      return b[0][0] - a[0][0];\n    },\n        n = function n(a, b) {\n      var c = a[0][0] < 0 ? -Math.PI - a[0][0] : Math.PI - a[0][0],\n          d = b[0][0] < 0 ? -Math.PI - b[0][0] : Math.PI - b[0][0];\n      return c - d;\n    },\n        o = {\n      top: n,\n      right: m,\n      bottom: m,\n      left: n\n    },\n        p = function p(a, b) {\n      return a.sort(b);\n    },\n        q = function q(a, b) {\n      var c = j.getCachedData(a),\n          d = c.s,\n          g = c.o,\n          h = function h(b, c, d, g, _h, i, j) {\n        if (g.length > 0) for (var k = p(g, o[b]), m = \"right\" === b || \"top\" === b, n = l(b, c, d, k, _h, i, m), q = function q(a, b) {\n          e[a.id] = [b[0], b[1], b[2], b[3]], f[a.id] = j;\n        }, r = 0; r < n.length; r++) {\n          var s = n[r][4],\n              t = s.endpoints[0].elementId === a,\n              u = s.endpoints[1].elementId === a;\n          t && q(s.endpoints[0], n[r]), u && q(s.endpoints[1], n[r]);\n        }\n      };\n\n      h(\"bottom\", d, [g.left, g.top], b.bottom, !0, 1, [0, 1]), h(\"top\", d, [g.left, g.top], b.top, !0, 0, [0, -1]), h(\"left\", d, [g.left, g.top], b.left, !1, 0, [-1, 0]), h(\"right\", d, [g.left, g.top], b.right, !1, 1, [1, 0]);\n    };\n\n    this.reset = function () {\n      d = {}, g = {}, i = {};\n    }, this.addFloatingConnection = function (a, b) {\n      k[a] = b;\n    }, this.removeFloatingConnection = function (a) {\n      delete k[a];\n    }, this.newConnection = function (a) {\n      var d = a.sourceId,\n          e = a.targetId,\n          f = a.endpoints,\n          h = !0,\n          i = function i(_i, j, k, l, m) {\n        d === e && k.isContinuous && (a._jsPlumb.instance.removeElement(f[1].canvas), h = !1), b.addToList(g, l, [m, j, k.constructor === c.DynamicAnchor]);\n      };\n\n      i(0, f[0], f[0].anchor, e, a), h && i(1, f[1], f[1].anchor, d, a);\n    };\n\n    var r = function r(a) {\n      !function (a, c) {\n        if (a) {\n          var d = function d(a) {\n            return a[4] === c;\n          };\n\n          b.removeWithFunction(a.top, d), b.removeWithFunction(a.left, d), b.removeWithFunction(a.bottom, d), b.removeWithFunction(a.right, d);\n        }\n      }(i[a.elementId], a.id);\n    };\n\n    this.connectionDetached = function (a, c) {\n      var d = a.connection || a,\n          e = a.sourceId,\n          f = a.targetId,\n          i = d.endpoints,\n          j = function j(a, c, d, e, f) {\n        b.removeWithFunction(g[e], function (a) {\n          return a[0].id === f.id;\n        });\n      };\n\n      j(1, i[1], i[1].anchor, e, d), j(0, i[0], i[0].anchor, f, d), d.floatingId && (j(d.floatingIndex, d.floatingEndpoint, d.floatingEndpoint.anchor, d.floatingId, d), r(d.floatingEndpoint)), r(d.endpoints[0]), r(d.endpoints[1]), c || (h.redraw(d.sourceId), d.targetId !== d.sourceId && h.redraw(d.targetId));\n    }, this.add = function (a, c) {\n      b.addToList(d, c, a);\n    }, this.changeId = function (a, b) {\n      g[b] = g[a], d[b] = d[a], delete g[a], delete d[a];\n    }, this.getConnectionsFor = function (a) {\n      return g[a] || [];\n    }, this.getEndpointsFor = function (a) {\n      return d[a] || [];\n    }, this.deleteEndpoint = function (a) {\n      b.removeWithFunction(d[a.elementId], function (b) {\n        return b.id === a.id;\n      }), r(a);\n    }, this.clearFor = function (a) {\n      delete d[a], d[a] = [];\n    };\n\n    var s = function s(c, d, e, f, g, h, i, j, k, l, m, n) {\n      var o,\n          p,\n          q = -1,\n          r = -1,\n          s = f.endpoints[i],\n          t = s.id,\n          u = [1, 0][i],\n          v = [[d, e], f, g, h, t],\n          w = c[k],\n          x = s._continuousAnchorEdge ? c[s._continuousAnchorEdge] : null;\n\n      if (x) {\n        var y = b.findWithFunction(x, function (a) {\n          return a[4] === t;\n        });\n        if (-1 !== y) for (x.splice(y, 1), o = 0; o < x.length; o++) {\n          p = x[o][1], b.addWithFunction(m, p, function (a) {\n            return a.id === p.id;\n          }), b.addWithFunction(n, x[o][1].endpoints[i], function (a) {\n            return a.id === p.endpoints[i].id;\n          }), b.addWithFunction(n, x[o][1].endpoints[u], function (a) {\n            return a.id === p.endpoints[u].id;\n          });\n        }\n      }\n\n      for (o = 0; o < w.length; o++) {\n        p = w[o][1], 1 === a.idx && w[o][3] === h && -1 === r && (r = o), b.addWithFunction(m, p, function (a) {\n          return a.id === p.id;\n        }), b.addWithFunction(n, w[o][1].endpoints[i], function (a) {\n          return a.id === p.endpoints[i].id;\n        }), b.addWithFunction(n, w[o][1].endpoints[u], function (a) {\n          return a.id === p.endpoints[u].id;\n        });\n      }\n\n      if (-1 !== q) w[q] = v;else {\n        var z = j ? -1 !== r ? r : 0 : w.length;\n        w.splice(z, 0, v);\n      }\n      s._continuousAnchorEdge = k;\n    };\n\n    this.updateOtherEndpoint = function (a, d, e, f) {\n      var h = b.findWithFunction(g[a], function (a) {\n        return a[0].id === f.id;\n      }),\n          i = b.findWithFunction(g[d], function (a) {\n        return a[0].id === f.id;\n      });\n      -1 !== h && (g[a][h][0] = f, g[a][h][1] = f.endpoints[1], g[a][h][2] = f.endpoints[1].anchor.constructor === c.DynamicAnchor), i > -1 && (g[d].splice(i, 1), b.addToList(g, e, [f, f.endpoints[0], f.endpoints[0].anchor.constructor === c.DynamicAnchor])), f.updateConnectedClass();\n    }, this.sourceChanged = function (a, d, e, f) {\n      if (a !== d) {\n        e.sourceId = d, e.source = f, b.removeWithFunction(g[a], function (a) {\n          return a[0].id === e.id;\n        });\n        var h = b.findWithFunction(g[e.targetId], function (a) {\n          return a[0].id === e.id;\n        });\n        h > -1 && (g[e.targetId][h][0] = e, g[e.targetId][h][1] = e.endpoints[0], g[e.targetId][h][2] = e.endpoints[0].anchor.constructor === c.DynamicAnchor), b.addToList(g, d, [e, e.endpoints[1], e.endpoints[1].anchor.constructor === c.DynamicAnchor]), e.endpoints[1].anchor.isContinuous && (e.source === e.target ? e._jsPlumb.instance.removeElement(e.endpoints[1].canvas) : null == e.endpoints[1].canvas.parentNode && e._jsPlumb.instance.appendElement(e.endpoints[1].canvas)), e.updateConnectedClass();\n      }\n    }, this.rehomeEndpoint = function (a, b, c) {\n      var e = d[b] || [],\n          f = j.getId(c);\n\n      if (f !== b) {\n        var g = e.indexOf(a);\n\n        if (g > -1) {\n          var i = e.splice(g, 1)[0];\n          h.add(i, f);\n        }\n      }\n\n      for (var k = 0; k < a.connections.length; k++) {\n        a.connections[k].sourceId === b ? h.sourceChanged(b, a.elementId, a.connections[k], a.element) : a.connections[k].targetId === b && (a.connections[k].targetId = a.elementId, a.connections[k].target = a.element, h.updateOtherEndpoint(a.connections[k].sourceId, b, a.elementId, a.connections[k]));\n      }\n    }, this.redraw = function (a, e, f, h, l, m) {\n      if (!j.isSuspendDrawing()) {\n        var n = d[a] || [],\n            o = g[a] || [],\n            p = [],\n            r = [],\n            t = [];\n        f = f || j.timestamp(), h = h || {\n          left: 0,\n          top: 0\n        }, e && (e = {\n          left: e.left + h.left,\n          top: e.top + h.top\n        });\n\n        for (var u = j.updateOffset({\n          elId: a,\n          offset: e,\n          recalc: !1,\n          timestamp: f\n        }), v = {}, w = 0; w < o.length; w++) {\n          var x = o[w][0],\n              y = x.sourceId,\n              z = x.targetId,\n              A = x.endpoints[0].anchor.isContinuous,\n              B = x.endpoints[1].anchor.isContinuous;\n\n          if (A || B) {\n            var C = y + \"_\" + z,\n                D = v[C],\n                E = x.sourceId === a ? 1 : 0;\n            A && !i[y] && (i[y] = {\n              top: [],\n              right: [],\n              bottom: [],\n              left: []\n            }), B && !i[z] && (i[z] = {\n              top: [],\n              right: [],\n              bottom: [],\n              left: []\n            }), a !== z && j.updateOffset({\n              elId: z,\n              timestamp: f\n            }), a !== y && j.updateOffset({\n              elId: y,\n              timestamp: f\n            });\n            var F = j.getCachedData(z),\n                G = j.getCachedData(y);\n            z === y && (A || B) ? (s(i[y], -Math.PI / 2, 0, x, !1, z, 0, !1, \"top\", y, p, r), s(i[z], -Math.PI / 2, 0, x, !1, y, 1, !1, \"top\", z, p, r)) : (D || (D = this.calculateOrientation(y, z, G.o, F.o, x.endpoints[0].anchor, x.endpoints[1].anchor, x), v[C] = D), A && s(i[y], D.theta, 0, x, !1, z, 0, !1, D.a[0], y, p, r), B && s(i[z], D.theta2, -1, x, !0, y, 1, !0, D.a[1], z, p, r)), A && b.addWithFunction(t, y, function (a) {\n              return a === y;\n            }), B && b.addWithFunction(t, z, function (a) {\n              return a === z;\n            }), b.addWithFunction(p, x, function (a) {\n              return a.id === x.id;\n            }), (A && 0 === E || B && 1 === E) && b.addWithFunction(r, x.endpoints[E], function (a) {\n              return a.id === x.endpoints[E].id;\n            });\n          }\n        }\n\n        for (w = 0; w < n.length; w++) {\n          0 === n[w].connections.length && n[w].anchor.isContinuous && (i[a] || (i[a] = {\n            top: [],\n            right: [],\n            bottom: [],\n            left: []\n          }), s(i[a], -Math.PI / 2, 0, {\n            endpoints: [n[w], n[w]],\n            paint: function paint() {}\n          }, !1, a, 0, !1, n[w].anchor.getDefaultFace(), a, p, r), b.addWithFunction(t, a, function (b) {\n            return b === a;\n          }));\n        }\n\n        for (w = 0; w < t.length; w++) {\n          q(t[w], i[t[w]]);\n        }\n\n        for (w = 0; w < n.length; w++) {\n          n[w].paint({\n            timestamp: f,\n            offset: u,\n            dimensions: u.s,\n            recalc: m !== !0\n          });\n        }\n\n        for (w = 0; w < r.length; w++) {\n          var H = j.getCachedData(r[w].elementId);\n          r[w].paint({\n            timestamp: null,\n            offset: H,\n            dimensions: H.s\n          });\n        }\n\n        for (w = 0; w < o.length; w++) {\n          var I = o[w][1];\n\n          if (I.anchor.constructor === c.DynamicAnchor) {\n            I.paint({\n              elementWithPrecedence: a,\n              timestamp: f\n            }), b.addWithFunction(p, o[w][0], function (a) {\n              return a.id === o[w][0].id;\n            });\n\n            for (var J = 0; J < I.connections.length; J++) {\n              I.connections[J] !== o[w][0] && b.addWithFunction(p, I.connections[J], function (a) {\n                return a.id === I.connections[J].id;\n              });\n            }\n          } else b.addWithFunction(p, o[w][0], function (a) {\n            return a.id === o[w][0].id;\n          });\n        }\n\n        var K = k[a];\n\n        for (K && K.paint({\n          timestamp: f,\n          recalc: !1,\n          elId: a\n        }), w = 0; w < p.length; w++) {\n          p[w].paint({\n            elId: a,\n            timestamp: null,\n            recalc: !1,\n            clearEdits: l\n          });\n        }\n      }\n    };\n\n    var t = function t(a) {\n      b.EventGenerator.apply(this), this.type = \"Continuous\", this.isDynamic = !0, this.isContinuous = !0;\n\n      for (var c = a.faces || [\"top\", \"right\", \"bottom\", \"left\"], d = !(a.clockwise === !1), g = {}, h = {\n        top: \"bottom\",\n        right: \"left\",\n        left: \"right\",\n        bottom: \"top\"\n      }, i = {\n        top: \"right\",\n        right: \"bottom\",\n        left: \"top\",\n        bottom: \"left\"\n      }, j = {\n        top: \"left\",\n        right: \"top\",\n        left: \"bottom\",\n        bottom: \"right\"\n      }, k = d ? i : j, l = d ? j : i, m = a.cssClass || \"\", n = null, o = null, p = [\"left\", \"right\"], q = [\"top\", \"bottom\"], r = null, s = 0; s < c.length; s++) {\n        g[c[s]] = !0;\n      }\n\n      this.getDefaultFace = function () {\n        return 0 === c.length ? \"top\" : c[0];\n      }, this.isRelocatable = function () {\n        return !0;\n      }, this.isSnapOnRelocate = function () {\n        return !0;\n      }, this.verifyEdge = function (a) {\n        return g[a] ? a : g[h[a]] ? h[a] : g[k[a]] ? k[a] : g[l[a]] ? l[a] : a;\n      }, this.isEdgeSupported = function (a) {\n        return null == r ? null == o ? g[a] === !0 : o === a : -1 !== r.indexOf(a);\n      }, this.setCurrentFace = function (a, b) {\n        n = a, b && null != o && (o = n);\n      }, this.getCurrentFace = function () {\n        return n;\n      }, this.getSupportedFaces = function () {\n        var a = [];\n\n        for (var b in g) {\n          g[b] && a.push(b);\n        }\n\n        return a;\n      }, this.lock = function () {\n        o = n;\n      }, this.unlock = function () {\n        o = null;\n      }, this.isLocked = function () {\n        return null != o;\n      }, this.lockCurrentAxis = function () {\n        null != n && (r = \"left\" === n || \"right\" === n ? p : q);\n      }, this.unlockCurrentAxis = function () {\n        r = null;\n      }, this.compute = function (a) {\n        return e[a.element.id] || [0, 0];\n      }, this.getCurrentLocation = function (a) {\n        return e[a.element.id] || [0, 0];\n      }, this.getOrientation = function (a) {\n        return f[a.id] || [0, 0];\n      }, this.getCssClass = function () {\n        return m;\n      };\n    };\n\n    j.continuousAnchorFactory = {\n      get: function get(a) {\n        return new t(a);\n      },\n      clear: function clear(a) {\n        delete e[a];\n      }\n    };\n  }, c.AnchorManager.prototype.calculateOrientation = function (a, b, c, d, e, f) {\n    var g = {\n      HORIZONTAL: \"horizontal\",\n      VERTICAL: \"vertical\",\n      DIAGONAL: \"diagonal\",\n      IDENTITY: \"identity\"\n    },\n        h = [\"left\", \"top\", \"right\", \"bottom\"];\n    if (a === b) return {\n      orientation: g.IDENTITY,\n      a: [\"top\", \"top\"]\n    };\n    var i = Math.atan2(d.centery - c.centery, d.centerx - c.centerx),\n        j = Math.atan2(c.centery - d.centery, c.centerx - d.centerx),\n        k = [],\n        l = {};\n    !function (a, b) {\n      for (var c = 0; c < a.length; c++) {\n        l[a[c]] = {\n          left: [b[c].left, b[c].centery],\n          right: [b[c].right, b[c].centery],\n          top: [b[c].centerx, b[c].top],\n          bottom: [b[c].centerx, b[c].bottom]\n        };\n      }\n    }([\"source\", \"target\"], [c, d]);\n\n    for (var m = 0; m < h.length; m++) {\n      for (var n = 0; n < h.length; n++) {\n        k.push({\n          source: h[m],\n          target: h[n],\n          dist: Biltong.lineLength(l.source[h[m]], l.target[h[n]])\n        });\n      }\n    }\n\n    k.sort(function (a, b) {\n      return a.dist < b.dist ? -1 : a.dist > b.dist ? 1 : 0;\n    });\n\n    for (var o = k[0].source, p = k[0].target, q = 0; q < k.length && (o = !e.isContinuous || e.isEdgeSupported(k[q].source) ? k[q].source : null, p = !f.isContinuous || f.isEdgeSupported(k[q].target) ? k[q].target : null, null == o || null == p); q++) {\n      ;\n    }\n\n    return e.isContinuous && e.setCurrentFace(o), f.isContinuous && f.setCurrentFace(p), {\n      a: [o, p],\n      theta: i,\n      theta2: j\n    };\n  }, c.Anchor = function (a) {\n    this.x = a.x || 0, this.y = a.y || 0, this.elementId = a.elementId, this.cssClass = a.cssClass || \"\", this.userDefinedLocation = null, this.orientation = a.orientation || [0, 0], this.lastReturnValue = null, this.offsets = a.offsets || [0, 0], this.timestamp = null;\n    var c = a.relocatable !== !1;\n    this.isRelocatable = function () {\n      return c;\n    }, this.setRelocatable = function (a) {\n      c = a;\n    };\n    var d = a.snapOnRelocate !== !1;\n\n    this.isSnapOnRelocate = function () {\n      return d;\n    };\n\n    var e = !1;\n    this.lock = function () {\n      e = !0;\n    }, this.unlock = function () {\n      e = !1;\n    }, this.isLocked = function () {\n      return e;\n    }, b.EventGenerator.apply(this), this.compute = function (a) {\n      var b = a.xy,\n          c = a.wh,\n          d = a.timestamp;\n      return a.clearUserDefinedLocation && (this.userDefinedLocation = null), d && d === this.timestamp ? this.lastReturnValue : (null != this.userDefinedLocation ? this.lastReturnValue = this.userDefinedLocation : this.lastReturnValue = [b[0] + this.x * c[0] + this.offsets[0], b[1] + this.y * c[1] + this.offsets[1], this.x, this.y], this.timestamp = d, this.lastReturnValue);\n    }, this.getCurrentLocation = function (a) {\n      return a = a || {}, null == this.lastReturnValue || null != a.timestamp && this.timestamp !== a.timestamp ? this.compute(a) : this.lastReturnValue;\n    }, this.setPosition = function (a, b, c, d, f) {\n      (!e || f) && (this.x = a, this.y = b, this.orientation = [c, d], this.lastReturnValue = null);\n    };\n  }, b.extend(c.Anchor, b.EventGenerator, {\n    equals: function equals(a) {\n      if (!a) return !1;\n      var b = a.getOrientation(),\n          c = this.getOrientation();\n      return this.x === a.x && this.y === a.y && this.offsets[0] === a.offsets[0] && this.offsets[1] === a.offsets[1] && c[0] === b[0] && c[1] === b[1];\n    },\n    getUserDefinedLocation: function getUserDefinedLocation() {\n      return this.userDefinedLocation;\n    },\n    setUserDefinedLocation: function setUserDefinedLocation(a) {\n      this.userDefinedLocation = a;\n    },\n    clearUserDefinedLocation: function clearUserDefinedLocation() {\n      this.userDefinedLocation = null;\n    },\n    getOrientation: function getOrientation() {\n      return this.orientation;\n    },\n    getCssClass: function getCssClass() {\n      return this.cssClass;\n    }\n  }), c.FloatingAnchor = function (a) {\n    c.Anchor.apply(this, arguments);\n    var b = a.reference,\n        d = a.referenceCanvas,\n        e = c.getSize(d),\n        f = 0,\n        g = 0,\n        h = null,\n        i = null;\n    this.orientation = null, this.x = 0, this.y = 0, this.isFloating = !0, this.compute = function (a) {\n      var b = a.xy,\n          c = [b[0] + e[0] / 2, b[1] + e[1] / 2];\n      return i = c, c;\n    }, this.getOrientation = function (a) {\n      if (h) return h;\n      var c = b.getOrientation(a);\n      return [Math.abs(c[0]) * f * -1, Math.abs(c[1]) * g * -1];\n    }, this.over = function (a, b) {\n      h = a.getOrientation(b);\n    }, this.out = function () {\n      h = null;\n    }, this.getCurrentLocation = function (a) {\n      return null == i ? this.compute(a) : i;\n    };\n  }, b.extend(c.FloatingAnchor, c.Anchor);\n\n  var d = function d(a, b, _d5) {\n    return a.constructor === c.Anchor ? a : b.makeAnchor(a, _d5, b);\n  };\n\n  c.DynamicAnchor = function (a) {\n    c.Anchor.apply(this, arguments), this.isDynamic = !0, this.anchors = [], this.elementId = a.elementId, this.jsPlumbInstance = a.jsPlumbInstance;\n\n    for (var b = 0; b < a.anchors.length; b++) {\n      this.anchors[b] = d(a.anchors[b], this.jsPlumbInstance, this.elementId);\n    }\n\n    this.getAnchors = function () {\n      return this.anchors;\n    };\n\n    var e = this.anchors.length > 0 ? this.anchors[0] : null,\n        f = e,\n        g = this,\n        h = function h(a, b, c, d, e) {\n      var f = d[0] + a.x * e[0],\n          g = d[1] + a.y * e[1],\n          h = d[0] + e[0] / 2,\n          i = d[1] + e[1] / 2;\n      return Math.sqrt(Math.pow(b - f, 2) + Math.pow(c - g, 2)) + Math.sqrt(Math.pow(h - f, 2) + Math.pow(i - g, 2));\n    },\n        i = a.selector || function (a, b, c, d, e) {\n      for (var f = c[0] + d[0] / 2, g = c[1] + d[1] / 2, i = -1, j = 1 / 0, k = 0; k < e.length; k++) {\n        var l = h(e[k], f, g, a, b);\n        j > l && (i = k + 0, j = l);\n      }\n\n      return e[i];\n    };\n\n    this.compute = function (a) {\n      var b = a.xy,\n          c = a.wh,\n          d = a.txy,\n          h = a.twh;\n      this.timestamp = a.timestamp;\n      var j = g.getUserDefinedLocation();\n      return null != j ? j : this.isLocked() || null == d || null == h ? e.compute(a) : (a.timestamp = null, e = i(b, c, d, h, this.anchors), this.x = e.x, this.y = e.y, e !== f && this.fire(\"anchorChanged\", e), f = e, e.compute(a));\n    }, this.getCurrentLocation = function (a) {\n      return this.getUserDefinedLocation() || (null != e ? e.getCurrentLocation(a) : null);\n    }, this.getOrientation = function (a) {\n      return null != e ? e.getOrientation(a) : [0, 0];\n    }, this.over = function (a, b) {\n      null != e && e.over(a, b);\n    }, this.out = function () {\n      null != e && e.out();\n    }, this.setAnchor = function (a) {\n      e = a;\n    }, this.getCssClass = function () {\n      return e && e.getCssClass() || \"\";\n    }, this.setAnchorCoordinates = function (a) {\n      var b = jsPlumbUtil.findWithFunction(this.anchors, function (b) {\n        return b.x === a[0] && b.y === a[1];\n      });\n      return -1 !== b ? (this.setAnchor(this.anchors[b]), !0) : !1;\n    };\n  }, b.extend(c.DynamicAnchor, c.Anchor);\n\n  var e = function e(a, b, d, _e, f, g) {\n    c.Anchors[f] = function (c) {\n      var h = c.jsPlumbInstance.makeAnchor([a, b, d, _e, 0, 0], c.elementId, c.jsPlumbInstance);\n      return h.type = f, g && g(h, c), h;\n    };\n  };\n\n  e(.5, 0, 0, -1, \"TopCenter\"), e(.5, 1, 0, 1, \"BottomCenter\"), e(0, .5, -1, 0, \"LeftMiddle\"), e(1, .5, 1, 0, \"RightMiddle\"), e(.5, 0, 0, -1, \"Top\"), e(.5, 1, 0, 1, \"Bottom\"), e(0, .5, -1, 0, \"Left\"), e(1, .5, 1, 0, \"Right\"), e(.5, .5, 0, 0, \"Center\"), e(1, 0, 0, -1, \"TopRight\"), e(1, 1, 0, 1, \"BottomRight\"), e(0, 0, 0, -1, \"TopLeft\"), e(0, 1, 0, 1, \"BottomLeft\"), c.Defaults.DynamicAnchors = function (a) {\n    return a.jsPlumbInstance.makeAnchors([\"TopCenter\", \"RightMiddle\", \"BottomCenter\", \"LeftMiddle\"], a.elementId, a.jsPlumbInstance);\n  }, c.Anchors.AutoDefault = function (a) {\n    var b = a.jsPlumbInstance.makeDynamicAnchor(c.Defaults.DynamicAnchors(a));\n    return b.type = \"AutoDefault\", b;\n  };\n\n  var f = function f(a, b) {\n    c.Anchors[a] = function (c) {\n      var d = c.jsPlumbInstance.makeAnchor([\"Continuous\", {\n        faces: b\n      }], c.elementId, c.jsPlumbInstance);\n      return d.type = a, d;\n    };\n  };\n\n  c.Anchors.Continuous = function (a) {\n    return a.jsPlumbInstance.continuousAnchorFactory.get(a);\n  }, f(\"ContinuousLeft\", [\"left\"]), f(\"ContinuousTop\", [\"top\"]), f(\"ContinuousBottom\", [\"bottom\"]), f(\"ContinuousRight\", [\"right\"]), e(0, 0, 0, 0, \"Assign\", function (a, b) {\n    var c = b.position || \"Fixed\";\n    a.positionFinder = c.constructor === String ? b.jsPlumbInstance.AnchorPositionFinders[c] : c, a.constructorParams = b;\n  }), a.jsPlumbInstance.prototype.AnchorPositionFinders = {\n    Fixed: function Fixed(a, b, c) {\n      return [(a.left - b.left) / c[0], (a.top - b.top) / c[1]];\n    },\n    Grid: function Grid(a, b, c, d) {\n      var e = a.left - b.left,\n          f = a.top - b.top,\n          g = c[0] / d.grid[0],\n          h = c[1] / d.grid[1],\n          i = Math.floor(e / g),\n          j = Math.floor(f / h);\n      return [(i * g + g / 2) / c[0], (j * h + h / 2) / c[1]];\n    }\n  }, c.Anchors.Perimeter = function (a) {\n    a = a || {};\n    var b = a.anchorCount || 60,\n        c = a.shape;\n    if (!c) throw new Error(\"no shape supplied to Perimeter Anchor type\");\n\n    var d = function d() {\n      for (var a = .5, c = 2 * Math.PI / b, d = 0, e = [], f = 0; b > f; f++) {\n        var g = a + a * Math.sin(d),\n            h = a + a * Math.cos(d);\n        e.push([g, h, 0, 0]), d += c;\n      }\n\n      return e;\n    },\n        e = function e(a) {\n      for (var c = b / a.length, d = [], e = function e(a, _e2, f, g, h, i, j) {\n        c = b * h;\n\n        for (var k = (f - a) / c, l = (g - _e2) / c, m = 0; c > m; m++) {\n          d.push([a + k * m, _e2 + l * m, null == i ? 0 : i, null == j ? 0 : j]);\n        }\n      }, f = 0; f < a.length; f++) {\n        e.apply(null, a[f]);\n      }\n\n      return d;\n    },\n        f = function f(a) {\n      for (var b = [], c = 0; c < a.length; c++) {\n        b.push([a[c][0], a[c][1], a[c][2], a[c][3], 1 / a.length, a[c][4], a[c][5]]);\n      }\n\n      return e(b);\n    },\n        g = function g() {\n      return f([[0, 0, 1, 0, 0, -1], [1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 1, 0, 0, -1, 0]]);\n    },\n        h = {\n      Circle: d,\n      Ellipse: d,\n      Diamond: function Diamond() {\n        return f([[.5, 0, 1, .5], [1, .5, .5, 1], [.5, 1, 0, .5], [0, .5, .5, 0]]);\n      },\n      Rectangle: g,\n      Square: g,\n      Triangle: function Triangle() {\n        return f([[.5, 0, 1, 1], [1, 1, 0, 1], [0, 1, .5, 0]]);\n      },\n      Path: function Path(a) {\n        for (var b = a.points, c = [], d = 0, f = 0; f < b.length - 1; f++) {\n          var g = Math.sqrt(Math.pow(b[f][2] - b[f][0]) + Math.pow(b[f][3] - b[f][1]));\n          d += g, c.push([b[f][0], b[f][1], b[f + 1][0], b[f + 1][1], g]);\n        }\n\n        for (var h = 0; h < c.length; h++) {\n          c[h][4] = c[h][4] / d;\n        }\n\n        return e(c);\n      }\n    },\n        i = function i(a, b) {\n      for (var c = [], d = b / 180 * Math.PI, e = 0; e < a.length; e++) {\n        var f = a[e][0] - .5,\n            g = a[e][1] - .5;\n        c.push([.5 + (f * Math.cos(d) - g * Math.sin(d)), .5 + (f * Math.sin(d) + g * Math.cos(d)), a[e][2], a[e][3]]);\n      }\n\n      return c;\n    };\n\n    if (!h[c]) throw new Error(\"Shape [\" + c + \"] is unknown by Perimeter Anchor type\");\n    var j = h[c](a);\n    a.rotation && (j = i(j, a.rotation));\n    var k = a.jsPlumbInstance.makeDynamicAnchor(j);\n    return k.type = \"Perimeter\", k;\n  };\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this,\n      b = a.jsPlumb,\n      c = a.jsPlumbUtil,\n      d = a.Biltong;\n  b.Segments = {\n    AbstractSegment: function AbstractSegment(a) {\n      this.params = a, this.findClosestPointOnPath = function (a, b) {\n        return {\n          d: 1 / 0,\n          x: null,\n          y: null,\n          l: null\n        };\n      }, this.getBounds = function () {\n        return {\n          minX: Math.min(a.x1, a.x2),\n          minY: Math.min(a.y1, a.y2),\n          maxX: Math.max(a.x1, a.x2),\n          maxY: Math.max(a.y1, a.y2)\n        };\n      }, this.lineIntersection = function (a, b, c, d) {\n        return [];\n      }, this.boxIntersection = function (a, b, c, d) {\n        var e = [];\n        return e.push.apply(e, this.lineIntersection(a, b, a + c, b)), e.push.apply(e, this.lineIntersection(a + c, b, a + c, b + d)), e.push.apply(e, this.lineIntersection(a + c, b + d, a, b + d)), e.push.apply(e, this.lineIntersection(a, b + d, a, b)), e;\n      }, this.boundingBoxIntersection = function (a) {\n        return this.boxIntersection(a.x, a.y, a.w, a.y);\n      };\n    },\n    Straight: function Straight(a) {\n      var c,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = (b.Segments.AbstractSegment.apply(this, arguments), function () {\n        c = Math.sqrt(Math.pow(h - g, 2) + Math.pow(j - i, 2)), e = d.gradient({\n          x: g,\n          y: i\n        }, {\n          x: h,\n          y: j\n        }), f = -1 / e;\n      });\n      this.type = \"Straight\", this.getLength = function () {\n        return c;\n      }, this.getGradient = function () {\n        return e;\n      }, this.getCoordinates = function () {\n        return {\n          x1: g,\n          y1: i,\n          x2: h,\n          y2: j\n        };\n      }, this.setCoordinates = function (a) {\n        g = a.x1, i = a.y1, h = a.x2, j = a.y2, k();\n      }, this.setCoordinates({\n        x1: a.x1,\n        y1: a.y1,\n        x2: a.x2,\n        y2: a.y2\n      }), this.getBounds = function () {\n        return {\n          minX: Math.min(g, h),\n          minY: Math.min(i, j),\n          maxX: Math.max(g, h),\n          maxY: Math.max(i, j)\n        };\n      }, this.pointOnPath = function (a, b) {\n        if (0 !== a || b) {\n          if (1 !== a || b) {\n            var e = b ? a > 0 ? a : c + a : a * c;\n            return d.pointOnLine({\n              x: g,\n              y: i\n            }, {\n              x: h,\n              y: j\n            }, e);\n          }\n\n          return {\n            x: h,\n            y: j\n          };\n        }\n\n        return {\n          x: g,\n          y: i\n        };\n      }, this.gradientAtPoint = function (a) {\n        return e;\n      }, this.pointAlongPathFrom = function (a, b, c) {\n        var e = this.pointOnPath(a, c),\n            f = 0 >= b ? {\n          x: g,\n          y: i\n        } : {\n          x: h,\n          y: j\n        };\n        return 0 >= b && Math.abs(b) > 1 && (b *= -1), d.pointOnLine(e, f, b);\n      };\n\n      var l = function l(a, b, c) {\n        return c >= Math.min(a, b) && c <= Math.max(a, b);\n      },\n          m = function m(a, b, c) {\n        return Math.abs(c - a) < Math.abs(c - b) ? a : b;\n      };\n\n      this.findClosestPointOnPath = function (a, b) {\n        var k = {\n          d: 1 / 0,\n          x: null,\n          y: null,\n          l: null,\n          x1: g,\n          x2: h,\n          y1: i,\n          y2: j\n        };\n        if (0 === e) k.y = i, k.x = l(g, h, a) ? a : m(g, h, a);else if (e === 1 / 0 || e === -(1 / 0)) k.x = g, k.y = l(i, j, b) ? b : m(i, j, b);else {\n          var n = i - e * g,\n              o = b - f * a,\n              p = (o - n) / (e - f),\n              q = e * p + n;\n          k.x = l(g, h, p) ? p : m(g, h, p), k.y = l(i, j, q) ? q : m(i, j, q);\n        }\n        var r = d.lineLength([k.x, k.y], [g, i]);\n        return k.d = d.lineLength([a, b], [k.x, k.y]), k.l = r / c, k;\n      };\n\n      var n = function n(a, b, c) {\n        return c > b ? a >= b && c >= a : b >= a && a >= c;\n      },\n          o = n;\n\n      this.lineIntersection = function (a, b, c, f) {\n        var k = Math.abs(d.gradient({\n          x: a,\n          y: b\n        }, {\n          x: c,\n          y: f\n        })),\n            l = Math.abs(e),\n            m = l === 1 / 0 ? g : i - l * g,\n            n = [],\n            p = k === 1 / 0 ? a : b - k * a;\n        if (k !== l) if (k === 1 / 0 && 0 === l) o(a, g, h) && o(i, b, f) && (n = [a, i]);else if (0 === k && l === 1 / 0) o(b, i, j) && o(g, a, c) && (n = [g, b]);else {\n          var q, r;\n          k === 1 / 0 ? (q = a, o(q, g, h) && (r = l * a + m, o(r, b, f) && (n = [q, r]))) : 0 === k ? (r = b, o(r, i, j) && (q = (b - m) / l, o(q, a, c) && (n = [q, r]))) : (q = (p - m) / (l - k), r = l * q + m, o(q, g, h) && o(r, i, j) && (n = [q, r]));\n        }\n        return n;\n      }, this.boxIntersection = function (a, b, c, d) {\n        var e = [];\n        return e.push.apply(e, this.lineIntersection(a, b, a + c, b)), e.push.apply(e, this.lineIntersection(a + c, b, a + c, b + d)), e.push.apply(e, this.lineIntersection(a + c, b + d, a, b + d)), e.push.apply(e, this.lineIntersection(a, b + d, a, b)), e;\n      }, this.boundingBoxIntersection = function (a) {\n        return this.boxIntersection(a.x, a.y, a.w, a.h);\n      };\n    },\n    Arc: function Arc(a) {\n      var c = (b.Segments.AbstractSegment.apply(this, arguments), function (b, c) {\n        return d.theta([a.cx, a.cy], [b, c]);\n      }),\n          e = function e(a, b) {\n        if (a.anticlockwise) {\n          var c = a.startAngle < a.endAngle ? a.startAngle + f : a.startAngle,\n              d = Math.abs(c - a.endAngle);\n          return c - d * b;\n        }\n\n        var e = a.endAngle < a.startAngle ? a.endAngle + f : a.endAngle,\n            g = Math.abs(e - a.startAngle);\n        return a.startAngle + g * b;\n      },\n          f = 2 * Math.PI;\n\n      this.radius = a.r, this.anticlockwise = a.ac, this.type = \"Arc\", a.startAngle && a.endAngle ? (this.startAngle = a.startAngle, this.endAngle = a.endAngle, this.x1 = a.cx + this.radius * Math.cos(a.startAngle), this.y1 = a.cy + this.radius * Math.sin(a.startAngle), this.x2 = a.cx + this.radius * Math.cos(a.endAngle), this.y2 = a.cy + this.radius * Math.sin(a.endAngle)) : (this.startAngle = c(a.x1, a.y1), this.endAngle = c(a.x2, a.y2), this.x1 = a.x1, this.y1 = a.y1, this.x2 = a.x2, this.y2 = a.y2), this.endAngle < 0 && (this.endAngle += f), this.startAngle < 0 && (this.startAngle += f);\n      var g = this.endAngle < this.startAngle ? this.endAngle + f : this.endAngle;\n      this.sweep = Math.abs(g - this.startAngle), this.anticlockwise && (this.sweep = f - this.sweep);\n      var h = 2 * Math.PI * this.radius,\n          i = this.sweep / f,\n          j = h * i;\n      this.getLength = function () {\n        return j;\n      }, this.getBounds = function () {\n        return {\n          minX: a.cx - a.r,\n          maxX: a.cx + a.r,\n          minY: a.cy - a.r,\n          maxY: a.cy + a.r\n        };\n      };\n\n      var k = 1e-10,\n          l = function l(a) {\n        var b = Math.floor(a),\n            c = Math.ceil(a);\n        return k > a - b ? b : k > c - a ? c : a;\n      };\n\n      this.pointOnPath = function (b, c) {\n        if (0 === b) return {\n          x: this.x1,\n          y: this.y1,\n          theta: this.startAngle\n        };\n        if (1 === b) return {\n          x: this.x2,\n          y: this.y2,\n          theta: this.endAngle\n        };\n        c && (b /= j);\n        var d = e(this, b),\n            f = a.cx + a.r * Math.cos(d),\n            g = a.cy + a.r * Math.sin(d);\n        return {\n          x: l(f),\n          y: l(g),\n          theta: d\n        };\n      }, this.gradientAtPoint = function (b, c) {\n        var e = this.pointOnPath(b, c),\n            f = d.normal([a.cx, a.cy], [e.x, e.y]);\n        return this.anticlockwise || f !== 1 / 0 && f !== -(1 / 0) || (f *= -1), f;\n      }, this.pointAlongPathFrom = function (b, c, d) {\n        var e = this.pointOnPath(b, d),\n            f = c / h * 2 * Math.PI,\n            g = this.anticlockwise ? -1 : 1,\n            i = e.theta + g * f,\n            j = a.cx + this.radius * Math.cos(i),\n            k = a.cy + this.radius * Math.sin(i);\n        return {\n          x: j,\n          y: k\n        };\n      };\n    },\n    Bezier: function Bezier(c) {\n      this.curve = [{\n        x: c.x1,\n        y: c.y1\n      }, {\n        x: c.cp1x,\n        y: c.cp1y\n      }, {\n        x: c.cp2x,\n        y: c.cp2y\n      }, {\n        x: c.x2,\n        y: c.y2\n      }];\n      b.Segments.AbstractSegment.apply(this, arguments);\n      this.bounds = {\n        minX: Math.min(c.x1, c.x2, c.cp1x, c.cp2x),\n        minY: Math.min(c.y1, c.y2, c.cp1y, c.cp2y),\n        maxX: Math.max(c.x1, c.x2, c.cp1x, c.cp2x),\n        maxY: Math.max(c.y1, c.y2, c.cp1y, c.cp2y)\n      }, this.type = \"Bezier\";\n\n      var d = function d(b, c, _d6) {\n        return _d6 && (c = a.jsBezier.locationAlongCurveFrom(b, c > 0 ? 0 : 1, c)), c;\n      };\n\n      this.pointOnPath = function (b, c) {\n        return b = d(this.curve, b, c), a.jsBezier.pointOnCurve(this.curve, b);\n      }, this.gradientAtPoint = function (b, c) {\n        return b = d(this.curve, b, c), a.jsBezier.gradientAtPoint(this.curve, b);\n      }, this.pointAlongPathFrom = function (b, c, e) {\n        return b = d(this.curve, b, e), a.jsBezier.pointAlongCurveFrom(this.curve, b, c);\n      }, this.getLength = function () {\n        return a.jsBezier.getLength(this.curve);\n      }, this.getBounds = function () {\n        return this.bounds;\n      }, this.findClosestPointOnPath = function (b, c) {\n        var d = a.jsBezier.nearestPointOnCurve({\n          x: b,\n          y: c\n        }, this.curve);\n        return {\n          d: Math.sqrt(Math.pow(d.point.x - b, 2) + Math.pow(d.point.y - c, 2)),\n          x: d.point.x,\n          y: d.point.y,\n          l: 1 - d.location,\n          s: this\n        };\n      }, this.lineIntersection = function (b, c, d, e) {\n        return a.jsBezier.lineIntersection(b, c, d, e, this.curve);\n      };\n    }\n  }, b.SegmentRenderer = {\n    getPath: function getPath(a, b) {\n      return {\n        Straight: function Straight(b) {\n          var c = a.getCoordinates();\n          return (b ? \"M \" + c.x1 + \" \" + c.y1 + \" \" : \"\") + \"L \" + c.x2 + \" \" + c.y2;\n        },\n        Bezier: function Bezier(b) {\n          var c = a.params;\n          return (b ? \"M \" + c.x2 + \" \" + c.y2 + \" \" : \"\") + \"C \" + c.cp2x + \" \" + c.cp2y + \" \" + c.cp1x + \" \" + c.cp1y + \" \" + c.x1 + \" \" + c.y1;\n        },\n        Arc: function Arc(b) {\n          var c = a.params,\n              d = a.sweep > Math.PI ? 1 : 0,\n              e = a.anticlockwise ? 0 : 1;\n          return (b ? \"M\" + a.x1 + \" \" + a.y1 + \" \" : \"\") + \"A \" + a.radius + \" \" + c.r + \" 0 \" + d + \",\" + e + \" \" + a.x2 + \" \" + a.y2;\n        }\n      }[a.type](b);\n    }\n  };\n\n  var e = function e() {\n    this.resetBounds = function () {\n      this.bounds = {\n        minX: 1 / 0,\n        minY: 1 / 0,\n        maxX: -(1 / 0),\n        maxY: -(1 / 0)\n      };\n    }, this.resetBounds();\n  };\n\n  b.Connectors.AbstractConnector = function (a) {\n    e.apply(this, arguments);\n    var f = [],\n        g = 0,\n        h = [],\n        i = [],\n        j = a.stub || 0,\n        k = c.isArray(j) ? j[0] : j,\n        l = c.isArray(j) ? j[1] : j,\n        m = a.gap || 0,\n        n = c.isArray(m) ? m[0] : m,\n        o = c.isArray(m) ? m[1] : m,\n        p = null,\n        q = null;\n    this.getPathData = function () {\n      for (var a = \"\", c = 0; c < f.length; c++) {\n        a += b.SegmentRenderer.getPath(f[c], 0 === c), a += \" \";\n      }\n\n      return a;\n    }, this.findSegmentForPoint = function (a, b) {\n      for (var c = {\n        d: 1 / 0,\n        s: null,\n        x: null,\n        y: null,\n        l: null\n      }, d = 0; d < f.length; d++) {\n        var e = f[d].findClosestPointOnPath(a, b);\n        e.d < c.d && (c.d = e.d, c.l = e.l, c.x = e.x, c.y = e.y, c.s = f[d], c.x1 = e.x1, c.x2 = e.x2, c.y1 = e.y1, c.y2 = e.y2, c.index = d, c.connectorLocation = h[d][0] + e.l * (h[d][1] - h[d][0]));\n      }\n\n      return c;\n    }, this.lineIntersection = function (a, b, c, d) {\n      for (var e = [], g = 0; g < f.length; g++) {\n        e.push.apply(e, f[g].lineIntersection(a, b, c, d));\n      }\n\n      return e;\n    }, this.boxIntersection = function (a, b, c, d) {\n      for (var e = [], g = 0; g < f.length; g++) {\n        e.push.apply(e, f[g].boxIntersection(a, b, c, d));\n      }\n\n      return e;\n    }, this.boundingBoxIntersection = function (a) {\n      for (var b = [], c = 0; c < f.length; c++) {\n        b.push.apply(b, f[c].boundingBoxIntersection(a));\n      }\n\n      return b;\n    };\n\n    var r = function r() {\n      for (var a = 0, b = 0; b < f.length; b++) {\n        var c = f[b].getLength();\n        i[b] = c / g, h[b] = [a, a += c / g];\n      }\n    },\n        s = function s(a, b) {\n      b && (a = a > 0 ? a / g : (g + a) / g);\n\n      for (var c = h.length - 1, d = 1, e = 0; e < h.length; e++) {\n        if (h[e][1] >= a) {\n          c = e, d = 1 === a ? 1 : 0 === a ? 0 : (a - h[e][0]) / i[e];\n          break;\n        }\n      }\n\n      return {\n        segment: f[c],\n        proportion: d,\n        index: c\n      };\n    },\n        t = function t(a, c, d) {\n      if (d.x1 !== d.x2 || d.y1 !== d.y2) {\n        var e = new b.Segments[c](d);\n        f.push(e), g += e.getLength(), a.updateBounds(e);\n      }\n    },\n        u = function u() {\n      g = f.length = h.length = i.length = 0;\n    };\n\n    this.setSegments = function (a) {\n      p = [], g = 0;\n\n      for (var b = 0; b < a.length; b++) {\n        p.push(a[b]), g += a[b].getLength();\n      }\n    }, this.getLength = function () {\n      return g;\n    };\n\n    var v = function v(a) {\n      this.strokeWidth = a.strokeWidth;\n      var b = d.quadrant(a.sourcePos, a.targetPos),\n          c = a.targetPos[0] < a.sourcePos[0],\n          e = a.targetPos[1] < a.sourcePos[1],\n          f = a.strokeWidth || 1,\n          g = a.sourceEndpoint.anchor.getOrientation(a.sourceEndpoint),\n          h = a.targetEndpoint.anchor.getOrientation(a.targetEndpoint),\n          i = c ? a.targetPos[0] : a.sourcePos[0],\n          j = e ? a.targetPos[1] : a.sourcePos[1],\n          m = Math.abs(a.targetPos[0] - a.sourcePos[0]),\n          p = Math.abs(a.targetPos[1] - a.sourcePos[1]);\n\n      if (0 === g[0] && 0 === g[1] || 0 === h[0] && 0 === h[1]) {\n        var q = m > p ? 0 : 1,\n            r = [1, 0][q];\n        g = [], h = [], g[q] = a.sourcePos[q] > a.targetPos[q] ? -1 : 1, h[q] = a.sourcePos[q] > a.targetPos[q] ? 1 : -1, g[r] = 0, h[r] = 0;\n      }\n\n      var s = c ? m + n * g[0] : n * g[0],\n          t = e ? p + n * g[1] : n * g[1],\n          u = c ? o * h[0] : m + o * h[0],\n          v = e ? o * h[1] : p + o * h[1],\n          w = g[0] * h[0] + g[1] * h[1],\n          x = {\n        sx: s,\n        sy: t,\n        tx: u,\n        ty: v,\n        lw: f,\n        xSpan: Math.abs(u - s),\n        ySpan: Math.abs(v - t),\n        mx: (s + u) / 2,\n        my: (t + v) / 2,\n        so: g,\n        to: h,\n        x: i,\n        y: j,\n        w: m,\n        h: p,\n        segment: b,\n        startStubX: s + g[0] * k,\n        startStubY: t + g[1] * k,\n        endStubX: u + h[0] * l,\n        endStubY: v + h[1] * l,\n        isXGreaterThanStubTimes2: Math.abs(s - u) > k + l,\n        isYGreaterThanStubTimes2: Math.abs(t - v) > k + l,\n        opposite: -1 === w,\n        perpendicular: 0 === w,\n        orthogonal: 1 === w,\n        sourceAxis: 0 === g[0] ? \"y\" : \"x\",\n        points: [i, j, m, p, s, t, u, v],\n        stubs: [k, l]\n      };\n      return x.anchorOrientation = x.opposite ? \"opposite\" : x.orthogonal ? \"orthogonal\" : \"perpendicular\", x;\n    };\n\n    this.getSegments = function () {\n      return f;\n    }, this.updateBounds = function (a) {\n      var b = a.getBounds();\n      this.bounds.minX = Math.min(this.bounds.minX, b.minX), this.bounds.maxX = Math.max(this.bounds.maxX, b.maxX), this.bounds.minY = Math.min(this.bounds.minY, b.minY), this.bounds.maxY = Math.max(this.bounds.maxY, b.maxY);\n    };\n    return this.pointOnPath = function (a, b) {\n      var c = s(a, b);\n      return c.segment && c.segment.pointOnPath(c.proportion, !1) || [0, 0];\n    }, this.gradientAtPoint = function (a, b) {\n      var c = s(a, b);\n      return c.segment && c.segment.gradientAtPoint(c.proportion, !1) || 0;\n    }, this.pointAlongPathFrom = function (a, b, c) {\n      var d = s(a, c);\n      return d.segment && d.segment.pointAlongPathFrom(d.proportion, b, !1) || [0, 0];\n    }, this.compute = function (a) {\n      q = v.call(this, a), u(), this._compute(q, a), this.x = q.points[0], this.y = q.points[1], this.w = q.points[2], this.h = q.points[3], this.segment = q.segment, r();\n    }, {\n      addSegment: t,\n      prepareCompute: v,\n      sourceStub: k,\n      targetStub: l,\n      maxStub: Math.max(k, l),\n      sourceGap: n,\n      targetGap: o,\n      maxGap: Math.max(n, o)\n    };\n  }, c.extend(b.Connectors.AbstractConnector, e), b.Endpoints.AbstractEndpoint = function (a) {\n    e.apply(this, arguments);\n\n    var b = this.compute = function (a, b, c, d) {\n      var e = this._compute.apply(this, arguments);\n\n      return this.x = e[0], this.y = e[1], this.w = e[2], this.h = e[3], this.bounds.minX = this.x, this.bounds.minY = this.y, this.bounds.maxX = this.x + this.w, this.bounds.maxY = this.y + this.h, e;\n    };\n\n    return {\n      compute: b,\n      cssClass: a.cssClass\n    };\n  }, c.extend(b.Endpoints.AbstractEndpoint, e), b.Endpoints.Dot = function (a) {\n    this.type = \"Dot\";\n    b.Endpoints.AbstractEndpoint.apply(this, arguments);\n    a = a || {}, this.radius = a.radius || 10, this.defaultOffset = .5 * this.radius, this.defaultInnerRadius = this.radius / 3, this._compute = function (a, b, c, d) {\n      this.radius = c.radius || this.radius;\n      var e = a[0] - this.radius,\n          f = a[1] - this.radius,\n          g = 2 * this.radius,\n          h = 2 * this.radius;\n\n      if (c.stroke) {\n        var i = c.strokeWidth || 1;\n        e -= i, f -= i, g += 2 * i, h += 2 * i;\n      }\n\n      return [e, f, g, h, this.radius];\n    };\n  }, c.extend(b.Endpoints.Dot, b.Endpoints.AbstractEndpoint), b.Endpoints.Rectangle = function (a) {\n    this.type = \"Rectangle\";\n    b.Endpoints.AbstractEndpoint.apply(this, arguments);\n    a = a || {}, this.width = a.width || 20, this.height = a.height || 20, this._compute = function (a, b, c, d) {\n      var e = c.width || this.width,\n          f = c.height || this.height,\n          g = a[0] - e / 2,\n          h = a[1] - f / 2;\n      return [g, h, e, f];\n    };\n  }, c.extend(b.Endpoints.Rectangle, b.Endpoints.AbstractEndpoint);\n\n  var f = function f(a) {\n    b.jsPlumbUIComponent.apply(this, arguments), this._jsPlumb.displayElements = [];\n  };\n\n  c.extend(f, b.jsPlumbUIComponent, {\n    getDisplayElements: function getDisplayElements() {\n      return this._jsPlumb.displayElements;\n    },\n    appendDisplayElement: function appendDisplayElement(a) {\n      this._jsPlumb.displayElements.push(a);\n    }\n  }), b.Endpoints.Image = function (d) {\n    this.type = \"Image\", f.apply(this, arguments), b.Endpoints.AbstractEndpoint.apply(this, arguments);\n    var e = d.onload,\n        g = d.src || d.url,\n        h = d.cssClass ? \" \" + d.cssClass : \"\";\n    this._jsPlumb.img = new Image(), this._jsPlumb.ready = !1, this._jsPlumb.initialized = !1, this._jsPlumb.deleted = !1, this._jsPlumb.widthToUse = d.width, this._jsPlumb.heightToUse = d.height, this._jsPlumb.endpoint = d.endpoint, this._jsPlumb.img.onload = function () {\n      null != this._jsPlumb && (this._jsPlumb.ready = !0, this._jsPlumb.widthToUse = this._jsPlumb.widthToUse || this._jsPlumb.img.width, this._jsPlumb.heightToUse = this._jsPlumb.heightToUse || this._jsPlumb.img.height, e && e(this));\n    }.bind(this), this._jsPlumb.endpoint.setImage = function (a, b) {\n      var c = a.constructor === String ? a : a.src;\n      e = b, this._jsPlumb.img.src = c, null != this.canvas && this.canvas.setAttribute(\"src\", this._jsPlumb.img.src);\n    }.bind(this), this._jsPlumb.endpoint.setImage(g, e), this._compute = function (a, b, c, d) {\n      return this.anchorPoint = a, this._jsPlumb.ready ? [a[0] - this._jsPlumb.widthToUse / 2, a[1] - this._jsPlumb.heightToUse / 2, this._jsPlumb.widthToUse, this._jsPlumb.heightToUse] : [0, 0, 0, 0];\n    }, this.canvas = b.createElement(\"img\", {\n      position: \"absolute\",\n      margin: 0,\n      padding: 0,\n      outline: 0\n    }, this._jsPlumb.instance.endpointClass + h), this._jsPlumb.widthToUse && this.canvas.setAttribute(\"width\", this._jsPlumb.widthToUse), this._jsPlumb.heightToUse && this.canvas.setAttribute(\"height\", this._jsPlumb.heightToUse), this._jsPlumb.instance.appendElement(this.canvas), this.actuallyPaint = function (a, b, d) {\n      if (!this._jsPlumb.deleted) {\n        this._jsPlumb.initialized || (this.canvas.setAttribute(\"src\", this._jsPlumb.img.src), this.appendDisplayElement(this.canvas), this._jsPlumb.initialized = !0);\n        var e = this.anchorPoint[0] - this._jsPlumb.widthToUse / 2,\n            f = this.anchorPoint[1] - this._jsPlumb.heightToUse / 2;\n        c.sizeElement(this.canvas, e, f, this._jsPlumb.widthToUse, this._jsPlumb.heightToUse);\n      }\n    }, this.paint = function (b, c) {\n      null != this._jsPlumb && (this._jsPlumb.ready ? this.actuallyPaint(b, c) : a.setTimeout(function () {\n        this.paint(b, c);\n      }.bind(this), 200));\n    };\n  }, c.extend(b.Endpoints.Image, [f, b.Endpoints.AbstractEndpoint], {\n    cleanup: function cleanup(a) {\n      a && (this._jsPlumb.deleted = !0, this.canvas && this.canvas.parentNode.removeChild(this.canvas), this.canvas = null);\n    }\n  }), b.Endpoints.Blank = function (a) {\n    b.Endpoints.AbstractEndpoint.apply(this, arguments);\n    this.type = \"Blank\", f.apply(this, arguments), this._compute = function (a, b, c, d) {\n      return [a[0], a[1], 10, 0];\n    };\n    var d = a.cssClass ? \" \" + a.cssClass : \"\";\n    this.canvas = b.createElement(\"div\", {\n      display: \"block\",\n      width: \"1px\",\n      height: \"1px\",\n      background: \"transparent\",\n      position: \"absolute\"\n    }, this._jsPlumb.instance.endpointClass + d), this._jsPlumb.instance.appendElement(this.canvas), this.paint = function (a, b) {\n      c.sizeElement(this.canvas, this.x, this.y, this.w, this.h);\n    };\n  }, c.extend(b.Endpoints.Blank, [b.Endpoints.AbstractEndpoint, f], {\n    cleanup: function cleanup() {\n      this.canvas && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);\n    }\n  }), b.Endpoints.Triangle = function (a) {\n    this.type = \"Triangle\", b.Endpoints.AbstractEndpoint.apply(this, arguments);\n    var c = this;\n    a = a || {}, a.width = a.width || 55, a.height = a.height || 55, this.width = a.width, this.height = a.height, this._compute = function (a, b, d, e) {\n      var f = d.width || c.width,\n          g = d.height || c.height,\n          h = a[0] - f / 2,\n          i = a[1] - g / 2;\n      return [h, i, f, g];\n    };\n  };\n\n  var g = b.Overlays.AbstractOverlay = function (a) {\n    this.visible = !0, this.isAppendedAtTopLevel = !0, this.component = a.component, this.loc = null == a.location ? .5 : a.location, this.endpointLoc = null == a.endpointLocation ? [.5, .5] : a.endpointLocation, this.visible = a.visible !== !1;\n  };\n\n  g.prototype = {\n    cleanup: function cleanup(a) {\n      a && (this.component = null, this.canvas = null, this.endpointLoc = null);\n    },\n    reattach: function reattach(a, b) {},\n    setVisible: function setVisible(a) {\n      this.visible = a, this.component.repaint();\n    },\n    isVisible: function isVisible() {\n      return this.visible;\n    },\n    hide: function hide() {\n      this.setVisible(!1);\n    },\n    show: function show() {\n      this.setVisible(!0);\n    },\n    incrementLocation: function incrementLocation(a) {\n      this.loc += a, this.component.repaint();\n    },\n    setLocation: function setLocation(a) {\n      this.loc = a, this.component.repaint();\n    },\n    getLocation: function getLocation() {\n      return this.loc;\n    },\n    updateFrom: function updateFrom() {}\n  }, b.Overlays.Arrow = function (a) {\n    this.type = \"Arrow\", g.apply(this, arguments), this.isAppendedAtTopLevel = !1, a = a || {};\n    var e = this;\n    this.length = a.length || 20, this.width = a.width || 20, this.id = a.id, this.direction = (a.direction || 1) < 0 ? -1 : 1;\n    var f = a.paintStyle || {\n      \"stroke-width\": 1\n    },\n        h = a.foldback || .623;\n    this.computeMaxSize = function () {\n      return 1.5 * e.width;\n    }, this.elementCreated = function (c, d) {\n      if (this.path = c, a.events) for (var e in a.events) {\n        b.on(c, e, a.events[e]);\n      }\n    }, this.draw = function (a, b) {\n      var e, g, i, j, k;\n\n      if (a.pointAlongPathFrom) {\n        if (c.isString(this.loc) || this.loc > 1 || this.loc < 0) {\n          var l = parseInt(this.loc, 10),\n              m = this.loc < 0 ? 1 : 0;\n          e = a.pointAlongPathFrom(m, l, !1), g = a.pointAlongPathFrom(m, l - this.direction * this.length / 2, !1), i = d.pointOnLine(e, g, this.length);\n        } else if (1 === this.loc) {\n          if (e = a.pointOnPath(this.loc), g = a.pointAlongPathFrom(this.loc, -this.length), i = d.pointOnLine(e, g, this.length), -1 === this.direction) {\n            var n = i;\n            i = e, e = n;\n          }\n        } else if (0 === this.loc) {\n          if (i = a.pointOnPath(this.loc), g = a.pointAlongPathFrom(this.loc, this.length), e = d.pointOnLine(i, g, this.length), -1 === this.direction) {\n            var o = i;\n            i = e, e = o;\n          }\n        } else e = a.pointAlongPathFrom(this.loc, this.direction * this.length / 2), g = a.pointOnPath(this.loc), i = d.pointOnLine(e, g, this.length);\n\n        j = d.perpendicularLineTo(e, i, this.width), k = d.pointOnLine(e, i, h * this.length);\n        var p = {\n          hxy: e,\n          tail: j,\n          cxy: k\n        },\n            q = f.stroke || b.stroke,\n            r = f.fill || b.stroke,\n            s = f.strokeWidth || b.strokeWidth;\n        return {\n          component: a,\n          d: p,\n          \"stroke-width\": s,\n          stroke: q,\n          fill: r,\n          minX: Math.min(e.x, j[0].x, j[1].x),\n          maxX: Math.max(e.x, j[0].x, j[1].x),\n          minY: Math.min(e.y, j[0].y, j[1].y),\n          maxY: Math.max(e.y, j[0].y, j[1].y)\n        };\n      }\n\n      return {\n        component: a,\n        minX: 0,\n        maxX: 0,\n        minY: 0,\n        maxY: 0\n      };\n    };\n  }, c.extend(b.Overlays.Arrow, g, {\n    updateFrom: function updateFrom(a) {\n      this.length = a.length || this.length, this.width = a.width || this.width, this.direction = null != a.direction ? a.direction : this.direction, this.foldback = a.foldback || this.foldback;\n    },\n    cleanup: function cleanup() {\n      this.path && this.canvas && this.canvas.removeChild(this.path);\n    }\n  }), b.Overlays.PlainArrow = function (a) {\n    a = a || {};\n    var c = b.extend(a, {\n      foldback: 1\n    });\n    b.Overlays.Arrow.call(this, c), this.type = \"PlainArrow\";\n  }, c.extend(b.Overlays.PlainArrow, b.Overlays.Arrow), b.Overlays.Diamond = function (a) {\n    a = a || {};\n    var c = a.length || 40,\n        d = b.extend(a, {\n      length: c / 2,\n      foldback: 2\n    });\n    b.Overlays.Arrow.call(this, d), this.type = \"Diamond\";\n  }, c.extend(b.Overlays.Diamond, b.Overlays.Arrow);\n\n  var h = function h(a, b) {\n    return (null == a._jsPlumb.cachedDimensions || b) && (a._jsPlumb.cachedDimensions = a.getDimensions()), a._jsPlumb.cachedDimensions;\n  },\n      i = function i(a) {\n    b.jsPlumbUIComponent.apply(this, arguments), g.apply(this, arguments);\n    var d = this.fire;\n    this.fire = function () {\n      d.apply(this, arguments), this.component && this.component.fire.apply(this.component, arguments);\n    }, this.detached = !1, this.id = a.id, this._jsPlumb.div = null, this._jsPlumb.initialised = !1, this._jsPlumb.component = a.component, this._jsPlumb.cachedDimensions = null, this._jsPlumb.create = a.create, this._jsPlumb.initiallyInvisible = a.visible === !1, this.getElement = function () {\n      if (null == this._jsPlumb.div) {\n        var c = this._jsPlumb.div = b.getElement(this._jsPlumb.create(this._jsPlumb.component));\n        c.style.position = \"absolute\", jsPlumb.addClass(c, this._jsPlumb.instance.overlayClass + \" \" + (this.cssClass ? this.cssClass : a.cssClass ? a.cssClass : \"\")), this._jsPlumb.instance.appendElement(c), this._jsPlumb.instance.getId(c), this.canvas = c;\n        var d = \"translate(-50%, -50%)\";\n        c.style.webkitTransform = d, c.style.mozTransform = d, c.style.msTransform = d, c.style.oTransform = d, c.style.transform = d, c._jsPlumb = this, a.visible === !1 && (c.style.display = \"none\");\n      }\n\n      return this._jsPlumb.div;\n    }, this.draw = function (a, b, d) {\n      var e = h(this);\n\n      if (null != e && 2 === e.length) {\n        var f = {\n          x: 0,\n          y: 0\n        };\n        if (d) f = {\n          x: d[0],\n          y: d[1]\n        };else if (a.pointOnPath) {\n          var g = this.loc,\n              i = !1;\n          (c.isString(this.loc) || this.loc < 0 || this.loc > 1) && (g = parseInt(this.loc, 10), i = !0), f = a.pointOnPath(g, i);\n        } else {\n          var j = this.loc.constructor === Array ? this.loc : this.endpointLoc;\n          f = {\n            x: j[0] * a.w,\n            y: j[1] * a.h\n          };\n        }\n        var k = f.x - e[0] / 2,\n            l = f.y - e[1] / 2;\n        return {\n          component: a,\n          d: {\n            minx: k,\n            miny: l,\n            td: e,\n            cxy: f\n          },\n          minX: k,\n          maxX: k + e[0],\n          minY: l,\n          maxY: l + e[1]\n        };\n      }\n\n      return {\n        minX: 0,\n        maxX: 0,\n        minY: 0,\n        maxY: 0\n      };\n    };\n  };\n\n  c.extend(i, [b.jsPlumbUIComponent, g], {\n    getDimensions: function getDimensions() {\n      return [1, 1];\n    },\n    setVisible: function setVisible(a) {\n      this._jsPlumb.div && (this._jsPlumb.div.style.display = a ? \"block\" : \"none\", a && this._jsPlumb.initiallyInvisible && (h(this, !0), this.component.repaint(), this._jsPlumb.initiallyInvisible = !1));\n    },\n    clearCachedDimensions: function clearCachedDimensions() {\n      this._jsPlumb.cachedDimensions = null;\n    },\n    cleanup: function cleanup(a) {\n      a ? null != this._jsPlumb.div && (this._jsPlumb.div._jsPlumb = null, this._jsPlumb.instance.removeElement(this._jsPlumb.div)) : (this._jsPlumb && this._jsPlumb.div && this._jsPlumb.div.parentNode && this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div), this.detached = !0);\n    },\n    reattach: function reattach(a, b) {\n      null != this._jsPlumb.div && a.getContainer().appendChild(this._jsPlumb.div), this.detached = !1;\n    },\n    computeMaxSize: function computeMaxSize() {\n      var a = h(this);\n      return Math.max(a[0], a[1]);\n    },\n    paint: function paint(a, b) {\n      this._jsPlumb.initialised || (this.getElement(), a.component.appendDisplayElement(this._jsPlumb.div), this._jsPlumb.initialised = !0, this.detached && this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div)), this._jsPlumb.div.style.left = a.component.x + a.d.minx + \"px\", this._jsPlumb.div.style.top = a.component.y + a.d.miny + \"px\";\n    }\n  }), b.Overlays.Custom = function (a) {\n    this.type = \"Custom\", i.apply(this, arguments);\n  }, c.extend(b.Overlays.Custom, i), b.Overlays.GuideLines = function () {\n    var a = this;\n    a.length = 50, a.strokeWidth = 5, this.type = \"GuideLines\", g.apply(this, arguments), b.jsPlumbUIComponent.apply(this, arguments), this.draw = function (b, c) {\n      var e = b.pointAlongPathFrom(a.loc, a.length / 2),\n          f = b.pointOnPath(a.loc),\n          g = d.pointOnLine(e, f, a.length),\n          h = d.perpendicularLineTo(e, g, 40),\n          i = d.perpendicularLineTo(g, e, 20);\n      return {\n        connector: b,\n        head: e,\n        tail: g,\n        headLine: i,\n        tailLine: h,\n        minX: Math.min(e.x, g.x, i[0].x, i[1].x),\n        minY: Math.min(e.y, g.y, i[0].y, i[1].y),\n        maxX: Math.max(e.x, g.x, i[0].x, i[1].x),\n        maxY: Math.max(e.y, g.y, i[0].y, i[1].y)\n      };\n    };\n  }, b.Overlays.Label = function (a) {\n    this.labelStyle = a.labelStyle;\n    this.cssClass = null != this.labelStyle ? this.labelStyle.cssClass : null;\n    var c = b.extend({\n      create: function create() {\n        return b.createElement(\"div\");\n      }\n    }, a);\n\n    if (b.Overlays.Custom.call(this, c), this.type = \"Label\", this.label = a.label || \"\", this.labelText = null, this.labelStyle) {\n      var d = this.getElement();\n\n      if (this.labelStyle.font = this.labelStyle.font || \"12px sans-serif\", d.style.font = this.labelStyle.font, d.style.color = this.labelStyle.color || \"black\", this.labelStyle.fill && (d.style.background = this.labelStyle.fill), this.labelStyle.borderWidth > 0) {\n        var e = this.labelStyle.borderStyle ? this.labelStyle.borderStyle : \"black\";\n        d.style.border = this.labelStyle.borderWidth + \"px solid \" + e;\n      }\n\n      this.labelStyle.padding && (d.style.padding = this.labelStyle.padding);\n    }\n  }, c.extend(b.Overlays.Label, b.Overlays.Custom, {\n    cleanup: function cleanup(a) {\n      a && (this.div = null, this.label = null, this.labelText = null, this.cssClass = null, this.labelStyle = null);\n    },\n    getLabel: function getLabel() {\n      return this.label;\n    },\n    setLabel: function setLabel(a) {\n      this.label = a, this.labelText = null, this.clearCachedDimensions(), this.update(), this.component.repaint();\n    },\n    getDimensions: function getDimensions() {\n      return this.update(), i.prototype.getDimensions.apply(this, arguments);\n    },\n    update: function update() {\n      if (\"function\" == typeof this.label) {\n        var a = this.label(this);\n        this.getElement().innerHTML = a.replace(/\\r\\n/g, \"<br/>\");\n      } else null == this.labelText && (this.labelText = this.label, this.getElement().innerHTML = this.labelText.replace(/\\r\\n/g, \"<br/>\"));\n    },\n    updateFrom: function updateFrom(a) {\n      null != a.label && this.setLabel(a.label);\n    }\n  });\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this,\n      b = a.jsPlumbUtil,\n      c = a.jsPlumbInstance,\n      d = \"jtk-group-collapsed\",\n      e = \"jtk-group-expanded\",\n      f = \"[jtk-group-content]\",\n      g = \"elementDraggable\",\n      h = \"stop\",\n      i = \"revert\",\n      j = \"_groupManager\",\n      k = \"_jsPlumbGroup\",\n      l = \"_jsPlumbGroupDrag\",\n      m = \"group:addMember\",\n      n = \"group:removeMember\",\n      o = \"group:add\",\n      p = \"group:remove\",\n      q = \"group:expand\",\n      r = \"group:collapse\",\n      s = \"groupDragStop\",\n      t = \"connectionMoved\",\n      u = \"internal.connectionDetached\",\n      v = \"removeAll\",\n      w = \"orphanAll\",\n      x = \"show\",\n      y = \"hide\",\n      z = function z(a) {\n    function c(a) {\n      delete a.proxies;\n      var c,\n          d = i[a.id];\n      null != d && (c = function c(b) {\n        return b.id === a.id;\n      }, b.removeWithFunction(d.connections.source, c), b.removeWithFunction(d.connections.target, c), delete i[a.id]), d = j[a.id], null != d && (c = function c(b) {\n        return b.id === a.id;\n      }, b.removeWithFunction(d.connections.source, c), b.removeWithFunction(d.connections.target, c), delete j[a.id]);\n    }\n\n    function f(b, c) {\n      for (var d = b.getMembers(), e = 0; e < d.length; e++) {\n        a[c ? x : y](d[e], !0);\n      }\n    }\n\n    function g(b) {\n      var c = b.getMembers(),\n          d = a.getConnections({\n        source: c,\n        scope: \"*\"\n      }, !0),\n          e = a.getConnections({\n        target: c,\n        scope: \"*\"\n      }, !0),\n          f = {};\n      b.connections.source.length = 0, b.connections.target.length = 0;\n\n      var g = function g(a) {\n        for (var c = 0; c < a.length; c++) {\n          f[a[c].id] || (f[a[c].id] = !0, a[c].source._jsPlumbGroup === b ? (a[c].target._jsPlumbGroup !== b && b.connections.source.push(a[c]), i[a[c].id] = b) : a[c].target._jsPlumbGroup === b && (b.connections.target.push(a[c]), j[a[c].id] = b));\n        }\n      };\n\n      g(d), g(e);\n    }\n\n    var h = {},\n        i = {},\n        j = {},\n        l = this;\n    a.bind(\"connection\", function (a) {\n      null != a.source[k] && null != a.target[k] && a.source[k] === a.target[k] ? (i[a.connection.id] = a.source[k], j[a.connection.id] = a.source[k]) : (null != a.source[k] && (b.suggest(a.source[k].connections.source, a.connection), i[a.connection.id] = a.source[k]), null != a.target[k] && (b.suggest(a.target[k].connections.target, a.connection), j[a.connection.id] = a.target[k]));\n    }), a.bind(u, function (a) {\n      c(a.connection);\n    }), a.bind(t, function (a) {\n      var b = 0 === a.index ? i : j,\n          c = b[a.connection.id];\n\n      if (c) {\n        var d = c.connections[0 === a.index ? \"source\" : \"target\"],\n            e = d.indexOf(a.connection);\n        -1 !== e && d.splice(e, 1);\n      }\n    }), this.addGroup = function (b) {\n      a.addClass(b.getEl(), e), h[b.id] = b, b.manager = this, g(b), a.fire(o, {\n        group: b\n      });\n    }, this.addToGroup = function (b, c, d) {\n      if (b = this.getGroup(b)) {\n        var e = b.getEl();\n        if (c._isJsPlumbGroup) return;\n        var f = c._jsPlumbGroup;\n\n        if (f !== b) {\n          a.removeFromDragSelection(c);\n          var g = a.getOffset(c, !0),\n              h = b.collapsed ? a.getOffset(e, !0) : a.getOffset(b.getDragArea(), !0);\n          null != f && (f.remove(c, !1, d, !1, b), l.updateConnectionsForGroup(f)), b.add(c, d);\n\n          var i = function i(a, c) {\n            var d = 0 === c ? 1 : 0;\n            a.each(function (a) {\n              a.setVisible(!1), a.endpoints[d].element._jsPlumbGroup === b ? (a.endpoints[d].setVisible(!1), s(a, d, b)) : (a.endpoints[c].setVisible(!1), n(a, c, b));\n            });\n          };\n\n          b.collapsed && (i(a.select({\n            source: c\n          }), 0), i(a.select({\n            target: c\n          }), 1));\n          var j = a.getId(c);\n          a.dragManager.setParent(c, j, e, a.getId(e), g);\n          var k = {\n            left: g.left - h.left,\n            top: g.top - h.top\n          };\n\n          if (a.setPosition(c, k), a.dragManager.revalidateParent(c, j, g), l.updateConnectionsForGroup(b), a.revalidate(j), !d) {\n            var o = {\n              group: b,\n              el: c,\n              pos: k\n            };\n            f && (o.sourceGroup = f), a.fire(m, o);\n          }\n        }\n      }\n    }, this.removeFromGroup = function (a, b, c) {\n      a = this.getGroup(a), a && a.remove(b, null, c);\n    }, this.getGroup = function (a) {\n      var c = a;\n      if (b.isString(a) && (c = h[a], null == c)) throw new TypeError(\"No such group [\" + a + \"]\");\n      return c;\n    }, this.getGroups = function () {\n      var a = [];\n\n      for (var b in h) {\n        a.push(h[b]);\n      }\n\n      return a;\n    }, this.removeGroup = function (b, c, d, e) {\n      b = this.getGroup(b), this.expandGroup(b, !0);\n      var f = b[c ? v : w](d, e);\n      return a.remove(b.getEl()), delete h[b.id], delete a._groups[b.id], a.fire(p, {\n        group: b\n      }), f;\n    }, this.removeAllGroups = function (a, b, c) {\n      for (var d in h) {\n        this.removeGroup(h[d], a, b, c);\n      }\n    };\n\n    var n = function n(b, c, d) {\n      var e = b.endpoints[0 === c ? 1 : 0].element;\n\n      if (!e[k] || e[k].shouldProxy() || !e[k].collapsed) {\n        var f = d.getEl(),\n            g = a.getId(f);\n        a.proxyConnection(b, c, f, g, function (a, b) {\n          return d.getEndpoint(a, b);\n        }, function (a, b) {\n          return d.getAnchor(a, b);\n        });\n      }\n    };\n\n    this.collapseGroup = function (b) {\n      if (b = this.getGroup(b), null != b && !b.collapsed) {\n        var c = b.getEl();\n\n        if (f(b, !1), b.shouldProxy()) {\n          var g = function g(a, c) {\n            for (var d = 0; d < a.length; d++) {\n              var e = a[d];\n              n(e, c, b);\n            }\n          };\n\n          g(b.connections.source, 0), g(b.connections.target, 1);\n        }\n\n        b.collapsed = !0, a.removeClass(c, e), a.addClass(c, d), a.revalidate(c), a.fire(r, {\n          group: b\n        });\n      }\n    };\n\n    var s = function s(b, c, d) {\n      a.unproxyConnection(b, c, a.getId(d.getEl()));\n    };\n\n    this.expandGroup = function (b, c) {\n      if (b = this.getGroup(b), null != b && b.collapsed) {\n        var g = b.getEl();\n\n        if (f(b, !0), b.shouldProxy()) {\n          var h = function h(a, c) {\n            for (var d = 0; d < a.length; d++) {\n              var e = a[d];\n              s(e, c, b);\n            }\n          };\n\n          h(b.connections.source, 0), h(b.connections.target, 1);\n        }\n\n        b.collapsed = !1, a.addClass(g, e), a.removeClass(g, d), a.revalidate(g), this.repaintGroup(b), c || a.fire(q, {\n          group: b\n        });\n      }\n    }, this.repaintGroup = function (b) {\n      b = this.getGroup(b);\n\n      for (var c = b.getMembers(), d = 0; d < c.length; d++) {\n        a.revalidate(c[d]);\n      }\n    }, this.updateConnectionsForGroup = g, this.refreshAllGroups = function () {\n      for (var b in h) {\n        g(h[b]), a.dragManager.updateOffsets(a.getId(h[b].getEl()));\n      }\n    };\n  },\n      A = function A(c, d) {\n    function e(a) {\n      return a.offsetParent;\n    }\n\n    function j(a, b) {\n      var d = e(a),\n          f = c.getSize(d),\n          g = c.getSize(a),\n          h = b[0],\n          i = h + g[0],\n          j = b[1],\n          k = j + g[1];\n      return i > 0 && h < f[0] && k > 0 && j < f[1];\n    }\n\n    function m(a) {\n      var b = c.getId(a),\n          d = c.getOffset(a);\n      return a.parentNode.removeChild(a), c.getContainer().appendChild(a), c.setPosition(a, d), q(a), c.dragManager.clearParent(a, b), [b, d];\n    }\n\n    function o(a) {\n      function b(a, b, d) {\n        var e = null;\n\n        if (!j(a, [b, d])) {\n          var f = a._jsPlumbGroup;\n          A ? c.remove(a) : e = m(a), f.remove(a);\n        }\n\n        return e;\n      }\n\n      for (var d = [], e = 0; e < a.selection.length; e++) {\n        d.push(b(a.selection[e][0], a.selection[e][1].left, a.selection[e][1].top));\n      }\n\n      return 1 === d.length ? d[0] : d;\n    }\n\n    function p(a) {\n      var b = c.getId(a);\n      c.revalidate(a), c.dragManager.revalidateParent(a, b);\n    }\n\n    function q(a) {\n      a._katavorioDrag && ((A || z) && a._katavorioDrag.off(h, o), A || z || !y || (a._katavorioDrag.off(i, p), a._katavorioDrag.setRevert(null)));\n    }\n\n    function r(a) {\n      a._katavorioDrag && ((A || z) && a._katavorioDrag.on(h, o), x && a._katavorioDrag.setConstrain(!0), w && a._katavorioDrag.setUseGhostProxy(!0), A || z || !y || (a._katavorioDrag.on(i, p), a._katavorioDrag.setRevert(function (a, b) {\n        return !j(a, b);\n      })));\n    }\n\n    var t = this,\n        u = d.el;\n    this.getEl = function () {\n      return u;\n    }, this.id = d.id || b.uuid(), u._isJsPlumbGroup = !0;\n\n    var v = this.getDragArea = function () {\n      var a = c.getSelector(u, f);\n      return a && a.length > 0 ? a[0] : u;\n    },\n        w = d.ghost === !0,\n        x = w || d.constrain === !0,\n        y = d.revert !== !1,\n        z = d.orphan === !0,\n        A = d.prune === !0,\n        B = d.dropOverride === !0,\n        C = d.proxied !== !1,\n        D = [];\n\n    if (this.connections = {\n      source: [],\n      target: [],\n      internal: []\n    }, this.getAnchor = function (a, b) {\n      return d.anchor || \"Continuous\";\n    }, this.getEndpoint = function (a, b) {\n      return d.endpoint || [\"Dot\", {\n        radius: 10\n      }];\n    }, this.collapsed = !1, d.draggable !== !1) {\n      var E = {\n        drag: function drag() {\n          for (var a = 0; a < D.length; a++) {\n            c.draw(D[a]);\n          }\n        },\n        stop: function stop(a) {\n          c.fire(s, jsPlumb.extend(a, {\n            group: t\n          }));\n        },\n        scope: l\n      };\n      d.dragOptions && a.jsPlumb.extend(E, d.dragOptions), c.draggable(d.el, E);\n    }\n\n    d.droppable !== !1 && c.droppable(d.el, {\n      drop: function drop(a) {\n        var b = a.drag.el;\n\n        if (!b._isJsPlumbGroup) {\n          var d = b._jsPlumbGroup;\n\n          if (d !== t) {\n            if (null != d && d.overrideDrop(b, t)) return;\n            c.getGroupManager().addToGroup(t, b, !1);\n          }\n        }\n      }\n    });\n\n    var F = function F(a, b) {\n      for (var c = null == a.nodeType ? a : [a], d = 0; d < c.length; d++) {\n        b(c[d]);\n      }\n    };\n\n    this.overrideDrop = function (a, b) {\n      return B && (y || A || z);\n    }, this.add = function (a, b) {\n      var d = v();\n      F(a, function (a) {\n        if (null != a._jsPlumbGroup) {\n          if (a._jsPlumbGroup === t) return;\n\n          a._jsPlumbGroup.remove(a, !0, b, !1);\n        }\n\n        a._jsPlumbGroup = t, D.push(a), c.isAlreadyDraggable(a) && r(a), a.parentNode !== d && d.appendChild(a);\n      }), c.getGroupManager().updateConnectionsForGroup(t);\n    }, this.remove = function (a, d, e, f, g) {\n      F(a, function (a) {\n        if (a._jsPlumbGroup === t) {\n          if (delete a._jsPlumbGroup, b.removeWithFunction(D, function (b) {\n            return b === a;\n          }), d) try {\n            t.getDragArea().removeChild(a);\n          } catch (f) {\n            jsPlumbUtil.log(\"Could not remove element from Group \" + f);\n          }\n\n          if (q(a), !e) {\n            var h = {\n              group: t,\n              el: a\n            };\n            g && (h.targetGroup = g), c.fire(n, h);\n          }\n        }\n      }), f || c.getGroupManager().updateConnectionsForGroup(t);\n    }, this.removeAll = function (a, b) {\n      for (var d = 0, e = D.length; e > d; d++) {\n        var f = D[0];\n        t.remove(f, a, b, !0), c.remove(f, !0);\n      }\n\n      D.length = 0, c.getGroupManager().updateConnectionsForGroup(t);\n    }, this.orphanAll = function () {\n      for (var a = {}, b = 0; b < D.length; b++) {\n        var c = m(D[b]);\n        a[c[0]] = c[1];\n      }\n\n      return D.length = 0, a;\n    }, this.getMembers = function () {\n      return D;\n    }, u[k] = this, c.bind(g, function (a) {\n      a.el._jsPlumbGroup === this && r(a.el);\n    }.bind(this)), this.shouldProxy = function () {\n      return C;\n    }, c.getGroupManager().addGroup(this);\n  };\n\n  c.prototype.addGroup = function (a) {\n    var b = this;\n    if (b._groups = b._groups || {}, null != b._groups[a.id]) throw new TypeError(\"cannot create Group [\" + a.id + \"]; a Group with that ID exists\");\n    if (null != a.el[k]) throw new TypeError(\"cannot create Group [\" + a.id + \"]; the given element is already a Group\");\n    var c = new A(b, a);\n    return b._groups[c.id] = c, a.collapsed && this.collapseGroup(c), c;\n  }, c.prototype.addToGroup = function (a, b, c) {\n    var d = function (b) {\n      var d = this.getId(b);\n      this.manage(d, b), this.getGroupManager().addToGroup(a, b, c);\n    }.bind(this);\n\n    if (Array.isArray(b)) for (var e = 0; e < b.length; e++) {\n      d(b[e]);\n    } else d(b);\n  }, c.prototype.removeFromGroup = function (a, b, c) {\n    this.getGroupManager().removeFromGroup(a, b, c);\n  }, c.prototype.removeGroup = function (a, b, c, d) {\n    return this.getGroupManager().removeGroup(a, b, c, d);\n  }, c.prototype.removeAllGroups = function (a, b, c) {\n    this.getGroupManager().removeAllGroups(a, b, c);\n  }, c.prototype.getGroup = function (a) {\n    return this.getGroupManager().getGroup(a);\n  }, c.prototype.getGroups = function () {\n    return this.getGroupManager().getGroups();\n  }, c.prototype.expandGroup = function (a) {\n    this.getGroupManager().expandGroup(a);\n  }, c.prototype.collapseGroup = function (a) {\n    this.getGroupManager().collapseGroup(a);\n  }, c.prototype.repaintGroup = function (a) {\n    this.getGroupManager().repaintGroup(a);\n  }, c.prototype.toggleGroup = function (a) {\n    a = this.getGroupManager().getGroup(a), null != a && this.getGroupManager()[a.collapsed ? \"expandGroup\" : \"collapseGroup\"](a);\n  }, c.prototype.getGroupManager = function () {\n    var a = this[j];\n    return null == a && (a = this[j] = new z(this)), a;\n  }, c.prototype.removeGroupManager = function () {\n    delete this[j];\n  }, c.prototype.getGroupFor = function (a) {\n    return a = this.getElement(a), a ? a[k] : void 0;\n  };\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this,\n      b = a.jsPlumb,\n      c = a.jsPlumbUtil,\n      d = \"Straight\",\n      e = \"Arc\",\n      f = function f(a) {\n    this.type = \"Flowchart\", a = a || {}, a.stub = null == a.stub ? 30 : a.stub;\n\n    var c,\n        f,\n        g = b.Connectors.AbstractConnector.apply(this, arguments),\n        h = null == a.midpoint ? .5 : a.midpoint,\n        i = a.alwaysRespectStubs === !0,\n        j = null,\n        k = null,\n        l = null != a.cornerRadius ? a.cornerRadius : 0,\n        m = (a.loopbackRadius || 25, function (a) {\n      return 0 > a ? -1 : 0 === a ? 0 : 1;\n    }),\n        n = function n(a) {\n      return [m(a[2] - a[0]), m(a[3] - a[1])];\n    },\n        o = function o(a, b, c, d) {\n      if (j !== b || k !== c) {\n        var e = null == j ? d.sx : j,\n            f = null == k ? d.sy : k,\n            g = e === b ? \"v\" : \"h\";\n        j = b, k = c, a.push([e, f, b, c, g]);\n      }\n    },\n        p = function p(a) {\n      return Math.sqrt(Math.pow(a[0] - a[2], 2) + Math.pow(a[1] - a[3], 2));\n    },\n        q = function q(a) {\n      var b = [];\n      return b.push.apply(b, a), b;\n    },\n        r = function r(a, b, c) {\n      for (var f, h, i, j = null, k = 0; k < b.length - 1; k++) {\n        if (j = j || q(b[k]), f = q(b[k + 1]), h = n(j), i = n(f), l > 0 && j[4] !== f[4]) {\n          var m = Math.min(p(j), p(f)),\n              o = Math.min(l, m / 2);\n          j[2] -= h[0] * o, j[3] -= h[1] * o, f[0] += i[0] * o, f[1] += i[1] * o;\n          var r = h[1] === i[0] && 1 === i[0] || h[1] === i[0] && 0 === i[0] && h[0] !== i[1] || h[1] === i[0] && -1 === i[0],\n              s = f[1] > j[3] ? 1 : -1,\n              t = f[0] > j[2] ? 1 : -1,\n              u = s === t,\n              v = u && r || !u && !r ? f[0] : j[2],\n              w = u && r || !u && !r ? j[3] : f[1];\n          g.addSegment(a, d, {\n            x1: j[0],\n            y1: j[1],\n            x2: j[2],\n            y2: j[3]\n          }), g.addSegment(a, e, {\n            r: o,\n            x1: j[2],\n            y1: j[3],\n            x2: f[0],\n            y2: f[1],\n            cx: v,\n            cy: w,\n            ac: r\n          });\n        } else {\n          var x = j[2] === j[0] ? 0 : j[2] > j[0] ? c.lw / 2 : -(c.lw / 2),\n              y = j[3] === j[1] ? 0 : j[3] > j[1] ? c.lw / 2 : -(c.lw / 2);\n          g.addSegment(a, d, {\n            x1: j[0] - x,\n            y1: j[1] - y,\n            x2: j[2] + x,\n            y2: j[3] + y\n          });\n        }\n\n        j = f;\n      }\n\n      null != f && g.addSegment(a, d, {\n        x1: f[0],\n        y1: f[1],\n        x2: f[2],\n        y2: f[3]\n      });\n    };\n\n    this._compute = function (a, b) {\n      c = [], j = null, k = null, f = null;\n\n      var d = function d() {\n        return [a.startStubX, a.startStubY, a.endStubX, a.endStubY];\n      },\n          e = {\n        perpendicular: d,\n        orthogonal: d,\n        opposite: function opposite(b) {\n          var c = a,\n              d = \"x\" === b ? 0 : 1,\n              e = {\n            x: function x() {\n              return 1 === c.so[d] && (c.startStubX > c.endStubX && c.tx > c.startStubX || c.sx > c.endStubX && c.tx > c.sx) || -1 === c.so[d] && (c.startStubX < c.endStubX && c.tx < c.startStubX || c.sx < c.endStubX && c.tx < c.sx);\n            },\n            y: function y() {\n              return 1 === c.so[d] && (c.startStubY > c.endStubY && c.ty > c.startStubY || c.sy > c.endStubY && c.ty > c.sy) || -1 === c.so[d] && (c.startStubY < c.endStubY && c.ty < c.startStubY || c.sy < c.endStubY && c.ty < c.sy);\n            }\n          };\n          return !i && e[b]() ? {\n            x: [(a.sx + a.tx) / 2, a.startStubY, (a.sx + a.tx) / 2, a.endStubY],\n            y: [a.startStubX, (a.sy + a.ty) / 2, a.endStubX, (a.sy + a.ty) / 2]\n          }[b] : [a.startStubX, a.startStubY, a.endStubX, a.endStubY];\n        }\n      },\n          l = e[a.anchorOrientation](a.sourceAxis),\n          m = \"x\" === a.sourceAxis ? 0 : 1,\n          n = \"x\" === a.sourceAxis ? 1 : 0,\n          p = l[m],\n          q = l[n],\n          s = l[m + 2],\n          t = l[n + 2];\n\n      o(c, l[0], l[1], a);\n      var u = a.startStubX + (a.endStubX - a.startStubX) * h,\n          v = a.startStubY + (a.endStubY - a.startStubY) * h,\n          w = {\n        x: [0, 1],\n        y: [1, 0]\n      },\n          x = {\n        perpendicular: function perpendicular(b) {\n          var c = a,\n              d = {\n            x: [[[1, 2, 3, 4], null, [2, 1, 4, 3]], null, [[4, 3, 2, 1], null, [3, 4, 1, 2]]],\n            y: [[[3, 2, 1, 4], null, [2, 3, 4, 1]], null, [[4, 1, 2, 3], null, [1, 4, 3, 2]]]\n          },\n              e = {\n            x: [[c.startStubX, c.endStubX], null, [c.endStubX, c.startStubX]],\n            y: [[c.startStubY, c.endStubY], null, [c.endStubY, c.startStubY]]\n          },\n              f = {\n            x: [[u, c.startStubY], [u, c.endStubY]],\n            y: [[c.startStubX, v], [c.endStubX, v]]\n          },\n              g = {\n            x: [[c.endStubX, c.startStubY]],\n            y: [[c.startStubX, c.endStubY]]\n          },\n              h = {\n            x: [[c.startStubX, c.endStubY], [c.endStubX, c.endStubY]],\n            y: [[c.endStubX, c.startStubY], [c.endStubX, c.endStubY]]\n          },\n              i = {\n            x: [[c.startStubX, v], [c.endStubX, v], [c.endStubX, c.endStubY]],\n            y: [[u, c.startStubY], [u, c.endStubY], [c.endStubX, c.endStubY]]\n          },\n              j = {\n            x: [c.startStubY, c.endStubY],\n            y: [c.startStubX, c.endStubX]\n          },\n              k = w[b][0],\n              l = w[b][1],\n              m = c.so[k] + 1,\n              n = c.to[l] + 1,\n              o = -1 === c.to[l] && j[b][1] < j[b][0] || 1 === c.to[l] && j[b][1] > j[b][0],\n              p = e[b][m][0],\n              q = e[b][m][1],\n              r = d[b][m][n];\n          return c.segment === r[3] || c.segment === r[2] && o ? f[b] : c.segment === r[2] && p > q ? g[b] : c.segment === r[2] && q >= p || c.segment === r[1] && !o ? i[b] : c.segment === r[0] || c.segment === r[1] && o ? h[b] : void 0;\n        },\n        orthogonal: function orthogonal(b, c, d, e, f) {\n          var g = a,\n              h = {\n            x: -1 === g.so[0] ? Math.min(c, e) : Math.max(c, e),\n            y: -1 === g.so[1] ? Math.min(c, e) : Math.max(c, e)\n          }[b];\n          return {\n            x: [[h, d], [h, f], [e, f]],\n            y: [[d, h], [f, h], [f, e]]\n          }[b];\n        },\n        opposite: function opposite(c, d, e, f) {\n          var h = a,\n              i = {\n            x: \"y\",\n            y: \"x\"\n          }[c],\n              j = {\n            x: \"height\",\n            y: \"width\"\n          }[c],\n              k = h[\"is\" + c.toUpperCase() + \"GreaterThanStubTimes2\"];\n\n          if (b.sourceEndpoint.elementId === b.targetEndpoint.elementId) {\n            var l = e + (1 - b.sourceEndpoint.anchor[i]) * b.sourceInfo[j] + g.maxStub;\n            return {\n              x: [[d, l], [f, l]],\n              y: [[l, d], [l, f]]\n            }[c];\n          }\n\n          return !k || 1 === h.so[m] && d > f || -1 === h.so[m] && f > d ? {\n            x: [[d, v], [f, v]],\n            y: [[u, d], [u, f]]\n          }[c] : 1 === h.so[m] && f > d || -1 === h.so[m] && d > f ? {\n            x: [[u, h.sy], [u, h.ty]],\n            y: [[h.sx, v], [h.tx, v]]\n          }[c] : void 0;\n        }\n      },\n          y = x[a.anchorOrientation](a.sourceAxis, p, q, s, t);\n      if (y) for (var z = 0; z < y.length; z++) {\n        o(c, y[z][0], y[z][1], a);\n      }\n      o(c, l[2], l[3], a), o(c, a.tx, a.ty, a), r(this, c, a);\n    };\n  };\n\n  b.Connectors.Flowchart = f, c.extend(b.Connectors.Flowchart, b.Connectors.AbstractConnector);\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this,\n      b = a.jsPlumb,\n      c = a.jsPlumbUtil;\n  b.Connectors.AbstractBezierConnector = function (a) {\n    a = a || {};\n    var c,\n        d = a.showLoopback !== !1,\n        e = (a.curviness || 10, a.margin || 5),\n        f = (a.proximityLimit || 80, a.orientation && \"clockwise\" === a.orientation),\n        g = a.loopbackRadius || 25,\n        h = !1;\n    return this._compute = function (a, b) {\n      var i = b.sourcePos,\n          j = b.targetPos,\n          k = Math.abs(i[0] - j[0]),\n          l = Math.abs(i[1] - j[1]);\n\n      if (d && b.sourceEndpoint.elementId === b.targetEndpoint.elementId) {\n        h = !0;\n        var m = b.sourcePos[0],\n            n = b.sourcePos[1] - e,\n            o = m,\n            p = n - g,\n            q = o - g,\n            r = p - g;\n        k = 2 * g, l = 2 * g, a.points[0] = q, a.points[1] = r, a.points[2] = k, a.points[3] = l, c.addSegment(this, \"Arc\", {\n          loopback: !0,\n          x1: m - q + 4,\n          y1: n - r,\n          startAngle: 0,\n          endAngle: 2 * Math.PI,\n          r: g,\n          ac: !f,\n          x2: m - q - 4,\n          y2: n - r,\n          cx: o - q,\n          cy: p - r\n        });\n      } else h = !1, this._computeBezier(a, b, i, j, k, l);\n    }, c = b.Connectors.AbstractConnector.apply(this, arguments);\n  }, c.extend(b.Connectors.AbstractBezierConnector, b.Connectors.AbstractConnector);\n\n  var d = function d(a) {\n    a = a || {}, this.type = \"Bezier\";\n    var c = b.Connectors.AbstractBezierConnector.apply(this, arguments),\n        d = a.curviness || 150,\n        e = 10;\n    this.getCurviness = function () {\n      return d;\n    }, this._findControlPoint = function (a, b, c, f, g, h, i) {\n      var j = h[0] !== i[0] || h[1] === i[1],\n          k = [];\n      return j ? (0 === i[0] ? k.push(c[0] < b[0] ? a[0] + e : a[0] - e) : k.push(a[0] + d * i[0]), 0 === i[1] ? k.push(c[1] < b[1] ? a[1] + e : a[1] - e) : k.push(a[1] + d * h[1])) : (0 === h[0] ? k.push(b[0] < c[0] ? a[0] + e : a[0] - e) : k.push(a[0] - d * h[0]), 0 === h[1] ? k.push(b[1] < c[1] ? a[1] + e : a[1] - e) : k.push(a[1] + d * i[1])), k;\n    }, this._computeBezier = function (a, b, d, e, f, g) {\n      var h,\n          i,\n          j = d[0] < e[0] ? f : 0,\n          k = d[1] < e[1] ? g : 0,\n          l = d[0] < e[0] ? 0 : f,\n          m = d[1] < e[1] ? 0 : g;\n      h = this._findControlPoint([j, k], d, e, b.sourceEndpoint, b.targetEndpoint, a.so, a.to), i = this._findControlPoint([l, m], e, d, b.targetEndpoint, b.sourceEndpoint, a.to, a.so), c.addSegment(this, \"Bezier\", {\n        x1: j,\n        y1: k,\n        x2: l,\n        y2: m,\n        cp1x: h[0],\n        cp1y: h[1],\n        cp2x: i[0],\n        cp2y: i[1]\n      });\n    };\n  };\n\n  b.Connectors.Bezier = d, c.extend(d, b.Connectors.AbstractBezierConnector);\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this,\n      b = a.jsPlumb,\n      c = a.jsPlumbUtil,\n      d = function d(a, b, c, _d7) {\n    return c >= a && b >= _d7 ? 1 : c >= a && _d7 >= b ? 2 : a >= c && _d7 >= b ? 3 : 4;\n  },\n      e = function e(a, b, c, d, _e3, f, g, h, i) {\n    return i >= h ? [a, b] : 1 === c ? d[3] <= 0 && _e3[3] >= 1 ? [a + (d[2] < .5 ? -1 * f : f), b] : d[2] >= 1 && _e3[2] <= 0 ? [a, b + (d[3] < .5 ? -1 * g : g)] : [a + -1 * f, b + -1 * g] : 2 === c ? d[3] >= 1 && _e3[3] <= 0 ? [a + (d[2] < .5 ? -1 * f : f), b] : d[2] >= 1 && _e3[2] <= 0 ? [a, b + (d[3] < .5 ? -1 * g : g)] : [a + f, b + -1 * g] : 3 === c ? d[3] >= 1 && _e3[3] <= 0 ? [a + (d[2] < .5 ? -1 * f : f), b] : d[2] <= 0 && _e3[2] >= 1 ? [a, b + (d[3] < .5 ? -1 * g : g)] : [a + -1 * f, b + -1 * g] : 4 === c ? d[3] <= 0 && _e3[3] >= 1 ? [a + (d[2] < .5 ? -1 * f : f), b] : d[2] <= 0 && _e3[2] >= 1 ? [a, b + (d[3] < .5 ? -1 * g : g)] : [a + f, b + -1 * g] : void 0;\n  },\n      f = function f(a) {\n    a = a || {}, this.type = \"StateMachine\";\n    var c,\n        f = b.Connectors.AbstractBezierConnector.apply(this, arguments),\n        g = a.curviness || 10,\n        h = a.margin || 5,\n        i = a.proximityLimit || 80;\n    a.orientation && \"clockwise\" === a.orientation;\n\n    this._computeBezier = function (a, b, j, k, l, m) {\n      var n = b.sourcePos[0] < b.targetPos[0] ? 0 : l,\n          o = b.sourcePos[1] < b.targetPos[1] ? 0 : m,\n          p = b.sourcePos[0] < b.targetPos[0] ? l : 0,\n          q = b.sourcePos[1] < b.targetPos[1] ? m : 0;\n      0 === b.sourcePos[2] && (n -= h), 1 === b.sourcePos[2] && (n += h), 0 === b.sourcePos[3] && (o -= h), 1 === b.sourcePos[3] && (o += h), 0 === b.targetPos[2] && (p -= h), 1 === b.targetPos[2] && (p += h), 0 === b.targetPos[3] && (q -= h), 1 === b.targetPos[3] && (q += h);\n      var r,\n          s,\n          t,\n          u,\n          v = (n + p) / 2,\n          w = (o + q) / 2,\n          x = d(n, o, p, q),\n          y = Math.sqrt(Math.pow(p - n, 2) + Math.pow(q - o, 2));\n      c = e(v, w, x, b.sourcePos, b.targetPos, g, g, y, i), r = c[0], s = c[0], t = c[1], u = c[1], f.addSegment(this, \"Bezier\", {\n        x1: p,\n        y1: q,\n        x2: n,\n        y2: o,\n        cp1x: r,\n        cp1y: t,\n        cp2x: s,\n        cp2y: u\n      });\n    };\n  };\n\n  b.Connectors.StateMachine = f, c.extend(f, b.Connectors.AbstractBezierConnector);\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this,\n      b = a.jsPlumb,\n      c = a.jsPlumbUtil,\n      d = \"Straight\",\n      e = function e(a) {\n    this.type = d;\n    var c = b.Connectors.AbstractConnector.apply(this, arguments);\n\n    this._compute = function (a, b) {\n      c.addSegment(this, d, {\n        x1: a.sx,\n        y1: a.sy,\n        x2: a.startStubX,\n        y2: a.startStubY\n      }), c.addSegment(this, d, {\n        x1: a.startStubX,\n        y1: a.startStubY,\n        x2: a.endStubX,\n        y2: a.endStubY\n      }), c.addSegment(this, d, {\n        x1: a.endStubX,\n        y1: a.endStubY,\n        x2: a.tx,\n        y2: a.ty\n      });\n    };\n  };\n\n  b.Connectors.Straight = e, c.extend(e, b.Connectors.AbstractConnector);\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this,\n      b = a.jsPlumb,\n      c = a.jsPlumbUtil,\n      d = {\n    \"stroke-linejoin\": \"stroke-linejoin\",\n    \"stroke-dashoffset\": \"stroke-dashoffset\",\n    \"stroke-linecap\": \"stroke-linecap\"\n  },\n      e = \"stroke-dasharray\",\n      f = \"dashstyle\",\n      g = \"linearGradient\",\n      h = \"radialGradient\",\n      i = \"defs\",\n      j = \"fill\",\n      k = \"stop\",\n      l = \"stroke\",\n      m = \"stroke-width\",\n      n = \"style\",\n      o = \"none\",\n      p = \"jsplumb_gradient_\",\n      q = \"strokeWidth\",\n      r = {\n    svg: \"http://www.w3.org/2000/svg\"\n  },\n      s = function s(a, b) {\n    for (var c in b) {\n      a.setAttribute(c, \"\" + b[c]);\n    }\n  },\n      t = function t(a, c) {\n    return c = c || {}, c.version = \"1.1\", c.xmlns = r.svg, b.createElementNS(r.svg, a, null, null, c);\n  },\n      u = function u(a) {\n    return \"position:absolute;left:\" + a[0] + \"px;top:\" + a[1] + \"px\";\n  },\n      v = function v(a) {\n    for (var b = a.querySelectorAll(\" defs,linearGradient,radialGradient\"), c = 0; c < b.length; c++) {\n      b[c].parentNode.removeChild(b[c]);\n    }\n  },\n      w = function w(a, b, c, d, e) {\n    var f = p + e._jsPlumb.instance.idstamp();\n\n    v(a);\n    var m;\n    m = c.gradient.offset ? t(h, {\n      id: f\n    }) : t(g, {\n      id: f,\n      gradientUnits: \"userSpaceOnUse\"\n    });\n    var n = t(i);\n    a.appendChild(n), n.appendChild(m);\n\n    for (var o = 0; o < c.gradient.stops.length; o++) {\n      var q = 1 === e.segment || 2 === e.segment ? o : c.gradient.stops.length - 1 - o,\n          r = c.gradient.stops[q][1],\n          s = t(k, {\n        offset: Math.floor(100 * c.gradient.stops[o][0]) + \"%\",\n        \"stop-color\": r\n      });\n      m.appendChild(s);\n    }\n\n    var u = c.stroke ? l : j;\n    b.setAttribute(u, \"url(#\" + f + \")\");\n  },\n      x = function x(a, b, c, g, h) {\n    if (b.setAttribute(j, c.fill ? c.fill : o), b.setAttribute(l, c.stroke ? c.stroke : o), c.gradient ? w(a, b, c, g, h) : (v(a), b.setAttribute(n, \"\")), c.strokeWidth && b.setAttribute(m, c.strokeWidth), c[f] && c[q] && !c[e]) {\n      var i = -1 === c[f].indexOf(\",\") ? \" \" : \",\",\n          k = c[f].split(i),\n          p = \"\";\n      k.forEach(function (a) {\n        p += Math.floor(a * c.strokeWidth) + i;\n      }), b.setAttribute(e, p);\n    } else c[e] && b.setAttribute(e, c[e]);\n\n    for (var r in d) {\n      c[r] && b.setAttribute(d[r], c[r]);\n    }\n  },\n      y = function y(a, b, c) {\n    a.childNodes.length > c ? a.insertBefore(b, a.childNodes[c]) : a.appendChild(b);\n  };\n\n  c.svg = {\n    node: t,\n    attr: s,\n    pos: u\n  };\n\n  var z = function z(a) {\n    var d = a.pointerEventsSpec || \"all\",\n        e = {};\n    b.jsPlumbUIComponent.apply(this, a.originalArgs), this.canvas = null, this.path = null, this.svg = null, this.bgCanvas = null;\n    var f = a.cssClass + \" \" + (a.originalArgs[0].cssClass || \"\"),\n        g = {\n      style: \"\",\n      width: 0,\n      height: 0,\n      \"pointer-events\": d,\n      position: \"absolute\"\n    };\n    this.svg = t(\"svg\", g), a.useDivWrapper ? (this.canvas = b.createElement(\"div\", {\n      position: \"absolute\"\n    }), c.sizeElement(this.canvas, 0, 0, 1, 1), this.canvas.className = f) : (s(this.svg, {\n      \"class\": f\n    }), this.canvas = this.svg), a._jsPlumb.appendElement(this.canvas, a.originalArgs[0].parent), a.useDivWrapper && this.canvas.appendChild(this.svg);\n    var h = [this.canvas];\n    return this.getDisplayElements = function () {\n      return h;\n    }, this.appendDisplayElement = function (a) {\n      h.push(a);\n    }, this.paint = function (b, d, f) {\n      if (null != b) {\n        var g,\n            h = [this.x, this.y],\n            i = [this.w, this.h];\n        null != f && (f.xmin < 0 && (h[0] += f.xmin), f.ymin < 0 && (h[1] += f.ymin), i[0] = f.xmax + (f.xmin < 0 ? -f.xmin : 0), i[1] = f.ymax + (f.ymin < 0 ? -f.ymin : 0)), a.useDivWrapper ? (c.sizeElement(this.canvas, h[0], h[1], i[0], i[1]), h[0] = 0, h[1] = 0, g = u([0, 0])) : g = u([h[0], h[1]]), e.paint.apply(this, arguments), s(this.svg, {\n          style: g,\n          width: i[0] || 0,\n          height: i[1] || 0\n        });\n      }\n    }, {\n      renderer: e\n    };\n  };\n\n  c.extend(z, b.jsPlumbUIComponent, {\n    cleanup: function cleanup(a) {\n      a || null == this.typeId ? (this.canvas && (this.canvas._jsPlumb = null), this.svg && (this.svg._jsPlumb = null), this.bgCanvas && (this.bgCanvas._jsPlumb = null), this.canvas && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas), this.bgCanvas && this.bgCanvas.parentNode && this.canvas.parentNode.removeChild(this.canvas), this.svg = null, this.canvas = null, this.path = null, this.group = null) : (this.canvas && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas), this.bgCanvas && this.bgCanvas.parentNode && this.bgCanvas.parentNode.removeChild(this.bgCanvas));\n    },\n    reattach: function reattach(a) {\n      var b = a.getContainer();\n      this.canvas && null == this.canvas.parentNode && b.appendChild(this.canvas), this.bgCanvas && null == this.bgCanvas.parentNode && b.appendChild(this.bgCanvas);\n    },\n    setVisible: function setVisible(a) {\n      this.canvas && (this.canvas.style.display = a ? \"block\" : \"none\");\n    }\n  }), b.ConnectorRenderers.svg = function (a) {\n    var c = this,\n        d = z.apply(this, [{\n      cssClass: a._jsPlumb.connectorClass,\n      originalArgs: arguments,\n      pointerEventsSpec: \"none\",\n      _jsPlumb: a._jsPlumb\n    }]);\n\n    d.renderer.paint = function (d, e, f) {\n      var g = c.getSegments(),\n          h = \"\",\n          i = [0, 0];\n\n      if (f.xmin < 0 && (i[0] = -f.xmin), f.ymin < 0 && (i[1] = -f.ymin), g.length > 0) {\n        h = c.getPathData();\n        var j = {\n          d: h,\n          transform: \"translate(\" + i[0] + \",\" + i[1] + \")\",\n          \"pointer-events\": a[\"pointer-events\"] || \"visibleStroke\"\n        },\n            k = null,\n            l = [c.x, c.y, c.w, c.h];\n\n        if (d.outlineStroke) {\n          var m = d.outlineWidth || 1,\n              n = d.strokeWidth + 2 * m;\n          k = b.extend({}, d), delete k.gradient, k.stroke = d.outlineStroke, k.strokeWidth = n, null == c.bgPath ? (c.bgPath = t(\"path\", j), b.addClass(c.bgPath, b.connectorOutlineClass), y(c.svg, c.bgPath, 0)) : s(c.bgPath, j), x(c.svg, c.bgPath, k, l, c);\n        }\n\n        null == c.path ? (c.path = t(\"path\", j), y(c.svg, c.path, d.outlineStroke ? 1 : 0)) : s(c.path, j), x(c.svg, c.path, d, l, c);\n      }\n    };\n  }, c.extend(b.ConnectorRenderers.svg, z);\n\n  var A = b.SvgEndpoint = function (a) {\n    var c = z.apply(this, [{\n      cssClass: a._jsPlumb.endpointClass,\n      originalArgs: arguments,\n      pointerEventsSpec: \"all\",\n      useDivWrapper: !0,\n      _jsPlumb: a._jsPlumb\n    }]);\n\n    c.renderer.paint = function (a) {\n      var c = b.extend({}, a);\n      c.outlineStroke && (c.stroke = c.outlineStroke), null == this.node ? (this.node = this.makeNode(c), this.svg.appendChild(this.node)) : null != this.updateNode && this.updateNode(this.node), x(this.svg, this.node, c, [this.x, this.y, this.w, this.h], this), u(this.node, [this.x, this.y]);\n    }.bind(this);\n  };\n\n  c.extend(A, z), b.Endpoints.svg.Dot = function () {\n    b.Endpoints.Dot.apply(this, arguments), A.apply(this, arguments), this.makeNode = function (a) {\n      return t(\"circle\", {\n        cx: this.w / 2,\n        cy: this.h / 2,\n        r: this.radius\n      });\n    }, this.updateNode = function (a) {\n      s(a, {\n        cx: this.w / 2,\n        cy: this.h / 2,\n        r: this.radius\n      });\n    };\n  }, c.extend(b.Endpoints.svg.Dot, [b.Endpoints.Dot, A]), b.Endpoints.svg.Rectangle = function () {\n    b.Endpoints.Rectangle.apply(this, arguments), A.apply(this, arguments), this.makeNode = function (a) {\n      return t(\"rect\", {\n        width: this.w,\n        height: this.h\n      });\n    }, this.updateNode = function (a) {\n      s(a, {\n        width: this.w,\n        height: this.h\n      });\n    };\n  }, c.extend(b.Endpoints.svg.Rectangle, [b.Endpoints.Rectangle, A]), b.Endpoints.svg.Image = b.Endpoints.Image, b.Endpoints.svg.Blank = b.Endpoints.Blank, b.Overlays.svg.Label = b.Overlays.Label, b.Overlays.svg.Custom = b.Overlays.Custom;\n\n  var B = function B(a, c) {\n    a.apply(this, c), b.jsPlumbUIComponent.apply(this, c), this.isAppendedAtTopLevel = !1;\n    this.path = null, this.paint = function (a, b) {\n      if (a.component.svg && b) {\n        null == this.path && (this.path = t(\"path\", {\n          \"pointer-events\": \"all\"\n        }), a.component.svg.appendChild(this.path), this.elementCreated && this.elementCreated(this.path, a.component), this.canvas = a.component.svg);\n        var e = c && 1 === c.length ? c[0].cssClass || \"\" : \"\",\n            f = [0, 0];\n        b.xmin < 0 && (f[0] = -b.xmin), b.ymin < 0 && (f[1] = -b.ymin), s(this.path, {\n          d: d(a.d),\n          \"class\": e,\n          stroke: a.stroke ? a.stroke : null,\n          fill: a.fill ? a.fill : null,\n          transform: \"translate(\" + f[0] + \",\" + f[1] + \")\"\n        });\n      }\n    };\n\n    var d = function d(a) {\n      return isNaN(a.cxy.x) || isNaN(a.cxy.y) ? \"\" : \"M\" + a.hxy.x + \",\" + a.hxy.y + \" L\" + a.tail[0].x + \",\" + a.tail[0].y + \" L\" + a.cxy.x + \",\" + a.cxy.y + \" L\" + a.tail[1].x + \",\" + a.tail[1].y + \" L\" + a.hxy.x + \",\" + a.hxy.y;\n    };\n\n    this.transfer = function (a) {\n      a.canvas && this.path && this.path.parentNode && (this.path.parentNode.removeChild(this.path), a.canvas.appendChild(this.path));\n    };\n  };\n\n  c.extend(B, [b.jsPlumbUIComponent, b.Overlays.AbstractOverlay], {\n    cleanup: function cleanup(a) {\n      null != this.path && (a ? this._jsPlumb.instance.removeElement(this.path) : this.path.parentNode && this.path.parentNode.removeChild(this.path));\n    },\n    reattach: function reattach(a, b) {\n      this.path && b.canvas && b.canvas.appendChild(this.path);\n    },\n    setVisible: function setVisible(a) {\n      null != this.path && (this.path.style.display = a ? \"block\" : \"none\");\n    }\n  }), b.Overlays.svg.Arrow = function () {\n    B.apply(this, [b.Overlays.Arrow, arguments]);\n  }, c.extend(b.Overlays.svg.Arrow, [b.Overlays.Arrow, B]), b.Overlays.svg.PlainArrow = function () {\n    B.apply(this, [b.Overlays.PlainArrow, arguments]);\n  }, c.extend(b.Overlays.svg.PlainArrow, [b.Overlays.PlainArrow, B]), b.Overlays.svg.Diamond = function () {\n    B.apply(this, [b.Overlays.Diamond, arguments]);\n  }, c.extend(b.Overlays.svg.Diamond, [b.Overlays.Diamond, B]), b.Overlays.svg.GuideLines = function () {\n    var a,\n        c,\n        d = null,\n        e = this;\n    b.Overlays.GuideLines.apply(this, arguments), this.paint = function (b, g) {\n      null == d && (d = t(\"path\"), b.connector.svg.appendChild(d), e.attachListeners(d, b.connector), e.attachListeners(d, e), a = t(\"path\"), b.connector.svg.appendChild(a), e.attachListeners(a, b.connector), e.attachListeners(a, e), c = t(\"path\"), b.connector.svg.appendChild(c), e.attachListeners(c, b.connector), e.attachListeners(c, e));\n      var h = [0, 0];\n      g.xmin < 0 && (h[0] = -g.xmin), g.ymin < 0 && (h[1] = -g.ymin), s(d, {\n        d: f(b.head, b.tail),\n        stroke: \"red\",\n        fill: null,\n        transform: \"translate(\" + h[0] + \",\" + h[1] + \")\"\n      }), s(a, {\n        d: f(b.tailLine[0], b.tailLine[1]),\n        stroke: \"blue\",\n        fill: null,\n        transform: \"translate(\" + h[0] + \",\" + h[1] + \")\"\n      }), s(c, {\n        d: f(b.headLine[0], b.headLine[1]),\n        stroke: \"green\",\n        fill: null,\n        transform: \"translate(\" + h[0] + \",\" + h[1] + \")\"\n      });\n    };\n\n    var f = function f(a, b) {\n      return \"M \" + a.x + \",\" + a.y + \" L\" + b.x + \",\" + b.y;\n    };\n  }, c.extend(b.Overlays.svg.GuideLines, b.Overlays.GuideLines);\n}.call(\"undefined\" != typeof window ? window : this), function () {\n  \"use strict\";\n\n  var a = this,\n      b = a.jsPlumb,\n      c = a.jsPlumbUtil,\n      d = a.Katavorio,\n      e = a.Biltong,\n      f = function f(b) {\n    var c = b._mottle;\n    return c || (c = b._mottle = new a.Mottle()), c;\n  },\n      g = function g(a, c) {\n    c = c || \"main\";\n    var f = \"_katavorio_\" + c,\n        g = a[f],\n        h = a.getEventManager();\n    return g || (g = new d({\n      bind: h.on,\n      unbind: h.off,\n      getSize: b.getSize,\n      getConstrainingRectangle: function getConstrainingRectangle(a) {\n        return [a.parentNode.scrollWidth, a.parentNode.scrollHeight];\n      },\n      getPosition: function getPosition(b, c) {\n        var d = a.getOffset(b, c, b._katavorioDrag ? b.offsetParent : null);\n        return [d.left, d.top];\n      },\n      setPosition: function setPosition(a, b) {\n        a.style.left = b[0] + \"px\", a.style.top = b[1] + \"px\";\n      },\n      addClass: b.addClass,\n      removeClass: b.removeClass,\n      intersects: e.intersects,\n      indexOf: function indexOf(a, b) {\n        return a.indexOf(b);\n      },\n      scope: a.getDefaultScope(),\n      css: {\n        noSelect: a.dragSelectClass,\n        droppable: \"jtk-droppable\",\n        draggable: \"jtk-draggable\",\n        drag: \"jtk-drag\",\n        selected: \"jtk-drag-selected\",\n        active: \"jtk-drag-active\",\n        hover: \"jtk-drag-hover\",\n        ghostProxy: \"jtk-ghost-proxy\"\n      }\n    }), g.setZoom(a.getZoom()), a[f] = g, a.bind(\"zoom\", g.setZoom)), g;\n  },\n      h = function h(a) {\n    var b = a.el._jsPlumbDragOptions,\n        c = !0;\n    return b.canDrag && (c = b.canDrag()), c && (this.setHoverSuspended(!0), this.select({\n      source: a.el\n    }).addClass(this.elementDraggingClass + \" \" + this.sourceElementDraggingClass, !0), this.select({\n      target: a.el\n    }).addClass(this.elementDraggingClass + \" \" + this.targetElementDraggingClass, !0), this.setConnectionBeingDragged(!0)), c;\n  },\n      i = function i(a) {\n    var b = this.getUIPosition(arguments, this.getZoom());\n\n    if (null != b) {\n      var c = a.el._jsPlumbDragOptions;\n      this.draw(a.el, b, null, !0), c._dragging && this.addClass(a.el, \"jtk-dragged\"), c._dragging = !0;\n    }\n  },\n      j = function j(a) {\n    for (var b, c = a.selection, d = function (a) {\n      null != a[1] && (b = this.getUIPosition([{\n        el: a[2].el,\n        pos: [a[1].left, a[1].top]\n      }]), this.draw(a[2].el, b)), null != a[0]._jsPlumbDragOptions && delete a[0]._jsPlumbDragOptions._dragging, this.removeClass(a[0], \"jtk-dragged\"), this.select({\n        source: a[2].el\n      }).removeClass(this.elementDraggingClass + \" \" + this.sourceElementDraggingClass, !0), this.select({\n        target: a[2].el\n      }).removeClass(this.elementDraggingClass + \" \" + this.targetElementDraggingClass, !0), this.getDragManager().dragEnded(a[2].el);\n    }.bind(this), e = 0; e < c.length; e++) {\n      d(c[e]);\n    }\n\n    this.setHoverSuspended(!1), this.setConnectionBeingDragged(!1);\n  },\n      k = function k(a, b) {\n    var d = function d(_d8) {\n      if (null != b[_d8]) {\n        if (c.isString(b[_d8])) {\n          var e = b[_d8].match(/-=/) ? -1 : 1,\n              f = b[_d8].substring(2);\n\n          return a[_d8] + e * f;\n        }\n\n        return b[_d8];\n      }\n\n      return a[_d8];\n    };\n\n    return [d(\"left\"), d(\"top\")];\n  },\n      l = function l(a, b) {\n    if (null == b) return [0, 0];\n    var c = q(b),\n        d = p(c, 0);\n    return [d[a + \"X\"], d[a + \"Y\"]];\n  },\n      m = l.bind(this, \"page\"),\n      n = l.bind(this, \"screen\"),\n      o = l.bind(this, \"client\"),\n      p = function p(a, b) {\n    return a.item ? a.item(b) : a[b];\n  },\n      q = function q(a) {\n    return a.touches && a.touches.length > 0 ? a.touches : a.changedTouches && a.changedTouches.length > 0 ? a.changedTouches : a.targetTouches && a.targetTouches.length > 0 ? a.targetTouches : [a];\n  },\n      r = function r(a) {\n    var b = {},\n        c = [],\n        d = {},\n        e = {},\n        f = {};\n    this.register = function (g) {\n      var h,\n          i = a.getId(g);\n      b[i] || (b[i] = g, c.push(g), d[i] = {});\n\n      var j = function j(b) {\n        if (b) for (var c = 0; c < b.childNodes.length; c++) {\n          if (3 !== b.childNodes[c].nodeType && 8 !== b.childNodes[c].nodeType) {\n            var k = jsPlumb.getElement(b.childNodes[c]),\n                l = a.getId(b.childNodes[c], null, !0);\n\n            if (l && e[l] && e[l] > 0) {\n              h || (h = a.getOffset(g));\n              var m = a.getOffset(k);\n              d[i][l] = {\n                id: l,\n                offset: {\n                  left: m.left - h.left,\n                  top: m.top - h.top\n                }\n              }, f[l] = i;\n            }\n\n            j(b.childNodes[c]);\n          }\n        }\n      };\n\n      j(g);\n    }, this.updateOffsets = function (b, c) {\n      if (null != b) {\n        c = c || {};\n        var e,\n            g = jsPlumb.getElement(b),\n            h = a.getId(g),\n            i = d[h];\n        if (i) for (var j in i) {\n          if (i.hasOwnProperty(j)) {\n            var k = jsPlumb.getElement(j),\n                l = c[j] || a.getOffset(k);\n            if (null == k.offsetParent && null != d[h][j]) continue;\n            e || (e = a.getOffset(g)), d[h][j] = {\n              id: j,\n              offset: {\n                left: l.left - e.left,\n                top: l.top - e.top\n              }\n            }, f[j] = h;\n          }\n        }\n      }\n    }, this.endpointAdded = function (c, g) {\n      g = g || a.getId(c);\n      var h = document.body,\n          i = c.parentNode;\n\n      for (e[g] = e[g] ? e[g] + 1 : 1; null != i && i !== h;) {\n        var j = a.getId(i, null, !0);\n\n        if (j && b[j]) {\n          var k = a.getOffset(i);\n\n          if (null == d[j][g]) {\n            var l = a.getOffset(c);\n            d[j][g] = {\n              id: g,\n              offset: {\n                left: l.left - k.left,\n                top: l.top - k.top\n              }\n            }, f[g] = j;\n          }\n\n          break;\n        }\n\n        i = i.parentNode;\n      }\n    }, this.endpointDeleted = function (a) {\n      if (e[a.elementId] && (e[a.elementId]--, e[a.elementId] <= 0)) for (var b in d) {\n        d.hasOwnProperty(b) && d[b] && (delete d[b][a.elementId], delete f[a.elementId]);\n      }\n    }, this.changeId = function (a, b) {\n      d[b] = d[a], d[a] = {}, f[b] = f[a], f[a] = null;\n    }, this.getElementsForDraggable = function (a) {\n      return d[a];\n    }, this.elementRemoved = function (a) {\n      var b = f[a];\n      b && (delete d[b][a], delete f[a]);\n    }, this.reset = function () {\n      b = {}, c = [], d = {}, e = {};\n    }, this.dragEnded = function (b) {\n      if (null != b.offsetParent) {\n        var c = a.getId(b),\n            d = f[c];\n        d && this.updateOffsets(d);\n      }\n    }, this.setParent = function (b, c, e, g, h) {\n      var i = f[c];\n      d[g] || (d[g] = {});\n      var j = a.getOffset(e),\n          k = h || a.getOffset(b);\n      i && d[i] && delete d[i][c], d[g][c] = {\n        id: c,\n        offset: {\n          left: k.left - j.left,\n          top: k.top - j.top\n        }\n      }, f[c] = g;\n    }, this.clearParent = function (a, b) {\n      var c = f[b];\n      c && (delete d[c][b], delete f[b]);\n    }, this.revalidateParent = function (b, c, d) {\n      var e = f[c];\n\n      if (e) {\n        var g = {};\n        g[c] = d, this.updateOffsets(e, g), a.revalidate(e);\n      }\n    }, this.getDragAncestor = function (b) {\n      var c = jsPlumb.getElement(b),\n          d = a.getId(c),\n          e = f[d];\n      return e ? jsPlumb.getElement(e) : null;\n    };\n  },\n      s = function s(a, b, d) {\n    b = c.fastTrim(b), \"undefined\" != typeof a.className.baseVal ? a.className.baseVal = b : a.className = b;\n\n    try {\n      var e = a.classList;\n\n      if (null != e) {\n        for (; e.length > 0;) {\n          e.remove(e.item(0));\n        }\n\n        for (var f = 0; f < d.length; f++) {\n          d[f] && e.add(d[f]);\n        }\n      }\n    } catch (g) {\n      c.log(\"JSPLUMB: cannot set class list\", g);\n    }\n  },\n      t = function t(a) {\n    return \"undefined\" == typeof a.className.baseVal ? a.className : a.className.baseVal;\n  },\n      u = function u(a, b, d) {\n    b = null == b ? [] : c.isArray(b) ? b : b.split(/\\s+/), d = null == d ? [] : c.isArray(d) ? d : d.split(/\\s+/);\n\n    var e = t(a),\n        f = e.split(/\\s+/),\n        g = function g(a, b) {\n      for (var c = 0; c < b.length; c++) {\n        if (a) -1 === f.indexOf(b[c]) && f.push(b[c]);else {\n          var d = f.indexOf(b[c]);\n          -1 !== d && f.splice(d, 1);\n        }\n      }\n    };\n\n    g(!0, b), g(!1, d), s(a, f.join(\" \"), f);\n  };\n\n  a.jsPlumb.extend(a.jsPlumbInstance.prototype, {\n    headless: !1,\n    pageLocation: m,\n    screenLocation: n,\n    clientLocation: o,\n    getDragManager: function getDragManager() {\n      return null == this.dragManager && (this.dragManager = new r(this)), this.dragManager;\n    },\n    recalculateOffsets: function recalculateOffsets(a) {\n      this.getDragManager().updateOffsets(a);\n    },\n    createElement: function createElement(a, b, c, d) {\n      return this.createElementNS(null, a, b, c, d);\n    },\n    createElementNS: function createElementNS(a, b, c, d, e) {\n      var f,\n          g = null == a ? document.createElement(b) : document.createElementNS(a, b);\n      c = c || {};\n\n      for (f in c) {\n        g.style[f] = c[f];\n      }\n\n      d && (g.className = d), e = e || {};\n\n      for (f in e) {\n        g.setAttribute(f, \"\" + e[f]);\n      }\n\n      return g;\n    },\n    getAttribute: function getAttribute(a, b) {\n      return null != a.getAttribute ? a.getAttribute(b) : null;\n    },\n    setAttribute: function setAttribute(a, b, c) {\n      null != a.setAttribute && a.setAttribute(b, c);\n    },\n    setAttributes: function setAttributes(a, b) {\n      for (var c in b) {\n        b.hasOwnProperty(c) && a.setAttribute(c, b[c]);\n      }\n    },\n    appendToRoot: function appendToRoot(a) {\n      document.body.appendChild(a);\n    },\n    getRenderModes: function getRenderModes() {\n      return [\"svg\"];\n    },\n    getClass: t,\n    addClass: function addClass(a, b) {\n      jsPlumb.each(a, function (a) {\n        u(a, b);\n      });\n    },\n    hasClass: function hasClass(a, b) {\n      return a = jsPlumb.getElement(a), a.classList ? a.classList.contains(b) : -1 !== t(a).indexOf(b);\n    },\n    removeClass: function removeClass(a, b) {\n      jsPlumb.each(a, function (a) {\n        u(a, null, b);\n      });\n    },\n    toggleClass: function toggleClass(a, b) {\n      jsPlumb.hasClass(a, b) ? jsPlumb.removeClass(a, b) : jsPlumb.addClass(a, b);\n    },\n    updateClasses: function updateClasses(a, b, c) {\n      jsPlumb.each(a, function (a) {\n        u(a, b, c);\n      });\n    },\n    setClass: function setClass(a, b) {\n      null != b && jsPlumb.each(a, function (a) {\n        s(a, b, b.split(/\\s+/));\n      });\n    },\n    setPosition: function setPosition(a, b) {\n      a.style.left = b.left + \"px\", a.style.top = b.top + \"px\";\n    },\n    getPosition: function getPosition(a) {\n      var b = function b(_b2) {\n        var c = a.style[_b2];\n        return c ? c.substring(0, c.length - 2) : 0;\n      };\n\n      return {\n        left: b(\"left\"),\n        top: b(\"top\")\n      };\n    },\n    getStyle: function getStyle(a, b) {\n      return \"undefined\" != typeof window.getComputedStyle ? getComputedStyle(a, null).getPropertyValue(b) : a.currentStyle[b];\n    },\n    getSelector: function getSelector(a, b) {\n      var c = null;\n      return c = 1 === arguments.length ? null != a.nodeType ? a : document.querySelectorAll(a) : a.querySelectorAll(b);\n    },\n    getOffset: function getOffset(a, b, c) {\n      a = jsPlumb.getElement(a), c = c || this.getContainer();\n\n      for (var d = {\n        left: a.offsetLeft,\n        top: a.offsetTop\n      }, e = b || null != c && a !== c && a.offsetParent !== c ? a.offsetParent : null, f = function (a) {\n        null != a && a !== document.body && (a.scrollTop > 0 || a.scrollLeft > 0) && (d.left -= a.scrollLeft, d.top -= a.scrollTop);\n      }.bind(this); null != e;) {\n        d.left += e.offsetLeft, d.top += e.offsetTop, f(e), e = b ? e.offsetParent : e.offsetParent === c ? null : e.offsetParent;\n      }\n\n      if (null != c && !b && (c.scrollTop > 0 || c.scrollLeft > 0)) {\n        var g = null != a.offsetParent ? this.getStyle(a.offsetParent, \"position\") : \"static\",\n            h = this.getStyle(a, \"position\");\n        \"absolute\" !== h && \"fixed\" !== h && \"absolute\" !== g && \"fixed\" !== g && (d.left -= c.scrollLeft, d.top -= c.scrollTop);\n      }\n\n      return d;\n    },\n    getPositionOnElement: function getPositionOnElement(a, b, c) {\n      var d = \"undefined\" != typeof b.getBoundingClientRect ? b.getBoundingClientRect() : {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0\n      },\n          e = document.body,\n          f = document.documentElement,\n          g = window.pageYOffset || f.scrollTop || e.scrollTop,\n          h = window.pageXOffset || f.scrollLeft || e.scrollLeft,\n          i = f.clientTop || e.clientTop || 0,\n          j = f.clientLeft || e.clientLeft || 0,\n          k = 0,\n          l = 0,\n          m = d.top + g - i + k * c,\n          n = d.left + h - j + l * c,\n          o = jsPlumb.pageLocation(a),\n          p = d.width || b.offsetWidth * c,\n          q = d.height || b.offsetHeight * c,\n          r = (o[0] - n) / p,\n          s = (o[1] - m) / q;\n      return [r, s];\n    },\n    getAbsolutePosition: function getAbsolutePosition(a) {\n      var b = function b(_b3) {\n        var c = a.style[_b3];\n        return c ? parseFloat(c.substring(0, c.length - 2)) : void 0;\n      };\n\n      return [b(\"left\"), b(\"top\")];\n    },\n    setAbsolutePosition: function setAbsolutePosition(a, b, c, d) {\n      c ? this.animate(a, {\n        left: \"+=\" + (b[0] - c[0]),\n        top: \"+=\" + (b[1] - c[1])\n      }, d) : (a.style.left = b[0] + \"px\", a.style.top = b[1] + \"px\");\n    },\n    getSize: function getSize(a) {\n      return [a.offsetWidth, a.offsetHeight];\n    },\n    getWidth: function getWidth(a) {\n      return a.offsetWidth;\n    },\n    getHeight: function getHeight(a) {\n      return a.offsetHeight;\n    },\n    getRenderMode: function getRenderMode() {\n      return \"svg\";\n    },\n    draggable: function draggable(a, b) {\n      var d;\n      return a = c.isArray(a) || null != a.length && !c.isString(a) ? a : [a], Array.prototype.slice.call(a).forEach(function (a) {\n        d = this.info(a), d.el && this._initDraggableIfNecessary(d.el, !0, b, d.id, !0);\n      }.bind(this)), this;\n    },\n    snapToGrid: function snapToGrid(a, b, c) {\n      var d = [],\n          e = function (a) {\n        var e = this.info(a);\n\n        if (null != e.el && e.el._katavorioDrag) {\n          var f = e.el._katavorioDrag.snap(b, c);\n\n          this.revalidate(e.el), d.push([e.el, f]);\n        }\n      }.bind(this);\n\n      if (1 === arguments.length || 3 === arguments.length) e(a, b, c);else {\n        var f = this.getManagedElements();\n\n        for (var g in f) {\n          e(g, arguments[0], arguments[1]);\n        }\n      }\n      return d;\n    },\n    initDraggable: function initDraggable(a, b, c) {\n      g(this, c).draggable(a, b), a._jsPlumbDragOptions = b;\n    },\n    destroyDraggable: function destroyDraggable(a, b) {\n      g(this, b).destroyDraggable(a), delete a._jsPlumbDragOptions;\n    },\n    unbindDraggable: function unbindDraggable(a, b, c, d) {\n      g(this, d).destroyDraggable(a, b, c);\n    },\n    setDraggable: function setDraggable(a, b) {\n      return jsPlumb.each(a, function (a) {\n        this.isDragSupported(a) && (this._draggableStates[this.getAttribute(a, \"id\")] = b, this.setElementDraggable(a, b));\n      }.bind(this));\n    },\n    _draggableStates: {},\n    toggleDraggable: function toggleDraggable(a) {\n      var b;\n      return jsPlumb.each(a, function (a) {\n        var c = this.getAttribute(a, \"id\");\n        return b = null == this._draggableStates[c] ? !1 : this._draggableStates[c], b = !b, this._draggableStates[c] = b, this.setDraggable(a, b), b;\n      }.bind(this)), b;\n    },\n    _initDraggableIfNecessary: function _initDraggableIfNecessary(a, b, d, e, f) {\n      if (!jsPlumb.headless) {\n        var g = null == b ? !1 : b;\n\n        if (g && jsPlumb.isDragSupported(a, this)) {\n          var k = d || this.Defaults.DragOptions;\n          if (k = jsPlumb.extend({}, k), jsPlumb.isAlreadyDraggable(a, this)) d.force && this.initDraggable(a, k);else {\n            var l = jsPlumb.dragEvents.drag,\n                m = jsPlumb.dragEvents.stop,\n                n = jsPlumb.dragEvents.start;\n            this.manage(e, a), k[n] = c.wrap(k[n], h.bind(this)), k[l] = c.wrap(k[l], i.bind(this)), k[m] = c.wrap(k[m], j.bind(this));\n            var o = this.getId(a);\n            this._draggableStates[o] = !0;\n            var p = this._draggableStates[o];\n            k.disabled = null == p ? !1 : !p, this.initDraggable(a, k), this.getDragManager().register(a), f && this.fire(\"elementDraggable\", {\n              el: a,\n              options: k\n            });\n          }\n        }\n      }\n    },\n    animationSupported: !0,\n    getElement: function getElement(a) {\n      return null == a ? null : (a = \"string\" == typeof a ? a : null != a.length && null == a.enctype ? a[0] : a, \"string\" == typeof a ? document.getElementById(a) : a);\n    },\n    removeElement: function removeElement(a) {\n      g(this).elementRemoved(a), this.getEventManager().remove(a);\n    },\n    doAnimate: function doAnimate(a, c, d) {\n      d = d || {};\n      var e = this.getOffset(a),\n          f = k(e, c),\n          g = f[0] - e.left,\n          h = f[1] - e.top,\n          i = d.duration || 250,\n          j = 15,\n          l = i / j,\n          m = j / i * g,\n          n = j / i * h,\n          o = 0,\n          p = setInterval(function () {\n        b.setPosition(a, {\n          left: e.left + m * (o + 1),\n          top: e.top + n * (o + 1)\n        }), null != d.step && d.step(o, Math.ceil(l)), o++, o >= l && (window.clearInterval(p), null != d.complete && d.complete());\n      }, j);\n    },\n    destroyDroppable: function destroyDroppable(a, b) {\n      g(this, b).destroyDroppable(a);\n    },\n    unbindDroppable: function unbindDroppable(a, b, c, d) {\n      g(this, d).destroyDroppable(a, b, c);\n    },\n    droppable: function droppable(a, b) {\n      a = c.isArray(a) || null != a.length && !c.isString(a) ? a : [a];\n      var d;\n      return b = b || {}, b.allowLoopback = !1, Array.prototype.slice.call(a).forEach(function (a) {\n        d = this.info(a), d.el && this.initDroppable(d.el, b);\n      }.bind(this)), this;\n    },\n    initDroppable: function initDroppable(a, b, c) {\n      g(this, c).droppable(a, b);\n    },\n    isAlreadyDraggable: function isAlreadyDraggable(a) {\n      return null != a._katavorioDrag;\n    },\n    isDragSupported: function isDragSupported(a, b) {\n      return !0;\n    },\n    isDropSupported: function isDropSupported(a, b) {\n      return !0;\n    },\n    isElementDraggable: function isElementDraggable(a) {\n      return a = b.getElement(a), a._katavorioDrag && a._katavorioDrag.isEnabled();\n    },\n    getDragObject: function getDragObject(a) {\n      return a[0].drag.getDragElement();\n    },\n    getDragScope: function getDragScope(a) {\n      return a._katavorioDrag && a._katavorioDrag.scopes.join(\" \") || \"\";\n    },\n    getDropEvent: function getDropEvent(a) {\n      return a[0].e;\n    },\n    getUIPosition: function getUIPosition(a, b) {\n      var c = a[0].el;\n      if (null == c.offsetParent) return null;\n      var d = a[0].finalPos || a[0].pos,\n          e = {\n        left: d[0],\n        top: d[1]\n      };\n\n      if (c._katavorioDrag && c.offsetParent !== this.getContainer()) {\n        var f = this.getOffset(c.offsetParent);\n        e.left += f.left, e.top += f.top;\n      }\n\n      return e;\n    },\n    setDragFilter: function setDragFilter(a, b, c) {\n      a._katavorioDrag && a._katavorioDrag.setFilter(b, c);\n    },\n    setElementDraggable: function setElementDraggable(a, c) {\n      a = b.getElement(a), a._katavorioDrag && a._katavorioDrag.setEnabled(c);\n    },\n    setDragScope: function setDragScope(a, b) {\n      a._katavorioDrag && a._katavorioDrag.k.setDragScope(a, b);\n    },\n    setDropScope: function setDropScope(a, b) {\n      a._katavorioDrop && a._katavorioDrop.length > 0 && a._katavorioDrop[0].k.setDropScope(a, b);\n    },\n    addToPosse: function addToPosse(a, c) {\n      var d = Array.prototype.slice.call(arguments, 1),\n          e = g(this);\n      b.each(a, function (a) {\n        a = [b.getElement(a)], a.push.apply(a, d), e.addToPosse.apply(e, a);\n      });\n    },\n    setPosse: function setPosse(a, c) {\n      var d = Array.prototype.slice.call(arguments, 1),\n          e = g(this);\n      b.each(a, function (a) {\n        a = [b.getElement(a)], a.push.apply(a, d), e.setPosse.apply(e, a);\n      });\n    },\n    removeFromPosse: function removeFromPosse(a, c) {\n      var d = Array.prototype.slice.call(arguments, 1),\n          e = g(this);\n      b.each(a, function (a) {\n        a = [b.getElement(a)], a.push.apply(a, d), e.removeFromPosse.apply(e, a);\n      });\n    },\n    removeFromAllPosses: function removeFromAllPosses(a) {\n      var c = g(this);\n      b.each(a, function (a) {\n        c.removeFromAllPosses(b.getElement(a));\n      });\n    },\n    setPosseState: function setPosseState(a, c, d) {\n      var e = g(this);\n      b.each(a, function (a) {\n        e.setPosseState(b.getElement(a), c, d);\n      });\n    },\n    dragEvents: {\n      start: \"start\",\n      stop: \"stop\",\n      drag: \"drag\",\n      step: \"step\",\n      over: \"over\",\n      out: \"out\",\n      drop: \"drop\",\n      complete: \"complete\",\n      beforeStart: \"beforeStart\"\n    },\n    animEvents: {\n      step: \"step\",\n      complete: \"complete\"\n    },\n    stopDrag: function stopDrag(a) {\n      a._katavorioDrag && a._katavorioDrag.abort();\n    },\n    addToDragSelection: function addToDragSelection(a) {\n      var b = this.getElement(a);\n      null == b || !b._isJsPlumbGroup && null != b._jsPlumbGroup || g(this).select(a);\n    },\n    removeFromDragSelection: function removeFromDragSelection(a) {\n      g(this).deselect(a);\n    },\n    getDragSelection: function getDragSelection() {\n      return g(this).getSelection();\n    },\n    clearDragSelection: function clearDragSelection() {\n      g(this).deselectAll();\n    },\n    trigger: function trigger(a, b, c, d) {\n      this.getEventManager().trigger(a, b, c, d);\n    },\n    doReset: function doReset() {\n      for (var a in this) {\n        0 === a.indexOf(\"_katavorio_\") && this[a].reset();\n      }\n    },\n    getEventManager: function getEventManager() {\n      return f(this);\n    },\n    on: function on(a, b, c) {\n      return this.getEventManager().on.apply(this, arguments), this;\n    },\n    off: function off(a, b, c) {\n      return this.getEventManager().off.apply(this, arguments), this;\n    }\n  });\n\n  var v = function v(a) {\n    var b = function b() {\n      /complete|loaded|interactive/.test(document.readyState) && \"undefined\" != typeof document.body && null != document.body ? a() : setTimeout(b, 9);\n    };\n\n    b();\n  };\n\n  v(b.init);\n}.call(\"undefined\" != typeof window ? window : this);","map":null,"metadata":{},"sourceType":"script"}